<html><head></head><body>
<h2 class="h2" id="ch07"><span epub:type="pagebreak" id="page_211"/><strong><span class="big">7</span><br/>ART</strong></h2>
<div class="image1"><img alt="Image" src="../images/common.jpg"/></div>
<p class="noindent">In this chapter, we’ll explore generative art—images created by algorithms that use randomness. We’ll begin with “random art,” a catchall phrase for three different approaches to producing artistic images. Alternative methods exist, but these will give you a taste of what’s possible. We’ll also learn about fractals, which were extremely popular a few decades ago when personal computers were finally powerful enough to do interesting things with graphics.</p>
<p class="indent">We’ll generate many color images in this chapter, though this book is in black and white. I suggest running the code to see them properly.</p>
<h3 class="h3" id="ch00lev1_47"><strong>Creating Random Art</strong></h3>
<p class="noindent">We’ll begin with three examples. The first mimics a program that amazed early Apple II personal computer enthusiasts. It also introduces us to Python’s turtle graphics package.</p>
<p class="indent">The second implements a random walk, effectively a simulation of Brownian motion, the wanderings of particles in a fluid when viewed through a <span epub:type="pagebreak" id="page_212"/>microscope. It’s a simple process that, with appropriate color tables, leads to pleasant images suitable for T-shirts and coffee mugs.</p>
<p class="indent">The last example warps a two-dimensional grid of points using randomly selected functions, rotations, and color tables to generate unique images, likewise suitable for print.</p>
<h4 class="h4" id="ch00lev2_66"><em><strong>Moiré Patterns</strong></em></h4>
<p class="noindent"><em>Moiré patterns</em> occur in digital images when the discrete world of the computer screen meets what should be a continuous representation, that is, when drawing a line that can’t be accurately represented by the grid imposed by the display. <a href="ch07.xhtml#ch07fig01">Figure 7-1</a> shows an example.</p>
<div class="image"><img alt="Image" id="ch07fig01" src="../images/07fig01.jpg"/></div>
<p class="figcap"><em>Figure 7-1: “Brian’s Theme” as rendered by an Apple II computer</em></p>
<p class="indent"><a href="ch07.xhtml#ch07fig01">Figure 7-1</a> is 1979’s “Brian’s Theme,” a simple BASIC program created by Brian Howard; it could be found on the Apple II DOS 3.3 system master diskette from 1983. The program selected a random point, from which it drew line after line to the edge of the screen, stepping each time by a randomly selected value. The crude resolution of the 280×160-pixel Apple II display, along with the funky way points were colored when plotting, produced a moiré pattern.</p>
<p class="indent">Let’s create our own moiré patterns. The code we want is in <em>moire.py</em>. It introduces us to Python’s turtle graphics module (<span class="literal">turtle</span>), part of the standard Python distribution.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>The phrase</em> turtle graphics <em>comes from the Logo programming language, which used a graphical “turtle” to drag a pen across the screen to teach programming concepts to children.</em></p>
</div>
<p class="noindent">Simple commands like <span class="literal">FD 10</span> (forward 10), <span class="literal">RT 90</span> (right turn 90 degrees), and <span class="literal">PD</span> (pen down) made it possible to create complex drawings with relatively little programming knowledge; imagine an old-school spirograph game, but on the computer.</p>
<p class="indent"><span epub:type="pagebreak" id="page_213"/>We want the turtle to draw straight lines from a randomly selected point near the center to the edges, stepping by some distance along the edge each time. The result is something like <a href="ch07.xhtml#ch07fig02">Figure 7-2</a>.</p>
<div class="image"><img alt="Image" id="ch07fig02" src="../images/07fig02.jpg"/></div>
<p class="figcap"><em>Figure 7-2: “Brian’s Theme” redux</em></p>
<p class="indent"><a href="ch07.xhtml#ch07fig02">Figure 7-2</a> is nothing more than straight line after straight line; the pattern emerges from the moiré effect.</p>
<p class="indent">First, we import the necessary modules and ask the turtle to configure the display:</p>
<pre class="pre">import time
import turtle as tu
from RE import *

tu.speed(0)
tu.ht()
tu.getscreen().setup(500,500)
tu.getscreen().bgcolor('black')

x = np.linspace(-200,200,400)
y = np.linspace(-200,200,400)</pre>
<p class="noindent">We configure the turtle, here <span class="literal">tu</span>, to go as fast as it can and then hide itself (<span class="literal">ht</span> for “hide turtle”). This way, we see only what it draws.</p>
<p class="indent">The drawing window is adjusted to 500×500 pixels with a black background. The <em>x</em> and <em>y</em> dimensions follow using NumPy’s <span class="literal">linspace</span> to generate <span epub:type="pagebreak" id="page_214"/>400 point vectors spanning –200 to 200. The turtle’s screen places the origin in the center of the display window.</p>
<p class="indent">We’ll draw a moiré pattern, wait a bit, then clear the screen and draw another—interactive visual art at its finest. We need a loop:</p>
<pre class="pre">while (True):
    tu.clear()
    X,Y = RE(mode='int', low=-100, high=100).random(2)
    step = RE(mode='int', low=2, high=9).random()
    r,g,b = RE(mode='int', low=1, high=256).random(3)
    color = "#%02x%02x%02x" % (r,g,b)
    tu.color(color)

    for i in range(0,400,step):
        Line(X,Y, x[i],y[0], color)
        Line(X,Y, x[0],y[i], color)
        Line(X,Y, x[i],y[-1], color)
        Line(X,Y, x[-1],y[i], color)

    time.sleep(4)</pre>
<p class="indent">To start a drawing, we clear the screen and select the origin point (<span class="literal">X</span>, <span class="literal">Y</span>) and the <span class="literal">step</span> size. We specify color as red, green, and blue using HTML notation; for example, <span class="literal">#FF0000</span> is bright red, <span class="literal">#E0B0FF</span> is mauve, <span class="literal">#A0522D</span> is sienna, and so on, mixing red, green, and blue in proportion.</p>
<p class="indent">A simple loop then uses <span class="literal">Line</span> to draw the pattern from the center point to each of the four screen edges:</p>
<pre class="pre">def Line(x0,y0,x1,y1,color):
    tu.color('white')
    tu.pu()
    tu.goto(x0,y0)
    tu.pd()
    tu.goto(x1,y1)
    tu.color(color)
    tu.goto(x0,y0)
    tu.pu()</pre>
<p class="indent">The <span class="literal">Line</span> method first draws the requested line in white, then backs over it using the randomly selected color to produce a flashing effect.</p>
<p class="indent">Given the speed of modern computers, you might expect the moiré pattern to flash on the screen. However, Python’s turtle is similar to its namesake in that it draws the pattern at its leisure, essentially matching the speed of the Apple II code we’re mimicking.</p>
<p class="indent">We’ll return to turtle graphics later in the chapter. For now, it’s time to take a walk.</p>
<h4 class="h4" id="ch00lev2_67"><span epub:type="pagebreak" id="page_215"/><em><strong>Random Walks</strong></em></h4>
<p class="noindent">A <em>random walk</em> algorithm follows the “two steps forward, one step backward” model in two dimensions: beginning at the origin, repeatedly take steps in random directions. To turn this trivial algorithm into art, we track the sequence of steps to create an image where each step is assigned a color from one of Matplotlib’s color tables.</p>
<p class="indent">A color table—also called a color map or lookup table—is a list of colors in red, green, and blue format. Most color tables, Matplotlib’s included, have 256 entries. For example, if some value of interest is 129, or assignable to 129, then the associated color is stored at index 129 of the color table currently in use.</p>
<p class="indent">If the desired index is 129 and the color table is <span class="literal">viridis</span>, then the resulting RGB color value is:</p>
<pre class="pre">&gt;&gt;&gt; <span class="codestrong1">from matplotlib import cm</span>
&gt;&gt;&gt; <span class="codestrong1">cmap = cm.get_cmap("viridis")</span>
&gt;&gt;&gt; <span class="codestrong1">cmap(129)</span>
(0.126453, 0.570633, 0.549841, 1.0)</pre>
<p class="noindent">This code snippet demonstrates how to access Matplotlib’s color tables, but the output might not be as expected. Why are there four values, and why are they not in the range [0, 255] like turtle graphics’ hexadecimal color values? RGB color values are often mapped to [0, 1], or as fractions of the maximum possible value of 1.0. To find the corresponding byte value, multiply by 255 and keep the integer part. The color in the previous code is <span class="literal">#20918C</span> in hexadecimal.</p>
<p class="indent">This explains the first three values, but the fourth component is the alpha value, representing the color’s transparency. An alpha value of 1.0 is opaque, 0.0 is transparent, and 0.5 blends the color and the color of the pixel behind it (similar to stacked graphics planes). For our purposes, we’ll allow for transparent backgrounds (what this means will become apparent when examining the code).</p>
<p class="indent">Matplotlib comes with 84 predefined color tables, called <em>maps</em>; see <em>color_map_names.txt</em> for a list. Our random walk code supports all of them in any combination.</p>
<p class="indent">While random walks “repeatedly take steps in random directions,” I didn’t specify the allowed set of directions. From a point, (<em>x</em>, <em>y</em>), there are either four or eight possible directions one might go, as shown in <a href="ch07.xhtml#ch07fig03">Figure 7-3</a>.</p>
<div class="image"><img alt="Image" id="ch07fig03" src="../images/07fig03.jpg"/></div>
<p class="figcap"><em>Figure 7-3: The four (left) or eight (right) directions a random walker can move</em></p>
<p class="indent">Random walkers on the left (called <em>4-connected</em>) are restricted to the cardinal directions: north, south, east, or west. Those on the right (<em>8-connected</em>) <span epub:type="pagebreak" id="page_216"/>have the option to walk diagonally. The code in <em>walker.py</em> supports both options.</p>
<p class="indent">Notice how the offsets from (<em>x</em>, <em>y</em>) are marked. If you’re used to plotting with Cartesian coordinates, as in math class, you might be a bit thrown by the signs. Ordinarily, we expect to plot in the first quadrant with <em>x</em> and <em>y</em> both positive and increasing to the right and up, respectively; this is not how most computers handle things. Instead, they put the origin at the upper-left corner of the screen so <em>y</em> increases as you move down and <em>x</em> increases as you move to the right. Mathematically, we’re plotting in the fourth quadrant and ignoring the sign of the <em>y</em>-axis.</p>
<p class="indent">Let’s run <em>walker.py</em> and see what it gives us:</p>
<pre class="pre">&gt; <span class="codestrong1">python3 walker.py 4 1000000 Reds,Oranges,Reds,Oranges none portrait tshirt.png mt19937 8675309</span></pre>
<p class="noindent">The command produces an output image according to the given extension, here a PNG file; see <a href="ch07.xhtml#ch07fig04">Figure 7-4</a>.</p>
<div class="image"><img alt="Image" id="ch07fig04" src="../images/07fig04.jpg"/></div>
<p class="figcap"><em>Figure 7-4: Sample random walker output</em></p>
<p class="indent">The first argument tells the code to take a 4-connected walk. The second is the number of steps to take <em>per specified color table</em>. The color tables come next, separated by commas and no spaces. Here, I’ve repeatedly used Matplotlib’s <span class="literal">Reds</span> and <span class="literal">Oranges</span>. With 1,000,000 steps per color table and four color tables, the image in <a href="ch07.xhtml#ch07fig04">Figure 7-4</a> represents a stroll of 4 million random steps, each generating a single pixel.</p>
<p class="indent">After the color tables, we add the background color or the word <span class="literal">none</span> for a transparent background. We can specify colors using HTML hexadecimal <span epub:type="pagebreak" id="page_217"/>format without the leading <span class="literal">#</span> so that <span class="literal">000000</span> is a black background and <span class="literal">FFFFFF</span> is white.</p>
<p class="indent">The following argument is the orientation for the output image. The walk will naturally be more extensive in one direction or the other. This argument orients the output as either <span class="literal">portrait</span> so the longest dimension of the output image is in the <em>y</em> direction, or <span class="literal">landscape</span> to use the <em>x</em> dimension.</p>
<p class="indent">The final two arguments are the randomness source and seed value for the source. Both are optional.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>I called the output file</em> tshirt.png <em>because I used this example to make an actual T-shirt. There are multiple online services where you can upload an image and order a shirt. If you want to make your own, I recommend many millions of steps, a transparent background, and even encapsulated PostScript output format (use a</em> .eps <em>file extension on the command line).</em></p>
</div>
<p class="indent">Let’s take a walk through <em>walker.py</em>. I’ll skip the part that imports the usual modules and parses the command line. Here’s the code:</p>
<pre class="pre">if (len(sys.argv) == 8):
    kind = sys.argv[7]
    rng = RE(kind=kind, mode="int", low=0, high=mode)
elif (len(sys.argv) == 9):
    kind = sys.argv[7]
    seed = int(sys.argv[8])
    rng = RE(kind=kind, mode="int", low=0, high=mode, seed=seed)
else:
    rng = RE(mode="int", low=0, high=mode)</pre>
<p class="indent">We begin by configuring the randomness source. In this case, we choose random integers in the range [0, 3] if 4-connected and [0, 7] if 8-connected. We’ll use the values as indices into a list of <em>x</em> and <em>y</em> offsets and add the offsets to the current point to take a step. The three cases in the code handle specifying a randomness source, a source with a seed value, or defaults.</p>
<p class="indent">Next comes the walk. The main loop tracks points in the lists <span class="literal">X</span> and <span class="literal">Y</span>, with colors in <span class="literal">C</span>. At this level, the loop is over the specified color tables:</p>
<pre class="pre">X = []; Y = []; C = []
for cname in cnames:
    x,y,c = Walk(steps,cname,mode)
    X = X + x
    Y = Y + y
    C = C + c</pre>
<p class="noindent">The <span class="literal">Walk</span> function simulates a complete walk of <span class="literal">steps</span> steps for the current color table (<span class="literal">cname</span>) and <span class="literal">mode</span>:</p>
<pre class="pre">def Walk(steps, cname, mode):
    try:
        cmap = cm.get_cmap(cname)
    <span epub:type="pagebreak" id="page_218"/>except:
        cmap = cm.get_cmap("inferno")
    if (mode == 8):
        offset = [[0,-1],[1,-1],[1,0],[1,1],[0,1],[-1,1],[-1,0],[-1,-1]]
    else:
        offset = [[0,-1],[1,0],[0,1],[-1,0]]
    X = [0]
    Y = [0]
    C = [cmap(0)]
    for i in range(steps):
        m = rng.random()
        X.append(X[-1] + offset[m][0])
        Y.append(Y[-1] + offset[m][1])
     <span class="ent">➊</span> c = cmap(int(256*i/steps))
        C.append((c[0],c[1],c[2]))
    return X,Y,C</pre>
<p class="indent">First, we get the color table (<span class="literal">cmap</span>), and then we define <span class="literal">offset</span>, a list of <em>x</em> and <em>y</em> offset values for 4-connected and 8-connected walks. The walk itself begins at (0, 0) using the color at index 0 (<span class="literal">C</span>).</p>
<p class="indent">The loop over <span class="literal">steps</span> simulates the walk. We add a randomly selected offset to the last position for both <em>x</em> and <em>y</em>. Consider the code to select the color <span class="ent">➊</span>. The loop index, <span class="literal">i</span>, ranges over [0, steps). Dividing by <span class="literal">steps</span> produces a fraction, [0, 1). Multiplying by 256 selects an index of the color table. Therefore, a full random walk steps through the entire color table once. There are other options to experiment with; see “Exercises” on <a href="ch07.xhtml#ch00lev1_49">page 238</a>.</p>
<p class="indent">For now, there is no output image, only a collection of points (<em>x</em>, <em>y</em>) and associated colors in <span class="literal">C</span>. To make an image, we need <span class="literal">CreateOutputImage</span>:</p>
<pre class="pre">def CreateOutputImage(X,Y,C, background):
    x = np.array(X)
    y = np.array(Y)
    xmin = x.min(); xmax = x.max()
    dx = xmax - xmin
    ymin = y.min(); ymax = y.max()
    dy = ymax - ymin
    img = np.zeros((dy,dx,4), dtype="uint8")
    
    if (background is not None) and (background != "none"):
        try:
            r = int(background[:2],16)
            g = int(background[2:4],16)
            b = int(background[4:],16)
            a = 255
        except:
            r,g,b,a = 0,0,0,0
    else:
        r,g,b,a = 0,0,0,0<span epub:type="pagebreak" id="page_219"/>
    img[:,:,0] = r; img[:,:,1] = g
    img[:,:,2] = b; img[:,:,3] = a

    for i in range(len(x)):
        xx = int((dx-1)*(x[i] - xmin) / dx)
        yy = int((dy-1)*(y[i] - ymin) / dy)
        c = C[i]
        img[yy,xx,0] = int(255*c[0])
        img[yy,xx,1] = int(255*c[1])
        img[yy,xx,2] = int(255*c[2])
        img[yy,xx,3] = 255
    return img</pre>
<p class="indent">The function is in three parts. The first makes NumPy vectors of the <em>x</em> and <em>y</em> points and determines the extent in each direction (<span class="literal">dx</span>, <span class="literal">dy</span>) to specify the output image, <span class="literal">img</span>. The output image uses 4 as the number of channels, not 3 as we’ve used previously; because we want to support a transparent background, we need to explicitly specify the alpha channel.</p>
<p class="indent">Next, we set the entire image to the transparent background color. Use 0 for the alpha channel for a transparent background and 255 for one that is completely opaque.</p>
<p class="indent">We loop over the points, mapping each point to a pixel of the image with explicit red, green, and blue color values. Review the assignments to <span class="literal">xx</span> and <span class="literal">yy</span> to follow how they map raw points to valid image coordinates.</p>
<p class="indent">Notice how <span class="literal">img</span> is indexed. The code assigns the point (<em>x</em>, <em>y</em>) to the image, but the image is indexed as <span class="literal">(yy,xx)</span>. Images are indexed by row and then by column, meaning the <em>y</em>-coordinate—using the origin at the upper-left corner convention—represents the row, and the <em>x</em> the column.</p>
<p class="indent">We’re almost done. The <span class="literal">CreateOutputImage</span> function returns the image as specified by the actual points of the walk. To produce the final output, we reorient the image to respect the portrait or landscape orientation:</p>
<pre class="pre">img = CreateOutputImage(X,Y,C,background)
rows, cols, _ = img.shape
if (orient == "portrait"):
    if (rows &lt; cols):
        img = img.transpose([1,0,2])
else:
    if (rows &gt; cols):
        img = img.transpose([1,0,2])
Image.fromarray(img).save(oname)</pre>
<p class="noindent">The <span class="literal">transpose</span> method rearranges the columns of a NumPy array as specified. We swap rows and columns as needed, but ensure the number of channels remains in place. Read through <em>walker.py</em> to follow the overall flow of the code.</p>
<p class="indent">I’ve included several example outputs in the chapter files to inspire you to create your own. I especially like <em>example1.png</em>; it reminds me of the sci-fi <span epub:type="pagebreak" id="page_220"/>sets used in <em>Doctor Who</em> episodes from the 1970s. The <em>example5.png</em> file uses <em>hotbits.bin</em> when that file was 1,130,496 bytes. The cyclic pattern is due to the number of requested points, which exceeds the number of random samples extracted from the file, thereby repeating. The <em>example5.txt</em> file contains the text of the command. If you create any compelling examples, please share them. I’ll make a small gallery on the book’s GitHub page.</p>
<p class="indent">Let’s change gears and use randomness in combination with determinism to produce images constructed from warpings of the <em>xy</em>-plane.</p>
<h4 class="h4" id="ch00lev2_68"><em><strong>A Grid</strong></em></h4>
<p class="noindent">What happens if you take an evenly spaced grid of points in two dimensions, apply a function that maps each point to a new point, then plot the points? In other words, what happens when you warp a grid of points? In this section, we’ll discover the answer and use it to build random works of abstract digital art.</p>
<p class="indent"><a href="ch07.xhtml#ch07fig05">Figure 7-5</a> illustrates the basic process.</p>
<div class="image"><img alt="Image" id="ch07fig05" src="../images/07fig05.jpg"/></div>
<p class="figcap"><em>Figure 7-5: A grid of points (left) and the same grid warped (right)</em></p>
<p class="indent">On the left of <a href="ch07.xhtml#ch07fig05">Figure 7-5</a>, we have a grid of 30×30 points. We apply a function to each point, (<em>x</em>, <em>y</em>), to generate a new point, (<em>x′</em>, <em>y′</em>), plotted on the right of <a href="ch07.xhtml#ch07fig05">Figure 7-5</a>.</p>
<p class="indent">The function is:</p>
<p class="center">(<em>x′</em>, <em>y′</em>) <em>←</em> (<em>y</em><sup>3</sup> + <em>x</em>, <em>x</em><sup>2</sup> + <em>y</em>)</p>
<p class="noindent">For input point (<em>x</em>, <em>y</em>), the output <em>x</em>-coordinate is <em>y</em><sup>3</sup> + <em>x</em> and the <em>y</em>-coordinate is <em>x</em><sup>2</sup> + <em>y</em>.</p>
<p class="indent">Likewise, the function (<em>x</em>, <em>y</em>) <em>→</em> (<em>yx</em><sup>2</sup>, <em>xy</em><sup>2</sup>) changes the uniform grid of points into <a href="ch07.xhtml#ch07fig06">Figure 7-6</a>.<span epub:type="pagebreak" id="page_221"/></p>
<div class="image"><img alt="Image" id="ch07fig06" src="../images/07fig06.jpg"/></div>
<p class="figcap"><em>Figure 7-6: A uniform grid warped by (</em>x,y<em>) → (</em>yx<sup><em>2,</em></sup> xy<sup><em>2</em></sup><em>)</em></p>
<p class="indent">We’ll generate a set of warping functions, select one randomly, and apply it to the uniform grid of points. Then, we repeat this process for a specified number of cycles, keeping all output points as we go.</p>
<p class="indent">To add color, we make each warping function return a color table index along with the new point location. Therefore, each warping function maps an input point to a new output point and color table index. Each cycle selects a new color table at random.</p>
<p class="indent">To add more randomness, we’ll shift the collection of points by adding randomly selected <em>x</em> and <em>y</em> offsets. Because we’re adventurous types, we’ll also rotate the points by a random angle about the origin.</p>
<p class="indent">I’ve defined a collection of five warping functions, two of which we’ve already seen:</p>
<div class="image1"><img alt="Image" src="../images/f0221-01.jpg"/></div>
<p class="noindent">The input grid is always in [–1, 1]. Each function returns the new point and color table index found by keeping the integer part after multiplying the third return value by 255. The cumulative effect of the random function applications, rotations, offsets, and color tables produces the desired output image.</p>
<p class="indent"><span epub:type="pagebreak" id="page_222"/>The code is in <em>warp.py</em>. Run it like so</p>
<pre class="pre">&gt; <span class="codestrong1">python3 warp.py 300 11 example.png minstd 6502</span></pre>
<p class="noindent">to produce <a href="ch07.xhtml#ch07fig07">Figure 7-7</a>.</p>
<div class="image"><img alt="Image" id="ch07fig07" src="../images/07fig07.jpg"/></div>
<p class="figcap"><em>Figure 7-7: Warping in action</em></p>
<p class="indent">The first argument to <em>warp.py</em> is the number of points along each grid dimension. The second is the number of cycles, or the number of times we apply a randomly selected function to the grid. Finally, the last three arguments are the output image name, randomness source, and seed, if desired.</p>
<p class="indent">First are the warp functions. For example:</p>
<pre class="pre">def f0(a,b):
    x,y = a**3 + b, b**2 + a
    c = int(255*(a*b+1)/2)
    return x,y,c</pre>
<p class="noindent">This implements the first warping function in the collection. The remaining four functions are similar. We store the warp functions in a list so they can be selected at random:</p>
<pre class="pre">funcs = [f0,f1,f2,f3,f4]</pre>
<p class="indent">The main body of <em>warp.py</em> parses the command line and loads the color table names from <em>color_map_names.txt</em>. It then defines empty lists to hold all the (<em>x</em>, <em>y</em>) points and associated RGB colors, <span class="literal">X</span>, <span class="literal">Y</span>, and <span class="literal">C</span>, respectively.</p>
<p class="indent">The grid is specified as an <span class="literal">npoints</span> long vector from –1 to +1:</p>
<pre class="pre">v = -1 + 2*np.arange(npoints)/npoints</pre>
<p class="indent"><span epub:type="pagebreak" id="page_223"/>All the action is in the loops over cycles and grid points:</p>
<pre class="pre">for k in range(cycles):
    n = int(len(cnames)*rng.random())
    cmap = cm.get_cmap(cnames[n])
    n = int(len(funcs)*rng.random())
    fn = funcs[n]
    xoff,yoff = rng.random(2)-0.5
    theta = np.pi*rng.random()
    for i in range(len(v)):
        for j in range(len(v)):
            n,m,c = fn(v[i],v[j])
            x = n*np.cos(theta) - m*np.sin(theta)
            y = n*np.sin(theta) + m*np.cos(theta)
            X.append(x+xoff)
            Y.append(y+yoff)
            C.append(cmap(c))</pre>
<p class="indent">The outermost loop over <span class="literal">k</span> handles the cycles. Each cycle randomly selects a color map (<span class="literal">cmap</span>) and a warp function (<span class="literal">fn</span>). It also selects random <em>x</em> and <em>y</em> offsets (<span class="literal">xoff</span>, <span class="literal">yoff</span>) and a rotation angle (<span class="literal">theta</span>).</p>
<p class="indent">The two inner loops, over <span class="literal">i</span> and <span class="literal">j</span>, walk through <span class="literal">v</span> in both the <em>x</em> and <em>y</em> directions; they visit every point in the 2D grid. The selected function is applied to each point, <span class="literal">n,m,c = fn(v[i],v[j])</span>, to return a new point (<em>n</em>, <em>m</em>) and color table index (<span class="literal">c</span>). To rotate a point about the origin, we multiply it by a rotation matrix</p>
<div class="image1"><img alt="Image" src="../images/f0223-01.jpg"/></div>
<p class="noindent">which, following the rules for matrix multiplication, becomes:</p>
<div class="image1"><img alt="Image" src="../images/f0223-02.jpg"/></div>
<p class="noindent">This matches the previous code.</p>
<p class="indent">Rotation complete, the final step is to add the <em>x</em> and <em>y</em> offsets. These shift the points in the <em>x</em> and <em>y</em> directions to keep them from overlapping.</p>
<p class="indent">Every warped, rotated, and offset point is appended to the list of points and colors. Notice that the warping function returns a color table index, but <span class="literal">C</span> holds the tuple returned by <span class="literal">cmap</span> for the current color table.</p>
<p class="indent">With all cycles complete, we produce the plot and dump it to disk. Matplotlib obliges:</p>
<pre class="pre">plt.scatter(X,Y, marker=',', s=0.6, c=C)
plt.axis('off')
plt.tight_layout(pad=0, h_pad=0, w_pad=0)
plt.savefig(oname, dpi=300)
plt.show()</pre>
<p class="noindent"><span epub:type="pagebreak" id="page_224"/>Here <span class="literal">oname</span> is the output image name; it’s taken from the command line argument.</p>
<p class="indent">Unlike Matplotlib’s <span class="literal">plot</span> command, <span class="literal">scatter</span> accepts a list of per-point colors, which is why we constructed <span class="literal">C</span> for each point. The <span class="literal">tight_layout</span> command removes extraneous space, which is handy after turning the axes off.</p>
<p class="indent">Run <em>warp.py</em> a few times to experiment with the code. If you make the grid too fine, with the first argument above 300 or thereabouts, you may run out of memory. While it isn’t necessary to specify a pseudorandom generator and seed value, doing so lets you re-create the output. The file <em>warp_factor_9.py</em> uses a single pseudorandom generator with a user-supplied global seed to create a specified number of warp images. I ran the command</p>
<pre class="pre">&gt; <span class="codestrong1">python3 warp_factor_9.py 3141592 100 warpings</span></pre>
<p class="noindent">to create 100 images in the <em>warpings</em> directory. It took about 15 minutes to run and produced some attractive output. Matplotlib’s cyclic color tables, like <span class="literal">flag</span>, make stunning displays.</p>
<p class="indent">While <em>warp.py</em> makes pretty pictures, the randomness isn’t particularly profound; it selects from among a set of options, relying on combinations of possible options to produce novelty.</p>
<p class="indent">The following section introduces us to fractals: a world of math, emergent behavior, and randomness.</p>
<h3 class="h3" id="ch00lev1_48"><strong>Fun with Fractals</strong></h3>
<p class="noindent"><em>Fractals</em> are mathematical objects constructed from smaller copies of themselves; they are <em>self-similar</em>. Mathematical fractals are our focus, but approximate fractals are a common sight in nature—for example, the branching of a tree, the airways in your lungs, and the fronds of a fern.</p>
<p class="indent">In this section, we’ll explore randomness as a means of generating fractal images. There is a rich literature on fractals for art and computer graphics. We’ll accomplish the barest of introductions.</p>
<p class="indent">First, we’ll play the chaos game to build simple fractal images with Python’s turtle. Then, we’ll learn about a more sophisticated approach to generating fractal images, iterated function systems (IFS). Finally, we’ll put everything together to build <em>ifs.py</em>.</p>
<h4 class="h4" id="ch00lev2_69"><em><strong>The Chaos Game</strong></em></h4>
<p class="noindent">Let’s play the <em>chaos game</em>, so named by mathematician and fractal explorer Michael Barnsley. It works like this:</p>
<ol>
<li class="noindent">Pick three points, (<em>x</em><sub>0</sub>, <em>y</em><sub>0</sub>), (<em>x</em><sub>1</sub>, <em>y</em><sub>1</sub>), and (<em>x</em><sub>2</sub>, <em>y</em><sub>2</sub>), to form the vertices of a triangle.</li>
<li class="noindent">Set <em>x</em> = <em>x</em><sub>0</sub> and <em>y</em> = <em>y</em><sub>0</sub>.</li>
<li class="noindent">Pick a vertex of the triangle at random, (<em>x<sub>n</sub></em>, <em>y<sub>n</sub></em>) for <em>n</em> in [0, 2].</li>
<li class="noindent">Update using <em>x ←</em> 0.5(<em>x</em> + <em>x<sub>n</sub></em>) and <em>y ←</em> 0.5(<em>y</em> + <em>y<sub>n</sub></em>).</li>
<li class="noindent"><span epub:type="pagebreak" id="page_225"/>Plot (<em>x</em>, <em>y</em>).</li>
<li class="noindent">Repeat from step 3.</li>
</ol>
<p class="noindent">This algorithm plots points in the <em>xy</em>-plane. Let’s find out whether the set of points eventually covers the plane, or there’s a pattern of some kind. Run <em>sierpinski.py</em>:</p>
<pre class="pre">&gt; <span class="codestrong1">python3 sierpinski.py</span></pre>
<p class="noindent">A small window should appear. The Python turtle is also there, jumping around the window seemingly at random. Each time it moves, it leaves a small dot behind. The dot color corresponds to which triangle vertex was selected in step 3.</p>
<p class="indent">Let the program run for some length of time to draw whatever it is it wants to draw. When you have waited as long as you can for the turtle to do its thing, press a key and examine the resulting image. It should look similar to <a href="ch07.xhtml#ch07fig08">Figure 7-8</a>.</p>
<div class="image"><img alt="Image" id="ch07fig08" src="../images/07fig08.jpg"/></div>
<p class="figcap"><em>Figure 7-8: The chaos game in action</em></p>
<p class="noindent">The image is a fractal known as the Sierpiński triangle after Wacław Sierpiński, a Polish mathematician who explored such shapes in 1915.</p>
<p class="indent">Fractals are constructed from copies of themselves. For example, the main triangle is built from three smaller triangles, each constructed from three still smaller triangles, and so on forever. Therefore, the game didn’t fill the <em>xy</em>-plane but only a subset of points on it. Such things are called “fractal” because their dimension is a noninteger.</p>
<p class="indent"><span epub:type="pagebreak" id="page_226"/>The fractal is more than a line, dimension 1, and less than a plane, dimension 2. There are multiple ways to define a fractal dimension, but perhaps the most common is the Hausdorff dimension. For the Sierpiński triangle, the Hausdorff dimension is log 3 / log 2 = 1.5849625 . . . , greater than a line but less than a plane.</p>
<p class="indent">Let’s look at <em>sierpinski.py</em>, shown in <a href="ch07.xhtml#ch07list01">Listing 7-1</a>.</p>
<pre class="pre">X = [-200,0,200];  Y = [-200,200,-200]
x = X[0]; y = Y[0]
colors = ['#E7FFAC','#ACE7FF','#97A2FF']
tu.color(colors[0])
rng = RE(mode='int', low=0, high=3)

done = False
def Done():
    global done
    done = True
tu.onkeypress(Done)
tu.listen()

while (not done):
    n = rng.random()
    x = 0.5*(x + X[n])
    y = 0.5*(y + Y[n])
    tu.color(colors[n])
    tu.goto(x,y)
    tu.pd()
    tu.dot(1)
    tu.pu()

tu.ht()
tu.done()</pre>
<p class="list" id="ch07list01"><em>Listing 7-1: Uncovering the Sierpiński triangle</em></p>
<p class="indent">The first code paragraph configures the turtle, some colors, and the pseudorandom generator (<span class="literal">rng</span>). It also defines two lists holding the triangle’s vertices, <span class="literal">X</span> and <span class="literal">Y</span>. The other important bit is assigning <span class="literal">x</span> and <span class="literal">y</span> to the first vertex. Any random initial value will do, but a few iterations of the game might be necessary to land on points within the fractal.</p>
<p class="indent">The second paragraph is merely for convenience. It defines a global, <span class="literal">done</span>, and an event handler for turtle graphics to call when we press a key. The handler’s sole task is to set global <span class="literal">done</span> to <span class="literal">True</span> so the <span class="literal">while</span> loop exits. The turtle’s <span class="literal">onkeypress</span> and <span class="literal">listen</span> methods tell the turtle that it should listen for keypresses in the drawing window and perform some action when it hears one.</p>
<p class="indent">All the cool stuff is in the third paragraph—the <span class="literal">while</span> loop that runs until a keypress. It selects a vertex at random, <span class="literal">n</span>, and updates <span class="literal">x</span> and <span class="literal">y</span> before <span epub:type="pagebreak" id="page_227"/>placing a properly colored dot at that point. The process repeats, placing point after point.</p>
<p class="indent">The chaos game uses the vertices of the triangle and randomness to uncover the <em>attractor</em> of the fractal, or the set of points that make up the fractal.</p>
<p class="indent">The chaos game works for <em>n</em>-sided polygons (<em>n</em> &gt; 2) as well, as the code in <em>polygon.py</em> demonstrates. I won’t walk through it here; it’s a glorified version of <em>sierpinski.py</em> accepting <em>n</em> on the command line, followed, optionally, by a randomness source and a seed value. <a href="ch07.xhtml#ch07fig09">Figure 7-9</a> shows the results for <em>n</em> = 5 and <em>n</em> = 9.</p>
<div class="image"><img alt="Image" id="ch07fig09" src="../images/07fig09.jpg"/></div>
<p class="figcap"><em>Figure 7-9: The chaos game with five-sided (left) and nine-sided polygons (right)</em></p>
<p class="indent">Read through <em>polygon.py</em> to understand what it’s doing.</p>
<h4 class="h4" id="ch00lev2_70"><em><strong>Iterated Function Systems</strong></em></h4>
<p class="noindent">This section introduces us to <em>iterated function systems (IFS)</em>, systems of equation that map points in the plane to other locations. In the following section, we combine IFS and the chaos game to generate fractals, the attractors of the IFS. Let this serve as a warning that there’s math with vectors and matrices ahead. If these are unfamiliar beasts, have no worries. We can use IFS to make fantastic images without grasping all of the details behind the process. Still, it’s best to understand at a deeper level if we have the option.</p>
<p class="indent">To build an IFS, we need to understand a few concepts. First, that matrices map vectors in the <em>xy</em>-plane to new vectors in the <em>xy</em>-plane. Second, that a vector in the <em>xy</em>-plane is another way to refer to a point, (<em>x</em>, <em>y</em>). Third, what a contraction mapping is. And finally, that a set of contraction mappings—with offset vectors and associated probabilities—forms an IFS, enabling us to use the chaos game to create fractal images. Let’s begin.</p>
<p class="indent">Earlier, we used a matrix to rotate a set of points by some angle, <em>θ</em>, about the origin:</p>
<div class="image1"><img alt="Image" src="../images/f0227-01.jpg"/></div>
<p class="noindent">We write this as <em><strong>x</strong>′</em> = <em><strong>Mx</strong></em>, where the bold lowercase letters are vectors and the bold uppercase letter is a matrix.</p>
<p class="indent"><span epub:type="pagebreak" id="page_228"/>To be more specific, multiplying a two-dimensional vector</p>
<div class="image1"><img alt="Image" src="../images/f0228-01.jpg"/></div>
<p class="noindent">by a matrix</p>
<div class="image1"><img alt="Image" src="../images/f0228-02.jpg"/></div>
<p class="noindent">maps the vector to a new two-dimensional vector, <em><strong>x</strong>′</em>:</p>
<div class="image1"><img alt="Image" src="../images/f0228-03.jpg"/></div>
<p class="noindent">This also shows us how to multiply a two-dimensional vector by a matrix: multiply each element of the rows of the matrix by the corresponding element of the vector and sum. We say the matrix <em><strong>M</strong></em> is a <em>mapping</em> from <em><strong>x</strong></em> to <em><strong>x</strong>′</em>.</p>
<p class="indent">In <a href="ch03.xhtml">Chapter 3</a>, we learned about the Euclidean distance between two points. Consider two vectors, <em><strong>x</strong></em><sub>0</sub> and <em><strong>x</strong></em><sub>1</sub>, and their mappings under matrix <em><strong>M</strong></em>: <img alt="Image" class="inline" src="../images/f0228-03a.jpg"/> and <img alt="Image" class="inline" src="../images/f0228-03b.jpg"/>. If <em>d</em>(<em><strong>x</strong></em><sub>0</sub>, <em><strong>x</strong></em><sub>1</sub>) is the Euclidean distance between <em><strong>x</strong></em><sub>0</sub> and <em><strong>x</strong></em><sub>1</sub>, and we have</p>
<div class="image1"><img alt="Image" src="../images/f0228-04.jpg"/></div>
<p class="noindent">for 0 &lt; <em>α</em> &lt; 1, then <em><strong>M</strong></em> is a <em>contraction mapping</em> that moves points together. We’ll use contraction mappings for our IFS, with each mapping represented by a matrix.</p>
<p class="indent">A mapping may also include a constant offset vector added to the vector found by applying the matrix. We write this as</p>
<div class="image1"><img alt="Image" src="../images/f0228-05.jpg"/></div>
<p class="noindent">where adding vectors is element-wise, like NumPy. However, it’s more convenient to replace the 2×2 matrix with a 3×3 matrix incorporating the offset vector:</p>
<div class="image1"><img alt="Image" src="../images/f0228-06.jpg"/></div>
<p class="indent">A set of contraction mapping matrices, {<em><strong>M</strong></em><sub>0</sub>, <em><strong>M</strong></em><sub>1</sub>, <em><strong>M</strong></em><sub>2</sub>, . . . }, forms an IFS where each <em><strong>M</strong></em> is a 3×3 matrix combining a mapping with an offset vector. IFS have <em>attractors</em>, sets of points that subsequent mappings with the IFS send back to other points in the attractor. In this way, mapping a point on the attractor using one of the matrices in the IFS results in another point on the attractor. The points forming the attractor are the fractal we want to image, and the chaos game is the tool we use to find them.</p>
<h4 class="h4" id="ch00lev2_71"><em><strong>Fractals Plotted with Points</strong></em></h4>
<p class="noindent">We’re almost where we need to be. We have an IFS, a collection of matrices, <em><strong>M</strong></em>. We also know that the chaos game helps us find the points on the <span epub:type="pagebreak" id="page_229"/>attractor of the IFS. To adapt the chaos game to a set of matrices, we assign a probability to each map. Then, when playing the chaos game, we select the next map to apply based on that probability. The assigned probabilities alter the weighting of the attractor points.</p>
<p class="indent">Let’s get practical. The code we’ll work with is in <em>ifs.py</em>. Read through the file to give yourself an overview. The majority of the file is the <span class="literal">IFS</span> class. Running <em>ifs.py</em> without arguments teaches us how to configure the command line:</p>
<pre class="pre">&gt; <span class="codestrong1">python3 ifs.py</span>

ifs &lt;points&gt; &lt;output&gt; &lt;fractal&gt; &lt;color&gt; [&lt;kind&gt; | &lt;kind&gt; &lt;seed&gt;]

  &lt;points&gt;   - number of points to calculate
  &lt;output&gt;   - output image
  &lt;fractal&gt;  - name from the list below or 'random'
  &lt;color&gt;    - &lt;hex&gt; (no '#')|maps
  &lt;kind&gt;     - randomness source
  &lt;seed&gt;     - seed value

circle dragon fern koch shell sierpinski tree thistle 
maple spiral mandel tree2 tree3 fern2 dragon2</pre>
<p class="indent">The words at the bottom of the output are assigned to different IFS, meaning different sets of mappings and probabilities. We specify the IFS we want on the command line by name. The maps are hardcoded in a dictionary embedded in the <span class="literal">IFS</span> class. For example, here’s the definition of the <span class="literal">sierpinski</span> IFS:</p>
<pre class="pre">"sierpinski": {
    "nmaps":3,
    "probs":[0.3333,0.3333,0.3333],
    "maps":[
           [[.5, 0, 0], [0, .5, 0], [0,0,1]],
           [[.5, 0, .5], [0, .5, 0], [0,0,1]],
           [[.5, 0, .25], [0, .5, .5], [0,0,1]]]},</pre>
<p class="indent">The IFS consists of three maps, or three 3×3 matrices:</p>
<div class="image1"><img alt="Image" src="../images/f0229-01.jpg"/></div>
<p class="noindent">Each is selected with probability 1/3 and is equally likely to be chosen when playing the chaos game.</p>
<p class="indent">The other IFS are defined similarly, though with more or fewer maps, as necessary. The <span class="literal">maple</span> IFS, and those following, are by Paul Bourke (<em><a href="https://paulbourke.net/fractals/ifs">https://paulbourke.net/fractals/ifs</a></em>), used with permission. Bourke’s site is a treasure trove of fascinating computer graphics and geometry pages, including many on fractals and IFS. I highly recommend taking a look.</p>
<p class="indent"><span epub:type="pagebreak" id="page_230"/>The remaining command line arguments are as described, with two options worth special mention. The first is using <span class="literal">maps</span> for the color. Specifying <span class="literal">maps</span> has the same effect as <em>sierpinski.py</em>; points are plotted in a color associated with the selected IFS map. This option reveals the maps in the output image. The second is using <span class="literal">random</span> for the IFS, which generates an IFS at random and then iterates to find the fractal it represents. We’ll experiment with this option shortly. For now, let’s use the <span class="literal">fern</span> IFS to see what sort of output we get. Give this command line a go:</p>
<pre class="pre">&gt; <span class="codestrong1">python3 ifs.py 1_000_000 fern.png fern maps</span></pre>
<p class="noindent">It plots 1 million points of the attractor for the fern IFS using a different color for each of the four maps. The result is <a href="ch07.xhtml#ch07fig10">Figure 7-10</a>.</p>
<div class="image"><img alt="Image" id="ch07fig10" src="../images/07fig10.jpg"/></div>
<p class="figcap"><em>Figure 7-10: One million points of the fern attractor</em></p>
<p class="indent">The fourth map is the narrow stem of the fern. Explore the other fractals supported by <em>ifs.py</em> or browse the <em>misc</em> directory, which contains images of each using 1 million points.</p>
<p class="indent">The <em>ifs.py</em> code uses Matplotlib to produce the output plot. Matplotlib’s graphics are interactive. Try generating 10 million points of the <span class="literal">shell</span> IFS and then click the magnifying glass icon and draw a box around the center to zoom in. With 10 million points, you should be able to zoom in two or three times. The spiral continues forever.</p>
<p class="indent">That IFS fractals resemble objects in nature can’t be a mere coincidence; there must be a biological basis for self-similar patterns, even if they’re not rigorous but only approximate mathematical fractals.</p>
<p class="indent">While it’s fun to look at the pretty fractal images <em>ifs.py</em> creates, it’s even more fun to understand the “how” behind them. Let’s examine the code and then experiment with purely random IFS fractals.</p>
<h5 class="h5"><span epub:type="pagebreak" id="page_231"/><strong>The IFS Class</strong></h5>
<p class="noindent">The dictionary of predefined maps constitutes the bulk of the <span class="literal">IFS</span> class. In terms of actual code, there are a handful of methods to contemplate: <span class="literal">ChooseMap</span>, <span class="literal">GeneratePoints</span>, <span class="literal">StoreFractal</span>, and <span class="literal">RandomMaps</span>. I’ll save <span class="literal">RandomMaps</span> for the next section; <span class="literal">StoreFractal</span> is a straightforward application of Matplotlib to plot the generated points using the associated colors. That leaves <span class="literal">GeneratePoints</span> and <span class="literal">ChooseMap</span>. Let’s begin with <span class="literal">GeneratePoints</span>, as shown in <a href="ch07.xhtml#ch07list02">Listing 7-2</a>.</p>
<pre class="pre">def GeneratePoints(self):
    self.xy = np.zeros((self.npoints,3))
    xy = np.array([self.rng.random(), self.rng.random(), 1.0])

    for i in range(100):
        m = self.maps[self.ChooseMap(),:,:]
        xy = m @ xy
    
    for i in range(self.npoints):
        k = self.ChooseMap()
        m = self.maps[k,:,:]
        xy = m @ xy
        self.xy[i,:] = [xy[0],xy[1],k]</pre>
<p class="list" id="ch07list02"><em>Listing 7-2: Finding the points on the fractal attractor</em></p>
<p class="indent">The <span class="literal">GeneratePoints</span> method fills in a NumPy array of <span class="literal">npoints</span> rows and three columns: <em>x</em>, <em>y</em>, and the index of the selected map. The code iterates a randomly initialized vector, <span class="literal">xy</span>. The third element, a constant 1, allows us to use 3×3 matrices for the maps.</p>
<p class="indent">A randomly selected point isn’t likely to be on the attractor; therefore, before we store points in <span class="literal">self.xy</span>, we iterate 100 times to ensure that new points are on the attractor. Each iteration involves selecting a map according to the assigned probabilities followed by a matrix multiplication with that map, <em><strong>x</strong> → <strong>Mx</strong></em>, which becomes <span class="literal">xy = m @ xy</span> in code. NumPy uses <span class="literal">@</span> for matrix multiplication.</p>
<p class="indent">While the <span class="literal">GeneratePoints</span> method does the lion’s share of the work, it relies on <span class="literal">ChooseMap</span> (<a href="ch07.xhtml#ch07list03">Listing 7-3</a>).</p>
<pre class="pre">def ChooseMap(self):
    r = self.rng.random()
    a = 0.0
    k = 0
    for i in range(self.nmaps):
        if (r &gt; a):
            k = i<span epub:type="pagebreak" id="page_232"/>
        else:
            return k
        a += self.probs[i]
    return k</pre>
<p class="list" id="ch07list03"><em>Listing 7-3: Choosing a map</em></p>
<p class="noindent">The <span class="literal">IFS</span> constructor creates member variables <span class="literal">nmaps</span>, <span class="literal">probs</span>, and <span class="literal">maps</span> according to the selected IFS. The <span class="literal">ChooseMap</span> method returns an index into the list of maps by picking a random number in [0, 1) (<span class="literal">r</span>) and then adding per-map probabilities until the accumulated sum (<span class="literal">a</span>) exceeds the selected value, at which point it returns the current index, <span class="literal">k</span>. The effect selects maps in proportion to their assigned probabilities.</p>
<p class="indent">Using the <span class="literal">IFS</span> class is straightforward:</p>
<pre class="pre">app = IFS(npoints, name, ctype, rng, show=True)
app.GeneratePoints()
app.StoreFractal(outfile)</pre>
<p class="indent">The constructor accepts the number of points, fractal name, color, an initialized <span class="literal">RE</span> object, and a flag to show or hide the fractal when we call <span class="literal">StoreFractal</span>. The <span class="literal">GeneratePoints</span> and <span class="literal">StoreFractal</span> methods complete the process. Encapsulating <span class="literal">IFS</span> in a single class with a small main driver lets us use <em>ifs.py</em> as a program or module; we’ll use it as the latter in the next section.</p>
<h5 class="h5"><strong>Random IFS</strong></h5>
<p class="noindent">Running <em>ifs.py</em> with <span class="literal">random</span> as the fractal name generates a set of random maps with random probabilities. Each map is a 3×3 matrix</p>
<div class="image1"><img alt="Image" src="../images/f0232-01.jpg"/></div>
<p class="noindent">with an associated probability, <em>p</em>. The six elements of the map must satisfy a set of constraints to be a contraction mapping. Specifically, the following must be true:</p>
<div class="image1"><img alt="Image" src="../images/f0232-02.jpg"/></div>
<p class="indent">The <span class="literal">RandomMaps</span> method creates a collection of maps and probabilities, as in <a href="ch07.xhtml#ch07list04">Listing 7-4</a>.</p>
<pre class="pre">def RandomMaps(self):
    def mapping():
        while (True):
            a,b,c,d,e,f = -1 + 2*self.rng.random(6)<span epub:type="pagebreak" id="page_233"/>
            if (a*a+d*d) &gt;= 1:
                continue
            if (b*b+e*e) &gt;= 1:
                continue
            if a*a+b*b+d*d+e*e - (a*e-d*b)**2 &gt;= 1:
                continue
            break
        return [[a,b,c],[d,e,f],[0,0,1]]

    nmaps = 2 + int(4*self.rng.random()) # [2,5]
    probs = self.rng.random(nmaps)
    probs = probs / probs.sum()

    maps = []
    for k in range(nmaps):
        maps.append(mapping())

    return nmaps, probs, np.array(maps)</pre>
<p class="list" id="ch07list04"><em>Listing 7-4: Creating a random IFS</em></p>
<p class="noindent">The code first chooses a random number of maps, [2, 5], and probabilities (<span class="literal">probs</span>). It then loops <span class="literal">nmaps</span> times, calling the embedded function, <span class="literal">mapping</span>, which returns a valid map matrix. The <span class="literal">mapping</span> method repeatedly selects random elements in [–1, 1) until all constraints are satisfied.</p>
<p class="indent">Let’s create 100 random fractals to get a feel for what the attractor of a randomly generated IFS looks like. The file <em>ifs_maps.py</em> contains the code we need. It uses a master seed value passed on the command line to generate a collection of random fractals. Here’s the command line I used:</p>
<pre class="pre">&gt; <span class="codestrong1">python3 ifs_maps.py 100 fractals 271828 &gt;ifs_maps_271828.txt</span></pre>
<p class="noindent">If you use the same command line, you’ll get the same collection of fractals in the <em>fractals</em> directory. The file <em>ifs_maps_271828.txt</em> contains the randomly generated maps and the seed value. The code in <em>ifs_maps.py</em> is only a few dozen lines, but it demonstrates how to use the <span class="literal">IFS</span> class inside another program.</p>
<p class="indent"><a href="ch07.xhtml#ch07fig11">Figure 7-11</a> presents some fractals that were produced by the previous command line. (These are better in color.)</p>
<div class="image"><img alt="Image" id="ch07fig11" src="../images/07fig11.jpg"/></div>
<p class="figcap"><em>Figure 7-11: Randomly generated IFS fractals</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_234"/>Even without color, we get a taste of what random IFS can do. The numbers identify the fractal. The maps used are in <em>ifs_maps_271828.txt</em>.</p>
<h4 class="h4" id="ch00lev2_72"><em><strong>IFS Maps</strong></em></h4>
<p class="noindent">Now that we understand the process of iterating a function system represented as a collection of matrices and probabilities, we’ll generate our own IFS maps. This section is optional, as some linear algebra is involved.</p>
<p class="indent">Consider <a href="ch07.xhtml#ch07fig12">Figure 7-12</a>.</p>
<div class="image"><img alt="Image" id="ch07fig12" src="../images/07fig12.jpg"/></div>
<p class="figcap"><em>Figure 7-12: The three contraction maps of the Sierpiński triangle</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_235"/>This shows the effect of the three maps that make up the Sierpiński triangle. The maps take the unit square (outermost square) and map it to one of the three smaller squares. The diagonal line shows the orientation to clarify flips or rotations. Here the mappings shrink the unit square and offset it from the origin, but they don’t flip or rotate. The recursive self-similar appearance of the attractor comes from repeating this mapping in each of the smaller squares, repeating in each of those, and so on forever.</p>
<p class="indent">Let’s turn the illustration in <a href="ch07.xhtml#ch07fig12">Figure 7-12</a> into three 3×3 matrices, or maps. We’ll track where the three points of the unit square, (0, 0), (1, 0), and (0, 1), end up in each map.</p>
<p class="indent">We’ll begin with the top map that maps the unit square into the range [0.25, 0.75] in <em>x</em> and [0.5, 1] in <em>y</em>. The map takes any point in the unit square to the proper place in this smaller square. The point at (1, 0) must map to (0.75, 0.5); similarly, (0, 0) <em>→</em> (0.25, 0.5) and (1, 0) <em>→</em> (0.25, 1). How do we find the matrix <em><strong>M</strong></em> that does this?</p>
<p class="indent"><span epub:type="pagebreak" id="page_236"/>Mathematically, we need <em><strong>M</strong></em> to act like so</p>
<div class="image1"><img alt="Image" src="../images/f0236-01.jpg"/></div>
<p class="noindent">for properly selected <em>a</em>, <em>b</em>, <em>c</em>, <em>d</em>, <em>e</em>, and <em>f</em>. The same matrix must also map (0, 0) and (0, 1) to (0.25, 0.5) and (0.25, 1), respectively.</p>
<p class="indent">Performing matrix multiplication gives us two equations to map (1, 0) to (0.75, 0.5):</p>
<div class="image1"><img alt="Image" src="../images/f0236-02.jpg"/></div>
<p class="noindent">The third equation contains only constants, so we’ll ignore it going forward.</p>
<p class="indent">We have two other points to consider that use the same matrix, so we have four more equations:</p>
<div class="image1"><img alt="Image" src="../images/f0236-03.jpg"/></div>
<p class="indent">Let’s find <em>a</em>, <em>b</em>, and <em>e</em>. The process repeats to find <em>c</em>, <em>d</em>, and <em>f</em>. If we group equations involving <em>a</em>, <em>b</em>, and <em>e</em>, we get:</p>
<div class="image1"><img alt="Image" src="../images/f0236-04.jpg"/></div>
<p class="noindent">This gives us three equations and three unknowns, so we can find a unique solution. First, let’s rewrite the equations in matrix form:</p>
<div class="image1"><img alt="Image" src="../images/f0236-05.jpg"/></div>
<p class="indent">This is a matrix equation of the form <em><strong>b</strong></em> = <em><strong>Ax</strong></em>, and we want to find <em><strong>x</strong></em>. One approach is to use <em>Cramer’s rule</em>, which solves the equation, element by element, as the ratio of determinants. In particular, we find each element of <em><strong>x</strong></em> as</p>
<div class="image1"><img alt="Image" src="../images/f0236-06.jpg"/></div>
<p class="noindent">for |<em><strong>A</strong></em>| the determinant of the matrix and |<em><strong>A</strong><sub>i</sub></em>| the determinant of a matrix formed by replacing the <em>i</em>th column of <em><strong>A</strong></em> with <em><strong>b</strong></em>. Therefore, we get <em>a</em>, <em>b</em>, and <em>e</em> like so:</p>
<div class="image1"><span epub:type="pagebreak" id="page_237"/><img alt="Image" src="../images/f0237-01.jpg"/></div>
<p class="indent">Working through the determinants, perhaps by using NumPy’s <span class="literal">np.linalg.det</span> function, tells us that <em>a</em> = 0.5, <em>b</em> = 0.0, and <em>e</em> = 0.25. The corresponding equations for <em>c</em>, <em>d</em>, and <em>f</em> give 0.0, 0.5, and 0.5, respectively.</p>
<p class="indent">We now have the mapping matrix we need:</p>
<div class="image1"><img alt="Image" src="../images/f0237-02.jpg"/></div>
<p class="noindent">This is indeed one of the <span class="literal">sierpinski</span> matrices in <em>ifs.py</em>.</p>
<p class="indent">We can generalize this process to write immediate solutions for a desired map. Assume three points on the unit square, (<em>a</em><sub>0</sub>, <em>a</em><sub>1</sub>), (<em>b</em><sub>0</sub>, <em>b</em><sub>1</sub>), and (<em>c</em><sub>0</sub>, <em>c</em><sub>1</sub>). If their desired positions after mapping are (<em>A</em><sub>0</sub>, <em>A</em><sub>1</sub>), (<em>B</em><sub>0</sub>, <em>B</em><sub>1</sub>), and (<em>C</em><sub>0</sub>, <em>C</em><sub>1</sub>), then we can find the map by calculating</p>
<div class="image1"><img alt="Image" src="../images/f0237-03.jpg"/></div>
<p class="noindent">and:</p>
<div class="image1"><img alt="Image" src="../images/f0237-04.jpg"/></div>
<p class="noindent">This process gives the maps, but says nothing about the associated probability for selecting the map when playing the chaos game. Intuition and experimentation help with assigning probabilities.</p>
<p class="indent">There are a plethora of IFS-related programs out there, many of which let you design IFS mappings interactively, so you need not work through the map calculations by hand. For example, Larry Riddle’s IFS Construction Kit is a Windows program for creating and animating IFS fractals that includes a graphical designer (<em><a href="https://larryriddle.agnesscott.org/ifskit">https://larryriddle.agnesscott.org/ifskit</a></em>). I was able to run the program under Linux using <span class="literal">wine</span> after downloading the missing <em>.ocx</em> and <em>.dll</em> files Riddle refers to on the installation page.</p>
<h3 class="h3" id="ch00lev1_49"><span epub:type="pagebreak" id="page_238"/> <strong>Exercises</strong></h3>
<p class="noindent">There’s no end to creating generative art. Here are some exercises related to this chapter’s experiments:</p>
<ul>
<li class="noindent">The code in <em>moire.py</em> draws from a single point to the edges. Try drawing from a corner; then, try multiple points with different step sizes.</li>
<li class="noindent">Modify <em>walker.py</em> to select a random color table index or use the step number modulo 256 to cycle through the color table.</li>
<li class="noindent">Why limit <em>walker.py</em> to a single walker?</li>
<li class="noindent">The list of available functions in <em>warp.py</em> is rather Spartan. Add new ones that assume inputs in [–1, 1] for both <em>x</em> and <em>y</em> and return new <em>x</em> and <em>y</em> values plus a color table index [0, 255].</li>
<li class="noindent">What happens if you change the probabilities for each map in <em>ifs.py</em>?</li>
<li class="noindent">Create new IFS maps for <em>ifs.py</em> using the manual process described in the text. Do they produce the expected result?</li>
<li class="noindent">Create new IFS maps using IFS Construction Kit or a similar program and add them to the library in <em>ifs.py</em>.</li>
</ul>
<h3 class="h3" id="ch00lev1_50"><strong>Summary</strong></h3>
<p class="noindent">This chapter introduced us to randomness in generative art, though we only scratched the surface. We explored images generated by the moiré effect, random walkers, and the application of randomly selected warping functions and color tables.</p>
<p class="indent">Fractals came next. We learned that IFS have attractors, or self-similar fractals. The chaos game, using a random sequence of mappings, falls onto the attractor, thereby giving us a means for generating an infinite number of fractal images. Randomly selected sets of maps produce fascinating and mesmerizing collections of fractal images. There seems to be a deep connection between the formation of structures in nature and the attractors of IFS.</p>
<p class="indent">This chapter focused on what is pleasant to look at. In the next chapter, we’ll delve into what is pleasant to listen to.</p>
</body></html>