["```\nstdout.put(\"i32=\",i32,\" strVar=\",strVar,\" charVar=\",charVar,nl);\n```", "```\nstdout.puts( \"i32=\" );\nstdout.puti32( i32 );\nstdout.puts( \" strVar=\" );\nstdout.puts( strVar );\nstdout.puts( \" charVar=\" );\nstdout.putc( charVar );\nstdout.newln();\n```", "```\nprogram ctlHelloWorld;\nbegin ctlHelloWorld;\n\n    #print( \"Hello, World of HLA/CTL\" )\n\nend ctlHelloWorld;\n```", "```\nHello, World of HLA/CTL\n```", "```\n#print( \"Hello World\" )\nstdout.puts( \"Hello World\" nl );\n```", "```\n#print( *`list_of_comma_separated_constants`* )\n```", "```\n#print( \"A string Constant \", 45, ' ', 54.9, ' ', true )\n```", "```\nconst\n    pi := 3.14159;\n    charConst := 'c';\n\n#print( \"PI = \", pi, \"  CharVal=\", charConst )\n```", "```\n#error( \"Statement must have exactly one operand\" )\n```", "```\n?ConstToPrint := 25;\n     #print( \"ConstToPrint = \", ConstToPrint )\n     ?ConstToPrint := ConstToPrint + 5;\n     #print( \"Now ConstToPrint = \", ConstToPrint )\n```", "```\nint8( \"-128\" )\n```", "```\n#error( \"theValue (\" + string( theValue ) + \") is out of range\" )\n```", "```\nreal32( $3F80_0000 )\n```", "```\nchar( 65 )\n```", "```\n@real32( $3F80_0000 )\n```", "```\n@length( *`string_expression`* )\n```", "```\n@defined( *`MyIdentifier`* )\n```", "```\n?id1:string := \"eax\";\n?id2:string := \"i32\";\n@text( \"mov( \" + id1 + \", \" + id2 + \");\" )\n```", "```\nmov( eax, i32 );\n```", "```\nval\n     t:text := \"stdout.put\";\n          .\n          .\n          .\n     ?t:text := \"fileio.put\";\n```", "```\nval\n     t:text := \"stdout.put\";\n          .\n          .\n          .\n     ?stdout.put:text := \"fileio.put\";\n```", "```\n?@string(t) := \"Hello\"\n```", "```\n?\"stdout.put\" := \"Hello\";\n```", "```\nval\n     t:text := \"stdout.put\";\n          .\n          .\n          .\n     ?@toString:t : text := \"fileio.put\";\n```", "```\n#if( *`constant_boolean_expression`* )\n     << text >>\n#endif\n```", "```\n#if( @length( someStrConst ) < 10*i & ( (MaxItems*2 + 2) < 100 | MinItems-5 < 10 ))\n     << text >>\n#endif\n```", "```\n#if( *`constant_boolean_expression_1`* )\n     << text >>\n#elseif( *`constant_boolean_expression_2`* )\n     << text >>\n#else\n     << text >>\n#endif\n```", "```\nconst\n    // Set true to use FCOMIxx instrs.\n    PentProOrLater: boolean := false;\n          .\n          .\n          .\n    #if( PentProOrLater )\n\n          fcomip();      // Compare st1 to st0 and set flags.\n     #else\n          fcomp();       // Compare st1 to st0.\n          fstsw( ax );   // Move the FPU condition code bits\n          sahf();        // into the flags register.\n\n     #endif\n```", "```\nconst\n     // Note: Uncomment the following line if you are compiling this\n     // code for a Pentium Pro or later CPU.\n\n     // PentProOrLater :=0;  // Value and type are irrelevant.\n          .\n          .\n          .\n#if( @defined( PentProOrLater ) )\n\n     fcomip();    // Compare st1 to st0 and set flags.\n\n#else\n\n     fcomp();     // Compare st1 to st0.\n     fstsw( ax ); // Move the FPU condition code bits\n     sahf();      // into the flags register.\n\n#endif\n```", "```\nconst\n     // Set to true to activate debug output.\n     debug: boolean := false;\n          .\n          .\n          .\n     #if( debug )\n\n          stdout.put( \"At line \", @lineNumber, \" i=\", i, nl );\n\n     #endif\n```", "```\n#while( *`constant_boolean_expression`* )\n     << text >>\n#endwhile\n```", "```\nprogram ctWhile;\n#include( \"stdlib.hhf\" )\n\nstatic\nary: uns32[5] := [ 2, 3, 5, 8, 13 ];\n\nbegin ctWhile;\n\n     ?i := 0;\n     #while( i < 5 )\n\n          stdout.put( \"array[ \", i, \" ] = \", ary[i*4], nl );\n          ?i := i + 1;\n\n     #endwhile\n\nend ctWhile;\n```", "```\narray[ 0 ] = 2\narray[ 1 ] = 3\narray[ 2 ] = 4\narray[ 3 ] = 5\narray[ 4 ] = 13\n```", "```\nprogram ctWhile;\n#include( \"stdlib.hhf\" )\n\nstatic\n     ary: uns32[5] := [ 2, 3, 5, 8, 13 ];\n\nbegin ctWhile;\n\n     stdout.put( \"array[ \", 0, \" ] = \", ary[0*4], nl );\n     stdout.put( \"array[ \", 1, \" ] = \", ary[1*4], nl );\n     stdout.put( \"array[ \", 2, \" ] = \", ary[2*4], nl );\n     stdout.put( \"array[ \", 3, \" ] = \", ary[3*4], nl );\n     stdout.put( \"array[ \", 4, \" ] = \", ary[4*4], nl );\n\nend ctWhile;\n```", "```\n#for( *`valObject`* := *`startExpr`* to *`endExpr`* )\n\n          .\n          .\n     #endfor\n\n     #for( *`valObject`* := *`startExpr`* downto *`endExpr`* )\n          .\n          .\n          .\n     #endfor\n\n     #for( *`valObject`* in *`composite_expr`* )\n          .\n          .\n          .\n     #endfor\n```", "```\n?*`valObject`* := *`startExpr`*;\n     #while( *`valObject`* <= *`endExpr`* )\n               .\n               .\n               .\n          ?*`valObject`* := *`valObject`* + 1;\n  #endwhile\n```", "```\n?*`valObject`* := *`startExpr`*;\n     #while( *`valObject`* >= *`endExpr`* )\n               .\n               .\n               .\n     ?*`valObject`* := *`valObject`* - 1;\n  #endwhile\n```", "```\n#for( i in [1, 10, 100, 1000])\n          #print( i )\n #endfor\n```", "```\n#macro *`macroname`*;\n     << Macro body >>\n#endmacro\n```", "```\n#macro neg64;\n\n     neg( edx );\n     neg( eax );\n     sbb( 0, edx );\n\n#endmacro\n```", "```\nmov( (type dword i64), eax );\n     mov( (type dword i64[4]), edx );\n     neg64;\n```", "```\nprocedure neg64p;\nbegin neg64p;\n\n     neg( edx );\n     neg( eax );\n     sbb( 0, edx );\n\nend neg64p;\n```", "```\nneg64;          neg64p();\n```", "```\nneg( edx );\n     neg( eax );\n     sbb( 0, edx );\n```", "```\ncall neg64p;\n```", "```\n#macro neg64( reg32HO, reg32LO );\n\n     neg( reg32HO );\n     neg( reg32LO );\n     sbb( 0, reg32HO );\n\n#endmacro;\n```", "```\nneg64( edx, eax );\n```", "```\nneg64( edx, eax );\n     neg64( ebx, ecx );\n```", "```\n// neg64(edx, eax );\n\n     neg( edx );\n     neg( eax );\n     sbb( 0, edx );\n\n// neg64( ebx, ecx );\n\n     neg( ebx );\n     neg( ecx );\n     sbb( 0, ebx );\n```", "```\n?reg32HO: text := \"edx\";\n  ?reg32LO: text := \"eax\";\n\n  neg( reg32HO );\n  neg( reg32LO );\n  sbb( 0, reg32HO );\n```", "```\n#macro chkError( instr, jump, target );\n\n     instr;\n     jump target;\n\n#endmacro;\n\n     chkError( cmp( eax, 0 ), jnl, RangeError );       // Example 1\n          ...\n     chkError( test( 1, bl ), jnz, ParityError );      // Example 2\n\n// Example 1 expands to\n\n     cmp( eax, 0 );\n     jnl RangeError;\n\n// Example 2 expands to\n\n     test( 1, bl );\n     jnz ParityError;\n```", "```\n#macro print( strToPrint );\n\n     stdout.out( strToPrint );\n\n#endmacro;\n     .\n     .\n     .\n     print( \"Hello, world!\" );\n```", "```\n#macro Echo2nTimes( n, theStr );\n     #for( echoCnt := 1 to n*2 )\n          #print( theStr )\n     #endfor\n#endmacro;\n\n     .\n     .\n     .\nEcho2nTimes( 3+1, \"Hello\" );\n```", "```\n#for( echoCnt := 1 to 3+1*2 )\n```", "```\n#macro Echo2nTimes( n, theStr );\n\n    #for( echoCnt := 1 to  (n)*2 )\n\n        #print( theStr )\n\n    #endfor\n\n#endmacro;\n```", "```\n#for( echoCnt := 1 to (3+1)*2 )\n         #print( theStr )\n    #endfor\n```", "```\n#macro varParms( varying[] );\n\n     << Macro body >>\n\n#endmacro;\n     .\n     .\n     .\n     varParms( 1 );\n     varParms( 1, 2 );\n     varParms( 1, 2, 3 );\n     varParms();\n```", "```\n#macro varParms( varying[] );\n\n     #for( vpCnt := 0 to @elements( varying ) - 1 )\n\n          #print( varying[ vpCnt ] )\n\n     #endfor\n\n#endmacro;\n     .\n     .\n     .\n varParms( 1 );        // Prints \"1\" during compilation.\n varParms( 1, 2 );     // Prints \"1\" and \"2\" on separate lines.\n varParms( 1, 2, 3 );  // Prints \"1\", \"2\", and \"3\" on separate lines.\n varParms();           // Doesn't print anything.\n```", "```\n#macro ReqAndOpt( Required, optional[] );\n     ?@text( optional[0] ) := @string( ReqAndOpt );\n     #print( @text( optional[0] ))\n\n     #endmacro;\n     .\n     .\n     .\n     ReqAndOpt( i, j );\n\n// The macro invocation above expands to\n\n     ?@text( \"j\" ) := @string( i );\n     #print( \"j\" )\n\n// The above further expands to\n\n     j := \"i\";\n     #print( j )\n\n// The above simply prints \"i\" during compilation.\n```", "```\n#macro ReqAndOpt( Required, optional[] );\n\n     #if( @elements( optional ) > 0 )\n\n          ?@text( optional[0] ) := @string( ReqAndOpt );\n          #print( @text( optional[0] ))\n\n     #else\n\n          #error( \"ReqAndOpt must have at least two parameters\" )\n\n     #endif\n\n#endmacro;\n```", "```\n#macro neg64( JustForTheParens[] );\n\n     #if( @elements( JustForTheParens ) = 0 )\n\n          neg( edx );\n          neg( eax );\n          sbb( 0, edx );\n\n     #else\n\n          #error( \"Unexpected operand(s)\" )\n\n     #endif\n\n#endmacro;\n```", "```\nmacro JZC( target );\n\n         jnz NotTarget;\n         jc target;\n     NotTarget:\n\nendmacro;\n```", "```\nJZC( *`Dest1`* );\n          .\n          .\n          .\n     JZC( *`Dest2`* );\n          .\n          .\n          .\n```", "```\njnz NotTarget;\n    jc *`Dest1`*;\nNotTarget:\n         .\n         .\n         .\n    jnz NotTarget;\n    jc *`Dest2`*;\nNotTarget:\n         .\n         .\n         .\n```", "```\n#macro *`macroname`*( *`optional_parameters`* ):*`optional_list_of_local_names`* ;\n     << Macro body >>\n#endmacro;\n```", "```\n#macro JZC( target ):NotTarget;\n\n         jnz NotTarget;\n         jc target;\n     NotTarget:\n\n#endmacro;\n```", "```\njnz _010A_;\n      jc *`SomeLabel`*;\n_010A_:\n```", "```\n#macro JZC( target );\n     ?NotTarget:text := \"_010A_*`Text`*_\";\n\n         jnz NotTarget;\n         jc target;\n\n     NotTarget:\n\n#endmacro;\n```", "```\n#macro unique:theSym;\n     @string(theSym)\n#endmacro;\n```", "```\n// Puti.hla\n//\n// This program demonstrates procedure overloading via macros.\n//\n// It defines a \"puti\" macro that calls stdout.puti8, stdout.puti16,\n// stdout.puti32, or stdout.puti64, depending on the size of\n// the operand.\n\nprogram putiDemo;\n#include( \"stdlib.hhf\" )\n\n// puti-\n//\n// Automatically decides whether we have a 64-, 32-, 16-, or 8-bit\n// operand and calls the appropriate stdout.putiX routine to\n// output this value.\n\n#macro puti( operand );\n\n     // If we have an 8-byte operand, call puti64:\n\n     #if( @size( operand ) = 8 )\n\n          stdout.puti64( operand );\n\n     // If we have a 5-byte operand, call puti32:\n\n     #elseif( @size( operand ) = 4 )\n\n          stdout.puti32( operand );\n\n     // If we have a 2-byte operand, call puti16:\n\n     #elseif( @size( operand ) = 2 )\n\n          stdout.puti16( operand );\n\n     // If we have a 1-byte operand, call puti8:\n\n     #elseif( @size( operand ) = 1 )\n\n          stdout.puti8( operand );\n\n     // If it's not an 8-, 4-, 2-, or 1-byte operand,\n     // then print an error message:\n\n     #else\n\n          #error( \"Expected a 64-, 32-, 16-, or 8-bit operand\" )\n\n     #endif\n\n#endmacro;\n\n// Some sample variable declarations so we can test the macro above:\n\nstatic\n     i8:  int8    := −8;\n     i16: int16   := −16;\n     i32: int32   := −32;\n     i64: qword;\n\nbegin putiDemo;\n\n     // Initialize i64 because we can't do this in the static section.\n\n     mov( −64, (type dword i64 ));\n     mov( $FFFF_FFFF, (type dword i64[4]));\n\n     // Demo the puti macro:\n\n     puti( i8  ); stdout.newln();\n     puti( i16 ); stdout.newln();\n     puti( i32 ); stdout.newln();\n     puti( i64 ); stdout.newln();\n\nend putiDemo;\n```", "```\n// put32.hla\n//\n// This program demonstrates procedure overloading via macros.\n//\n// It defines a put32 macro that calls stdout.puti32, stdout.putu32,\n// or stdout.putdw depending on the type of the operand.\n\nprogram put32Demo;\n#include( \"stdlib.hhf\" )\n\n// put32-\n//\n// Automatically decides whether we have an int32, uns32, or dword\n// operand and calls the appropriate stdout.putX routine to\n// output this value.\n\n#macro put32( operand );\n\n// If we have an int32 operand, call puti32:\n\n     #if( @typename( operand ) = \"int32\" )\n\n          stdout.puti32( operand );\n\n     // If we have an uns32 operand, call putu32:\n\n     #elseif( @typename( operand ) = \"uns32\" )\n\n          stdout.putu32( operand );\n\n     // If we have a dword operand, call puth32:\n\n     #elseif( @typename( operand ) = \"dword\" )\n\n          stdout.puth32( operand );\n\n     // If it's not a 32-bit integer value, report an error:\n\n     #else\n\n          #error( \"Expected an int32, uns32, or dword operand\" )\n\n     #endif\n\n#endmacro;\n\n// Some sample variable declarations so we can test the macro above:\n\nstatic\n     i32: int32   := −32;\n     u32: uns32   := 32;\n     d32: dword   := $32;\n\nbegin put32Demo;\n\n     // Demo the put32 macro:\n\n     put32( d32 );  stdout.newln();\n     put32( u32 );  stdout.newln();\n     put32( i32 );  stdout.newln();\n\nend put32Demo;\n```", "```\n// puti32.hla\n//\n// This program demonstrates procedure overloading via macros.\n//\n// It defines a puti32 macro that calls\n// stdout.puti32 or stdout.puti32size\n// depending on the number of parameters present.\n\nprogram puti32Demo;\n#include( \"stdlib.hhf\" )\n\n// puti32-\n//\n// Automatically decides whether we have an int32, uns32, or dword\n// operand and calls the appropriate stdout.putX routine to\n// output this value.\n\n#macro puti32( operand[] );\n\n     // If we have a single operand, call stdout.puti32:\n\n     #if( @elements( operand ) = 1 )\n\n          stdout.puti32( @text(operand[0]) );\n\n     // If we have two operands, call stdout.puti32size and\n     // supply a default value of ' ' for the padding character:\n\n     #elseif( @elements( operand ) = 2 )\n\n          stdout.puti32Size\n          (\n              @text(operand[0]),\n              @text(operand[1]),\n              ' '\n           );\n\n     // If we have three parameters, then pass all three of them\n     // along to puti32size:\n\n     #elseif( @elements( operand ) = 3 )\n\n          stdout.puti32Size\n           (\n               @text(operand[0]),\n               @text(operand[1]),\n               @text(operand[2])\n          );\n\n     // If we don't have one, two, or three operands, report an error:\n\n     #else\n\n          #error( \"Expected one, two, or three operands\" )\n\n     #endif\n\n#endmacro;\n\n// A sample variable declaration so we can test the macro above:\n\nStatic\n     i32: int32 := −32;\n\nbegin puti32Demo;\n\n          // Demo the put32 macro:\n\n     puti32( i32 );  stdout.newln();\n     puti32( i32, 5 );  stdout.newln();\n     puti32( i32, 5, '*' );  stdout.newln();\n\nend puti32Demo;\n```", "```\n// demoSines.hla\n//\n// This program demonstrates how to create a lookup table\n// of sine values using the HLA compile-time language.\n\nprogram demoSines;\n#include( \"stdlib.hhf\" )\n\nconst\n     pi :real80 := 3.1415926535897;\n\nreadonly\n     sines:  int32[ 360 ] :=\n             [\n               // The following compile-time program generates\n               // 359 entries (out of 360). For each entry\n               // it computes the sine of the index into the\n               // table and multiplies this result by 1000\n               // in order to get a reasonable integer value.\n\n               ?angle := 0;\n               #while( angle < 359 )\n\n                    // Note: HLA's @sin function expects angles\n                    // in radians. radians = degrees*pi/180.\n                    // The int32 function truncates its result,\n                    // so this function adds 1/2 as a weak attempt\n                    // to round the value up.\n\n                    int32( @sin( angle * pi / 180.0 ) * 1000 + 0.5 ),\n                    ?angle := angle + 1;\n\n               #endwhile\n\n               // Here's the 360th entry in the table. This code\n               // handles the last entry specially because a comma\n               // does not follow this entry in the table.\n\n               int32( @sin( 359 * pi / 180.0 ) * 1000 + 0.5 )\n          ];\nbegin demoSines;\n\n     // Simple demo program that displays all the values in the table:\n\n     for( mov( 0, ebx); ebx<360; inc( ebx )) do\n\n          mov( sines[ ebx*4 ], eax );\n          stdout.put\n           (\n               \"sin( \",\n               (type uns32 ebx ),\n               \" )*1000 = \",\n               (type int32 eax ),\n               nl\n           );\n\n     endfor;\n\nend demoSines;\n```", "```\n// demoCase.hla\n//\n// This program demonstrates how to create a lookup table\n// of alphabetic case conversion values using the HLA\n// compile-time language.\n\nprogram demoCase;\n#include( \"stdlib.hhf\" )\n\nconst\n\n     // emitCharRange\n     //\n     // This macro emits a set of character entries\n     // for an array of characters. It emits a list\n     // of values (with a comma suffix on each value)\n     // from the starting value up to, but not including,\n     // the ending value.\n\n     #macro emitCharRange( start, last ): index;\n\n          ?index:uns8 := start;\n          #while( index < last )\n\n               char( index ),\n               ?index := index + 1;\n\n          #endwhile\n\n     #endmacro;\n\n     readonly\n\n    // toUC:\n    // The entries in this table contain the value of the index\n    // into the table except for indices #$61..#$7A (those entries\n    // whose indices are the ASCII codes for the lowercase\n    // characters). Those particular table entries contain the\n    // codes for the corresponding uppercase alphabetic characters.\n    // If you use an ASCII character as an index into this table and\n    // fetch the specified byte at that location, you will effectively\n    // translate lowercase characters to uppercase characters and\n    // leave all other characters unaffected.\n\n    toUC: char[ 256 ] :=\n          [\n              // The following compile-time program generates\n              // 255 entries (out of 256). For each entry\n              // it computes toupper( *`index`* ) where *`index`* is\n              // the character whose ASCII code is an index\n              // into the table.\n\n              emitCharRange( 0, uns8('a') )\n\n              // Okay, we've generated all the entries up to\n              // the start of the lowercase characters. Output\n              // uppercase characters in place of the lowercase\n              // characters here.\n\n              emitCharRange( uns8('A'), uns8('Z') + 1 )\n\n              // Okay, emit the nonalphabetic characters\n              // through to byte code #$FE:\n\n              emitCharRange( uns8('z') + 1, $FF )\n\n              // Here's the last entry in the table. This code\n              // handles the last entry specially because a comma\n              // does not follow this entry in the table.\n\n              #$FF\n\n         ];\n\n     // The following table is very similar to the one above.\n     // You would use this one, however, to translate uppercase\n     // characters to lowercase while leaving everything else alone.\n     // See the comments in the previous table for more details.\n\n     TOlc: char[ 256 ] :=\n           [\n\n               emitCharRange( 0, uns8('A') )\n               emitCharRange( uns8('a'), uns8('z') + 1 )\n               emitCharRange( uns8('Z') + 1, $FF )\n\n               #$FF\n          ];\n\nbegin demoCase;\n     for( mov( uns32( ' ' ), eax ); eax <= $FF; inc( eax )) do\n\n          mov( toUC[ eax ], bl );\n          mov( TOlc[ eax ], bh );\n          stdout.put\n          (\n               \"toupper( '\",\n                (type char al),\n                \"' ) = '\",\n                (type char bl),\n                \"'  tolower( '\",\n                (type char al),\n                \"' ) = '\",\n                (type char bh),\n                \"'\",\n                nl\n          );\n\n     endfor;\n\nend demoCase;\n```", "```\n#for( count := 1 to 10 )\n     stdout.put( \"Hello World\", nl );\n#endfor\n```", "```\nmov( 0, eax );\nfor( mov( 0, ebx ); ebx < 20; inc( ebx )) do\n\n   mov( eax, array[ ebx*4 ] );\n\nendfor;\n```", "```\nmov( eax, array[ 0*4 ] );\n          mov( eax, array[ 1*4 ] );\n          mov( eax, array[ 2*4 ] );\n          mov( eax, array[ 3*4 ] );\n          mov( eax, array[ 4*4 ] );\n          mov( eax, array[ 5*4 ] );\n          mov( eax, array[ 6*4 ] );\n          mov( eax, array[ 7*4 ] );\n          mov( eax, array[ 8*4 ] );\n          mov( eax, array[ 9*4 ] );\n          mov( eax, array[ 10*4 ] );\n          mov( eax, array[ 11*4 ] );\n          mov( eax, array[ 12*4 ] );\n          mov( eax, array[ 13*4 ] );\n          mov( eax, array[ 14*4 ] );\n          mov( eax, array[ 15*4 ] );\n          mov( eax, array[ 16*4 ] );\n          mov( eax, array[ 17*4 ] );\n          mov( eax, array[ 18*4 ] );\n          mov( eax, array[ 19*4 ] );\n```", "```\n#for( iteration := 0 to 19 )\n     mov( eax, array[ iteration*4 ] );\n#endfor\n```"]