- en: '**10**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**10**'
- en: '**DATA LEAKAGE**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据泄露**'
- en: Data theft is a serious concern in the mobile world, where devices containing
    critical personal and business data are lost or stolen frequently. The primary
    threat to consider here is forensic attackers, so use special care to ensure that
    such data is persisted in a format that can’t be easily extracted by physical
    attackers or by compromised devices. Unfortunately, there’s a lot of confusion
    over what APIs actually end up storing sensitive data, which is understandable
    since much of this behavior is undocumented.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 数据盗窃在移动设备领域是一个严重的隐患，因为包含重要个人和商业数据的设备常常会丢失或被盗。这里需要关注的主要威胁是取证攻击者，因此请特别小心，确保这些数据以无法被物理攻击者或被攻击的设备轻易提取的格式保存。不幸的是，对于哪些
    API 实际上会存储敏感数据，存在很多混淆，这是可以理解的，因为很多行为并未文档化。
- en: In this chapter, I’ll examine the many ways in which data can leak from your
    application to dark corners of the device—and even accidentally be synced to remote
    services such as iCloud. You’ll learn how to search for leaked data on a device
    or within your own Simulator application directory structure, as well as how to
    prevent these kinds of leaks from happening.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将探讨数据如何从您的应用程序泄露到设备的隐秘角落——甚至可能不小心同步到像 iCloud 这样的远程服务。您将学习如何在设备或自己的模拟器应用程序目录结构中搜索泄露的数据，以及如何防止这些泄露的发生。
- en: '**The Truth About NSLog and the Apple System Log**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**NSLog 和 Apple 系统日志的真相**'
- en: 'For years developers have used `printf` to output basic debug information while
    writing programs. In iOS, `NSLog` *appears* to be the equivalent, and it’s frequently
    used as such. However, `NSLog` doesn’t merely write output to the Xcode console,
    as most people believe. Its purpose is to log an error message to the Apple System
    Log (ASL) facility. Here’s what Apple has to say:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，开发者一直使用 `printf` 来输出基本的调试信息。在 iOS 中，`NSLog` *看起来* 是等效的，并且经常被这样使用。然而，`NSLog`
    并不仅仅是将输出写入 Xcode 控制台，正如大多数人认为的那样。它的目的是将错误信息记录到 Apple 系统日志（ASL）设施中。以下是 Apple 的说法：
- en: Messages received by the server are saved in a data store (subject to input
    filtering constraints). This API permits clients to create queries and search
    the message data store for matching messages.^([1](footnote.html#fn83))
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器接收到的消息会保存在数据存储中（受到输入过滤约束）。这个 API 允许客户端创建查询，并在消息数据存储中搜索匹配的消息。^([1](footnote.html#fn83))
- en: So perhaps `NSLog` is best thought of as a hybrid between `printf` and `syslog`,
    which spits out messages in the Xcode console when debugging and sends messages
    to a global system log when on the device. It follows, then, that data logged
    by `NSLog` will be retrievable by anyone in physical possession of the device,
    similar to other cached application data.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，也许 `NSLog` 最好被视为 `printf` 和 `syslog` 之间的混合体，当调试时，它会在 Xcode 控制台中输出消息，并且在设备上时会将消息发送到全局系统日志。因此，可以推断，`NSLog`
    记录的数据将可以被任何物理接触到设备的人检索，类似于其他缓存的应用数据。
- en: No special tools are necessary to read the log. Just plug the iOS device in
    to a Mac, open Xcode, select **Window** → **Devices**, and click your device.
    The device’s system log may not be initially visible in the console. If it isn’t,
    click the tiny arrow in the lower left of the panel. [Figure 10-1](ch10.html#ch10fig1)
    shows an example of viewing the console log with the Devices window.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读日志不需要特殊的工具。只需将 iOS 设备连接到 Mac，打开 Xcode，选择 **窗口** → **设备**，然后点击您的设备。设备的系统日志可能最初在控制台中不可见。如果不可见，点击面板左下角的那个小箭头。[图
    10-1](ch10.html#ch10fig1) 显示了如何通过设备窗口查看控制台日志的示例。
- en: '![image](graphics/f10-01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f10-01.jpg)'
- en: '*Figure 10-1: The Devices window in Xcode*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-1：Xcode 中的设备窗口*'
- en: 'The Apple System Log facility has one quirk that makes it different from the
    traditional UNIX syslog facility: you can create queries to search existing data
    in the ASL. In versions of iOS before iOS 7, this function works regardless of
    which application originally submitted the data, which means that any information
    an application logs can be read by any other application on the device. Any application
    can read the ASL programmatically, too, as Oliver Drobnik describes on the Cocoanetics
    blog.^([2](footnote.html#fn84)) In fact, there are several applications that act
    as system log viewers using this API.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果的系统日志设施有一个独特之处，使其与传统的UNIX syslog设施不同：你可以创建查询来搜索ASL中的现有数据。在iOS 7之前的版本中，这个功能无论是哪个应用最初提交了数据都能工作，这意味着任何一个应用记录的信息都可以被设备上的其他应用读取。任何应用程序也可以通过编程方式读取ASL，正如Oliver
    Drobnik在Cocoanetics博客中所描述的那样^([2](footnote.html#fn84))。事实上，有几个应用程序使用这个API充当系统日志查看器。
- en: In iOS 7 and later, the impact of this flaw has lessened significantly because
    apps can access only their own logs. However, all application logs can still be
    read with physical access to a device, provided that the device has a trust relationship
    with another computer (or that the attacker jailbreaks the device).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS 7及更高版本中，这一缺陷的影响已大大减轻，因为应用程序只能访问自己的日志。然而，所有应用程序的日志仍然可以通过物理访问设备读取，只要该设备与另一台计算机建立了信任关系（或者攻击者越狱了设备）。
- en: Since log information can leak under certain circumstances, you need to be painstakingly
    careful to ensure that sensitive information doesn’t end up in the system log.
    For example, I’ve seen applications containing code like the horrible snippet
    in [Listing 10-1](ch10.html#ch10ex1).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在某些情况下日志信息可能会泄漏，你需要格外小心，以确保敏感信息不会出现在系统日志中。例如，我曾见过包含类似[清单 10-1](ch10.html#ch10ex1)中那种可怕代码的应用程序。
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 10-1: Please don’t do this.*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-1：请不要这么做。*'
- en: If you’re sending usernames, passwords, and so on, to `NSLog`, you’re basically
    handing over users’ private information, and you should feel bad about that. To
    redeem yourself, stop abusing `NSLog`; take it out of the equation before releasing
    your app to users.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将用户名、密码等信息发送到`NSLog`，实际上是在泄露用户的私密信息，这种行为是不道德的。为了弥补这一点，请停止滥用`NSLog`；在发布应用给用户之前，将其从代码中去除。
- en: '***Disabling NSLog in Release Builds***'
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***在发布版本中禁用NSLog***'
- en: The simplest way to get rid of `NSLog` output is to use a variadic macro ([Listing
    10-2](ch10.html#ch10ex2)) that makes `NSLog` a no-op unless the app is built in
    Debug mode within Xcode.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 去除`NSLog`输出的最简单方法是使用一个变参宏（[清单 10-2](ch10.html#ch10ex2)），它会使得`NSLog`在Xcode的Debug模式之外变为无操作（no-op）。
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 10-2: Disabling NSLog in nondebug builds*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-2：在非调试版本中禁用NSLog*'
- en: As bad as `NSLog` seems, apps with `NSLog` *do* make it into the App Store.
    This may change at some point, but you can’t rely on Apple to detect that your
    application is logging information that you don’t intend, nor can you rely on
    Apple to prevent applications from reading that logged data.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`NSLog`看起来很糟糕，但包含`NSLog`的应用程序*确实*可以进入App Store。虽然这一情况可能会在某个时刻发生变化，但你不能依赖苹果来检测应用程序是否在记录你不打算公开的信息，也不能依赖苹果阻止其他应用读取这些日志数据。
- en: '***Logging with Breakpoint Actions Instead***'
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***改用断点操作进行日志记录***'
- en: Another option is to use breakpoint actions to do logging, as I touched on in
    [Chapter 5](ch05.html#ch05). In that case, you’re effectively logging with the
    debugger, rather than the program itself. This is more convenient in some circumstances
    and doesn’t result in data being written to the system log when deployed, reducing
    the risk of releasing code with logging enabled to zero. Knowing how to use these
    actions will also be useful to you in future debugging.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是使用断点操作进行日志记录，正如我在[第5章](ch05.html#ch05)中提到的那样。在这种情况下，你实际上是通过调试器进行日志记录，而不是程序本身。这在某些情况下更为方便，并且在部署时不会将数据写入系统日志，从而减少了将启用日志记录的代码发布到生产环境中的风险。掌握如何使用这些操作，对未来的调试工作也会有帮助。
- en: Breakpoint actions are stored within a project, rather than in the source itself.
    They’re also user specific, so you see only the breakpoints and logging actions
    that you care about, rather than having everyone on your team clutter up the codebase
    with their logging statements. But when needed, Xcode lets you share your breakpoints
    with other users, making them part of the main project (see [Figure 10-2](ch10.html#ch10fig2)).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 断点操作存储在项目中，而不是源代码本身中。它们也是用户特定的，因此你只会看到你关心的断点和日志操作，而不会让团队中的每个人都用日志语句弄乱代码库。但在需要时，Xcode
    允许你与其他用户共享你的断点，使它们成为主项目的一部分（见[图 10-2](ch10.html#ch10fig2)）。
- en: You can also easily enable or disable actions, as well as specify that they
    shouldn’t output until the breakpoint is hit a certain number of times. You can
    even specify complex breakpoint conditions, which define when the associated actions
    will execute.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以轻松启用或禁用操作，并指定它们在断点被触发一定次数之前不输出。你甚至可以指定复杂的断点条件，定义何时执行相关的操作。
- en: If you want to disable all the breakpoints in a project, you can do this a couple
    of ways in Xcode. Either go the breakpoint navigator and right-click the workspace
    icon ([Figure 10-2](ch10.html#ch10fig2)) or use the shortcut ![image](graphics/common-01.jpg)-Y.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想禁用项目中的所有断点，可以通过几种方式在 Xcode 中实现。你可以打开断点导航器，右键点击工作区图标（[图 10-2](ch10.html#ch10fig2)），或使用快捷键
    ![image](graphics/common-01.jpg)-Y。
- en: '![image](graphics/f10-02.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f10-02.jpg)'
- en: '*Figure 10-2: Sharing breakpoints with other users and disabling all breakpoints
    in Xcode*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-2：与其他用户共享断点并禁用 Xcode 中的所有断点*'
- en: While `NSLog` leaks information to disk where it can be read by a physical attacker
    (and malicious apps in some versions of iOS), data can also leak between apps
    via more transient mechanisms, such as iOS pasteboards. Let’s take a look at them
    now.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `NSLog` 会将信息泄漏到磁盘上，供物理攻击者（以及在某些版本的 iOS 中的恶意应用）读取，但数据也可以通过更为瞬时的机制在应用之间泄漏，例如
    iOS 粘贴板。让我们现在来看一下它们。
- en: '**How Sensitive Data Leaks Through Pasteboards**'
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**敏感数据如何通过粘贴板泄漏**'
- en: The iOS pasteboard is a flexible mechanism for sharing arbitrary data within
    or between applications. Via a pasteboard, you can share textual data or serialized
    objects between applications, with the option to persist these pasteboards on
    disk.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 粘贴板是一个灵活的机制，用于在应用之间或应用内部共享任意数据。通过粘贴板，你可以在应用之间共享文本数据或序列化对象，并可以选择将这些粘贴板持久化到磁盘上。
- en: '***Restriction-Free System Pasteboards***'
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***无限制的系统粘贴板***'
- en: 'There are two default system pasteboards: `UIPasteboardNameGeneral` and `UIPasteboardNameFind`.
    The former is the pasteboard that almost every application will read from and
    write to by default when using Cut, Copy, or Paste menu items from within the
    app, and it’s the pasteboard of choice when you want to share data between third-party
    applications. The latter is a special pasteboard that stores the contents of the
    last search string entered into a `UISearchBar`, so applications can automatically
    determine what users have searched for in other applications.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 系统有两个默认的粘贴板：`UIPasteboardNameGeneral` 和 `UIPasteboardNameFind`。前者是几乎所有应用在使用剪切、复制或粘贴菜单项时默认读取和写入的粘贴板，也是你希望在第三方应用之间共享数据时选择的粘贴板。后者是一个特殊的粘贴板，用于存储最后一次在
    `UISearchBar` 中输入的搜索字符串的内容，因此应用可以自动识别用户在其他应用中搜索的内容。
- en: '**NOTE**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Contrary to the official description of* `*UIPasteboardNameFind*`*, this pasteboard
    is never used in real life. This bug is acknowledged by Apple but hasn’t been
    fixed, nor has the documentation been updated. As a security consultant, I can
    only hope that it will be fixed so that I can complain about it being a security
    flaw.*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*与官方描述的`*UIPasteboardNameFind*`相反，这个粘贴板在现实中从未被使用过。这个错误已被苹果承认，但尚未修复，也没有更新文档。作为一名安全顾问，我只能希望它会被修复，这样我就可以抱怨它是一个安全漏洞。*'
- en: It’s important to remember that the system pasteboards have *no* access controls
    or restrictions. If your application stores something on the pasteboard, any application
    has access to read, delete, or tamper with that data. This tampering can come
    from processes running in the background, polling pasteboard contents periodically
    to harvest sensitive data (see Osamu Noguchi’s UIPasteBoardSniffer^([3](footnote.html#fn85))
    for a demonstration of this technique). As such, you need to be extremely careful
    about what ends up on `UIPasteboardNameGeneral` in particular, as well as pasteboards
    in general.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，系统剪贴板 *没有* 访问控制或限制。如果你的应用程序将某些内容存储在剪贴板上，任何应用都可以访问、删除或篡改这些数据。这种篡改可能来自后台运行的进程，定期轮询剪贴板内容以窃取敏感数据（参见
    Osamu Noguchi 的 UIPasteBoardSniffer^([3](footnote.html#fn85))，展示了这种技术）。因此，你需要特别小心，特别是在
    `UIPasteboardNameGeneral` 和其他剪贴板中存储的内容。
- en: '***The Risks of Custom-Named Pasteboards***'
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***自定义命名剪贴板的风险***'
- en: Custom-named pasteboards are sometimes referred to as *private* pasteboards,
    which is an unfortunate misnomer. While applications can create their own pasteboards
    for internal use or to share among other specific applications, custom pasteboards
    are *public* in versions of iOS prior to 7, making them available for any program
    to use so long as their names are known.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义命名的剪贴板有时被称为 *私有* 剪贴板，这其实是一个不恰当的称呼。虽然应用程序可以创建自己的剪贴板供内部使用或与其他特定应用共享，但在 iOS
    7 之前的版本中，自定义剪贴板是 *公共的*，只要名称已知，任何程序都可以使用它们。
- en: Custom pasteboards are created with `pasteboardWithName`, and in iOS 7 and later,
    both `pasteboardWithName` and `pasteboardWithUniqueName` are specific to all applications
    within an application group. If other applications outside of this group attempt
    to create a pasteboard with a name already in use, they’ll be assigned a totally
    separate pasteboard. Note, however, that the two system pasteboards are still
    accessible by any application. Given that a number of devices can’t be upgraded
    to iOS 6, much less iOS 7, you should carefully examine how custom pasteboards
    are used in different versions of iOS.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义剪贴板通过 `pasteboardWithName` 创建，在 iOS 7 及更高版本中，`pasteboardWithName` 和 `pasteboardWithUniqueName`
    是特定于应用组内所有应用的。如果应用组外的其他应用尝试创建一个已经在使用的名字的剪贴板，它们将被分配一个完全独立的剪贴板。然而，值得注意的是，两个系统剪贴板仍然可以被任何应用访问。鉴于许多设备无法升级到
    iOS 6，更不用说 iOS 7，你应当仔细检查在不同版本的 iOS 中如何使用自定义剪贴板。
- en: One thing that you can do with a custom pasteboard is mark it as persistent
    across reboots by setting the `persistent` property to `YES`. This will cause
    pasteboard contents to be written to *$SIMPATH/Devices/<device ID>/data/Library/Caches/com.apple.UIKit.pboard/pasteboardDB*,
    along with other application pasteboards. [Listing 10-3](ch10.html#ch10ex3) shows
    some data you might see in the *pasteboardDB* file.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自定义剪贴板的一件事是，可以通过将 `persistent` 属性设置为 `YES` 来标记它在重启后仍然存在。这将导致剪贴板内容被写入 *$SIMPATH/Devices/<设备
    ID>/data/Library/Caches/com.apple.UIKit.pboard/pasteboardDB*，与其他应用程序的剪贴板一起存储。[列表
    10-3](ch10.html#ch10ex3) 显示了你可能会在 *pasteboardDB* 文件中看到的一些数据。
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 10-3: Possible contents of the* com.apple.UIKit.pboard/pasteboardDB
    *file*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-3：com.apple.UIKit.pboard/pasteboardDB 文件的可能内容*'
- en: 'The base64 blobs `bigbase64encodedblob` (too big to include in its entirety)
    and `aHR0cDovL2J1cnAvY2VydA` hold pasteboard contents, leaving those contents
    accessible to any application that can read *pasteboardDB*. Note, too, that pasteboards
    can be of different types: the Apple Web Archive pasteboard allows an entire web
    page to be stored, while the `public.text` pasteboard is the text content of the
    general pasteboard.^([4](footnote.html#fn86))'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: base64 编码的二进制数据 `bigbase64encodedblob`（太大，无法完整包含）和 `aHR0cDovL2J1cnAvY2VydA`
    保存了剪贴板内容，任何能够读取 *pasteboardDB* 的应用程序都可以访问这些内容。还需要注意的是，剪贴板有不同类型：Apple Web Archive
    剪贴板允许将整个网页存储，而 `public.text` 剪贴板则是一般剪贴板的文本内容。^([4](footnote.html#fn86))
- en: '***Pasteboard Data Protection Strategies***'
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***剪贴板数据保护策略***'
- en: 'To minimize the risk of information leakage, it’s a good idea to analyze exactly
    what behavior you’re trying to facilitate by using pasteboards. Here are some
    questions to ask yourself:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最小化信息泄露的风险，最好仔细分析你希望通过使用剪贴板实现的行为。以下是一些你可以问自己的问题：
- en: • Do I want users to copy information into other applications, or will they
    simply need to move data within my application?
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: • 我是否希望用户将信息复制到其他应用程序中，还是他们仅需要在我的应用程序内移动数据？
- en: • How long should clipboard data live?
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: • 剪贴板数据应该保留多久？
- en: • Is there any place in the application that data should never be copied from?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: • 是否有应用程序中某些地方永远不应复制数据？
- en: • Is there any part of the application that should never receive pasted data?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: • 是否有应用程序部分永远不应接收粘贴的数据？
- en: The answers to these questions will inform the way you should handle pasteboard
    data within your application. You can take a few different approaches to minimize
    data leakage.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题的答案将指导你在应用程序中如何处理剪贴板数据。你可以采用几种不同的方式来最小化数据泄露的风险。
- en: '**Wiping the Pasteboard When You Switch Apps**'
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**切换应用时清空剪贴板**'
- en: If you want your users to copy and paste only within your own application, you
    can clear the pasteboard on the appropriate events to ensure that data doesn’t
    stay on the pasteboard when the user switches applications. To do this, clear
    the pasteboard by setting `pasteBoard.items = nil` on the `applicationDidEnterBackground`
    and `applicationWillTerminate` events. This won’t prevent applications running
    in the background from reading the pasteboard, but it will shorten the lifetime
    of the data on the pasteboard and will prevent users from pasting data into apps
    they’re not supposed to.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望用户仅在你的应用程序内进行复制和粘贴，你可以在适当的事件中清空剪贴板，以确保当用户切换应用时数据不会留在剪贴板上。为此，可以在 `applicationDidEnterBackground`
    和 `applicationWillTerminate` 事件中通过设置 `pasteBoard.items = nil` 来清空剪贴板。这样做不会阻止后台运行的应用程序读取剪贴板，但会缩短剪贴板上数据的存活时间，并阻止用户将数据粘贴到不应该粘贴的应用程序中。
- en: Keep in mind that clearing the pasteboard may interfere with data the end user
    or other applications are using for a different purpose. You may want to create
    a flag that indicates whether potentially sensitive data has been written to the
    pasteboard and clear it only conditionally.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，清空剪贴板可能会干扰最终用户或其他应用程序出于不同目的使用的数据。你可能希望创建一个标志，指示是否有潜在敏感数据已写入剪贴板，并仅在特定条件下清空剪贴板。
- en: '**Preventing Copy/Paste Selectively**'
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**选择性禁止复制/粘贴**'
- en: Even when you do want to let the user copy and paste, sometimes there are specific
    places you want to disallow the option. For example, you might want to prevent
    a user from pasting in a PIN or answer to a security question (such data should
    never be on the pasteboard in the first place) yet allow the ability to paste
    in an email address from an email.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 即便你确实希望允许用户复制和粘贴，有时也会有特定的地方需要禁止这一选项。例如，你可能想要防止用户粘贴 PIN 码或安全问题的答案（此类数据本不应出现在剪贴板上），但又允许用户从电子邮件中粘贴电子邮件地址。
- en: '**NOTE**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*That’s not to say you should use security questions, which tend to enable
    account hijacking by using publicly available information as an authenticator.
    You’ll take a look at this in “[Keylogging and the Autocorrection Database](ch10.html#ch10lev1sec04)”
    on [page 175](ch10.html#page_175).*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*这并不是说你应该使用安全问题，因为安全问题往往通过使用公开可得的信息作为认证工具，容易导致账户劫持。你将在《[键盘记录与自动修正数据库](ch10.html#ch10lev1sec04)》中详细了解这一点，见[第175页](ch10.html#page_175)。*'
- en: The official way to allow users to paste some information and prevent them from
    pasting others is with the `canPerformAction:withSender` responder method.^([5](footnote.html#fn87))
    Create a new class in Xcode, as in [Figure 10-3](ch10.html#ch10fig3).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 官方的方法是使用 `canPerformAction:withSender` 响应者方法来允许用户粘贴某些信息，并防止他们粘贴其他信息。^([5](footnote.html#fn87))
    如图 [10-3](ch10.html#ch10fig3) 所示，在 Xcode 中创建一个新类。
- en: '![image](graphics/f10-03.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f10-03.jpg)'
- en: '*Figure 10-3: Creating the* `restrictedUITextField` *subclass*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-3：创建* `restrictedUITextField` *子类*'
- en: Then, edit *restrictedUITextField.m* and add the `canPerformAction` method.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，编辑 *restrictedUITextField.m* 并添加 `canPerformAction` 方法。
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 10-4: Adding* `canPerformAction` *to* restrictedUITextField.m'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单10-4：将* `canPerformAction` *添加到* restrictedUITextField.m'
- en: The `canPerformAction` method at ➊ is passed an `action` selector, which can
    be inspected to see what type of action is being requested at ➋. You can use any
    method from those specified in the `UIResponderStandardEditActions` protocol.
    If you want to entirely disable the context menu, you can, of course, simply return
    `NO` in every circumstance.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，`canPerformAction`方法接收一个`action`选择器，可以检查该选择器以查看在➋处请求的操作类型。你可以使用`UIResponderStandardEditActions`协议中指定的任何方法。如果你希望完全禁用上下文菜单，当然可以在任何情况下都返回`NO`。
- en: '**Finding and Plugging HTTP Cache Leaks**'
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**查找并修补 HTTP 缓存泄漏**'
- en: You’ll also find cached data from the URL loading system stored, unencrypted,
    in the *<app ID>/Library/Caches/com.mycompany.myapp/Cache.db** files, which are
    private to each application. HTTP caches can contain images, URLs, and text fetched
    over HTTP and can therefore expose sensitive data to a third party if examined.
    An easy way to get an idea of the type of data exposed by your application is
    to use File Juicer to carve the database into normal, readable individual files.
    You can download File Juicer at *[http://echoone.com/filejuicer/](http://echoone.com/filejuicer/)*,
    and [Figure 10-4](ch10.html#ch10fig4) shows the type of output it provides.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会发现URL加载系统的缓存数据被存储在*<app ID>/Library/Caches/com.mycompany.myapp/Cache.db*文件中，这些文件对每个应用都是私有的，并且没有加密。HTTP缓存可能包含通过HTTP获取的图像、URL和文本，因此，如果被检查，可能会将敏感数据暴露给第三方。一个简单的办法是使用File
    Juicer将数据库拆解为普通的可读文件，这样你可以大致了解应用暴露的数据类型。你可以在*[http://echoone.com/filejuicer/](http://echoone.com/filejuicer/)*下载File
    Juicer，[图10-4](ch10.html#ch10fig4)展示了它提供的输出类型。
- en: '![image](graphics/f10-04.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f10-04.jpg)'
- en: '*Figure 10-4: Examining the contents of the cache databases, split into separate
    files and directories by File Juicer*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-4：检查缓存数据库的内容，按文件类型和目录分割，由File Juicer提供*'
- en: File Juicer splits data into directories based on particular file types, so
    you can investigate stored images, plists, SQLite databases, or plaintext conversions
    of other binary file types.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: File Juicer根据特定的文件类型将数据拆分为多个目录，这样你可以调查存储的图像、plist文件、SQLite数据库或其他二进制文件类型的纯文本转换。
- en: Once you know what kind of data your application exposes through cached data,
    you can consider how best to manage it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你了解了应用通过缓存数据暴露的数据类型，就可以考虑如何最佳地管理这些数据。
- en: '***Cache Management***'
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***缓存管理***'
- en: Cache management on iOS is somewhat complex. There are many configuration settings
    and a seemingly endless number of ways to affect cache policy. On top of that,
    the platform tries to aggressively cache and copy everything it can get its hands
    on to try to improve the user experience. Developers need to determine which of
    these methods allows for secure cache management, but it’s easy to lull yourself
    into a false sense of security. Pentesters have to know when clients who think
    they are doing the right things are in fact leaking potentially sensitive information
    onto disk. Let’s talk about all the wrong ways to manage caches.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: iOS上的缓存管理有些复杂。有很多配置设置以及看似无穷无尽的方式来影响缓存策略。除此之外，平台尽力缓存并复制它能获取到的所有内容，以尝试改善用户体验。开发者需要判断哪些方法可以实现安全的缓存管理，但很容易让自己产生虚假的安全感。渗透测试者必须知道，哪些看似正确的做法实际上可能将敏感信息泄露到磁盘上。我们来谈谈所有不正确的缓存管理方式。
- en: As I mentioned in [Chapter 5](ch05.html#ch05), the documented way to remove
    cached data, `[NSURLCache removeAllCachedResponses]`, only removes cache entries
    from memory. This is essentially useless for security purposes because the same
    information is persisted to disk and is not removed. Perhaps there’s a better
    approach.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如我在[第5章](ch05.html#ch05)中提到的，文档化的移除缓存数据的方法`[NSURLCache removeAllCachedResponses]`仅仅从内存中移除缓存项。这对于安全目的来说基本没用，因为相同的信息仍然会保存在磁盘上，并且不会被移除。也许有更好的方法。
- en: Ideally, you won’t ever need to delete the cache because removal implies that
    you were caching responses in the first place. If the response data is so sensitive,
    then why not just never cache it? Let’s give that a shot.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，你永远不需要删除缓存，因为删除缓存意味着你一开始就进行了缓存操作。如果响应数据如此敏感，那为什么不干脆不缓存它呢？我们不妨试试看。
- en: The first place to start limiting cached responses is in the `NSURLCache` configuration,
    as in [Listing 10-5](ch10.html#ch10ex5). This API lets you control the amount
    of memory and disk capacity that the platform dedicates to the cache.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 限制缓存响应的第一个地方是在`NSURLCache`配置中，如[清单10-5](ch10.html#ch10ex5)所示。这个API允许你控制平台为缓存分配的内存和磁盘容量。
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 10-5: Limiting disk cache storage to zero bytes*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单10-5：将磁盘缓存存储限制为零字节*'
- en: The problem with this strategy is that the capacity manipulation APIs are not
    intended to be security mechanisms. Rather, these configurations exist to provide
    the system with information to be used when memory or disk space runs low. The
    `NSURLCache` documentation^([6](footnote.html#fn88)) specifies that both the on-disk
    and in-memory caches will be truncated to the configured sizes only if necessary.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个策略的问题在于，容量管理API并不打算作为安全机制。相反，这些配置是为了在内存或磁盘空间不足时为系统提供信息。`NSURLCache`文档^([6](footnote.html#fn88))
    指出，只有在必要时，磁盘和内存中的缓存才会被缩减到配置的大小。
- en: 'So you can’t trust configuring the cache capacity. What about setting the cache
    policy to `NSURLRequestReloadIgnoringLocalCacheData` to force the URL loading
    system to ignore any cached responses and fetch the data anew? Here’s how that
    might work:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你不能完全相信配置缓存容量。那么，设置缓存策略为`NSURLRequestReloadIgnoringLocalCacheData`，强制URL加载系统忽略任何缓存响应并重新获取数据怎么样？下面是这种方法的实现：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: But this policy is not implicitly preventing responses from being cached; it’s
    preventing the URL loading system only from *retrieving* the cached responses
    on subsequent fetches. Any previously cached responses will persist on disk, which
    poses problems if your initial app implementations allowed caching. No dice.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这个策略并没有隐含地阻止响应被缓存；它只是阻止了仅在后续请求中*检索*缓存响应的URL加载系统。任何先前缓存的响应将继续保存在磁盘上，这会导致问题，尤其是如果你的初始应用实现允许缓存的话。没有办法。
- en: As I’ve tried to demonstrate, if you rely on the system defaults for web view
    cache management, you might just implement a lot of precautions that don’t really
    protect users at all. If you want to reliably control the contents of your application
    caches, you need to do it yourself. Luckily, this isn’t actually that difficult.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我所尝试演示的那样，如果你依赖系统默认的Web视图缓存管理，你可能只是在实施许多实际上并不能保护用户的预防措施。如果你想可靠地控制应用程序缓存的内容，你需要自己来做。幸运的是，这其实并不困难。
- en: The Cocoa Touch API gives developers the ability to manipulate responses on
    a per-request basis before they are cached using the `[NSURLConnection connection:willCacheResponse:]`
    method. If you don’t want to cache the data, you can implement the delegate method,
    as shown in [Listing 10-6](ch10.html#ch10ex6).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Cocoa Touch API允许开发者在响应被缓存之前，按请求逐个操作响应，可以使用`[NSURLConnection connection:willCacheResponse:]`方法。如果你不想缓存数据，可以实现委托方法，如[列表10-6](ch10.html#ch10ex6)所示。
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 10-6: Preventing caching of responses served over secure connections*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表10-6：防止通过安全连接提供的响应被缓存*'
- en: This implementation of the delegate just returns `NULL` instead of the `NSCachedURLResponse`
    representation of the response data.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 该委托的实现只是返回`NULL`，而不是响应数据的`NSCachedURLResponse`表示。
- en: Similarly, for data fetched using the `NSURLSession` class, you’d implement
    the `[NSURLSessionDataDelegate URLSession:dataTask:willCacheResponse:completion-Handler:]`
    delegate method. Beware of relying entirely on this method, however, because it
    is called only for data and upload tasks. Caching behavior for download tasks
    will still be determined by the cache policy only and should be resolved similarly
    to [Listing 10-6](ch10.html#ch10ex6).^([7](footnote.html#fn89))
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，对于使用`NSURLSession`类获取的数据，你需要实现`[NSURLSessionDataDelegate URLSession:dataTask:willCacheResponse:completionHandler:]`委托方法。然而，要小心完全依赖这个方法，因为它仅在数据和上传任务中调用。下载任务的缓存行为仍将仅由缓存策略决定，应该像[列表10-6](ch10.html#ch10ex6)一样解决。^([7](footnote.html#fn89))
- en: In summary, caching on iOS is unreliable. Be careful, and double-check your
    app after extended use to make sure it’s not leaving sensitive information around.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，iOS上的缓存是不可靠的。要小心，并在长时间使用后再次检查你的应用，确保它没有留下敏感信息。
- en: '***Solutions for Removing Cached Data***'
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***移除缓存数据的解决方案***'
- en: The documented way to remove locally cached data is to use the `removeAllCachedResponses`
    method of the shared URL cache, shown in [Listing 10-7](ch10.html#ch10ex7).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 删除本地缓存数据的文档方式是使用共享URL缓存的`removeAllCachedResponses`方法，如[列表10-7](ch10.html#ch10ex7)所示。
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 10-7: The documented API for removing cached data*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表10-7：删除缓存数据的文档API*'
- en: A similar method, `removeCachedResponseForRequest`, exists to remove cached
    data for only specific sites. However, as you discovered in [Chapter 4](ch04.html#ch04),
    this removes only cached data from memory and not from the disk cache that you’re
    actually concerned with. I would file a bug, if Apple’s bug tracking system were
    not an infinitely hot and dense dot from which no light or information could escape.^([8](footnote.html#fn90))
    Anyway, there are a few ways you can work around this—the caching issue, I mean;
    you’re on your own if you’re unfortunate enough to have to report a bug.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个类似的方法，`removeCachedResponseForRequest`，它可以仅删除特定网站的缓存数据。然而，正如你在[第 4 章](ch04.html#ch04)中发现的那样，它只会从内存中删除缓存数据，而不会从你真正关心的磁盘缓存中删除数据。如果
    Apple 的 bug 跟踪系统不是一个无法逃逸任何光线和信息的无限炙热点的话，我真想提交一个 bug。^([8](footnote.html#fn90))
    无论如何，你可以通过几种方式绕过这个缓存问题；如果你不幸需要报告一个 bug，那就得自己解决了。
- en: '**Just Don’t Cache**'
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**直接不缓存**'
- en: In most circumstances, it’s better to just prevent caching altogether, rather
    than clean up piecemeal afterward. You can proactively set the cache capacities
    for disk and memory to zero ([Listing 10-8](ch10.html#ch10ex8)), or you can simply
    disable caching for the disk, if you’re comfortable with in-RAM caching.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，最好完全禁止缓存，而不是事后逐个清理。你可以主动将磁盘和内存的缓存容量设置为零（[示例 10-8](ch10.html#ch10ex8)），或者如果你对内存中的缓存比较放心，也可以仅禁用磁盘缓存。
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 10-8: Disallowing cache storage by limiting permitted storage space*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 10-8：通过限制允许的存储空间来禁止缓存存储*'
- en: Alternatively, you can implement a `willCacheResponse` delegate method of `NSURLConnection`,
    returning a value of `nil`, as in [Listing 10-9](ch10.html#ch10ex9).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你可以实现 `NSURLConnection` 的 `willCacheResponse` 委托方法，返回 `nil`，如[示例 10-9](ch10.html#ch10ex9)所示。
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 10-9: Sample cache discarding code*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 10-9：示例缓存丢弃代码*'
- en: This just checks whether a cached response has been sent at ➊ and, if it finds
    one, sets it to `nil` at ➋. You can also conditionally cache data by examining
    the properties of the response before returning the object to cache, as shown
    in [Listing 10-10](ch10.html#ch10ex10).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是检查在 ➊ 处是否已发送缓存响应，如果找到了，则在 ➋ 处将其设置为 `nil`。你还可以通过检查响应的属性，在返回对象到缓存之前有条件地缓存数据，如[示例
    10-10](ch10.html#ch10ex10)所示。
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 10-10: Conditional cache discarding code*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 10-10：条件缓存丢弃代码*'
- en: This is nearly the same as in [Listing 10-9](ch10.html#ch10ex9), but it additionally
    examines the response being cached at ➊ to determine whether it is being delivered
    over HTTPS and discards it if that’s the case.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎与[示例 10-9](ch10.html#ch10ex9)中的代码相同，但它额外检查在 ➊ 处被缓存的响应，以确定其是否通过 HTTPS 传输，并在这种情况下丢弃它。
- en: 'If you’re using `NSURLSession`, you can also use ephemeral sessions, which
    will not store any data to disk; this includes caches, credentials, and so forth.
    Creating an ephemeral session is easy. Just instantiate a configuration object
    for your `NSURLSession`s, like so:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 `NSURLSession`，你还可以使用临时会话，这些会话不会将任何数据存储到磁盘，包括缓存、凭据等。创建一个临时会话非常简单，只需为你的
    `NSURLSession` 实例化一个配置对象，如下所示：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can find more information and examples of how to use `NSURLSession` in [Chapter
    7](ch07.html#ch07).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[第 7 章](ch07.html#ch07)中找到更多关于如何使用 `NSURLSession` 的信息和示例。
- en: '**Disable Caching via the Server**'
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**通过服务器禁用缓存**'
- en: 'Presuming you control the server your application communicates with, you can
    instruct the client not to cache requests using the `Cache-Control` HTTP header.
    This allows you to either disable caching application-wide or apply it only to
    specific requests. The mechanism for implementing this on the server side is language-dependent,
    but the header you’ll want to return for requests you don’t want cached is as
    follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你控制着你的应用程序与之通信的服务器，你可以通过 `Cache-Control` HTTP 头来指示客户端不要缓存请求。这允许你要么禁用整个应用程序的缓存，要么仅对特定请求应用缓存。实现该机制的方式依赖于服务器端的编程语言，但你需要返回的头部是以下内容：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Sadly, at least some versions of iOS (verified as of 6.1) don’t actually obey
    these headers. It’s a good idea to set them for sensitive resources regardless,
    but don’t rely on this method to solve the problem entirely.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，至少在某些版本的 iOS 中（已验证到 6.1 版本），这些头部并没有得到遵守。尽管如此，最好仍然为敏感资源设置这些头部，但不要完全依赖这种方法来解决问题。
- en: '**Go Nuclear**'
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用核选项**'
- en: The previous approaches will prevent data from being cached, but sometimes you
    may want to cache data and then clean it up later. This could be for performance
    reasons or perhaps because you’re correcting a caching problem in a newly released
    version of your application, which has already cached data locally on disk. Whatever
    your reason, clearing the cache in the documented manner doesn’t work, so you’re
    stuck removing the cached data forcibly, as in [Listing 10-11](ch10.html#ch10ex11).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的方法会阻止数据被缓存，但有时你可能希望缓存数据，然后稍后清理它。这可能是出于性能考虑，或者是因为你在修复应用程序新版本中缓存问题，而该版本已经在本地磁盘上缓存了数据。无论原因是什么，按照文档中的方式清理缓存不起作用，因此你只能像在[示例
    10-11](ch10.html#ch10ex11)中那样强制移除缓存数据。
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 10-11: Manually removing the cache database*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 10-11：手动移除缓存数据库*'
- en: There’s no guarantee that some other part of the system won’t freak out if you
    clear cached data manually. However, this method is the only reliable way I’ve
    found to remove cached data after it’s already been written to disk.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 没有保证系统的其他部分在你手动清理缓存数据时不会出问题。然而，这种方法是我发现的唯一可靠方式，用来在缓存数据已经写入磁盘后移除它。
- en: '***Data Leakage from HTTP Local Storage and Databases***'
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***HTTP本地存储和数据库中的数据泄露***'
- en: 'The HTML 5 specification allows websites to store and retrieve large amounts
    of data (larger than what would fit in a cookie) on the client. These mechanisms
    are sometimes used to cache data locally so that primarily web-based applications
    can function in an offline mode. You can find these databases in a number of locations
    on the device or your simulator, including the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 5规范允许网站在客户端存储和检索大量数据（比cookie能存储的更多）。这些机制有时用于本地缓存数据，使主要基于Web的应用程序能够在离线模式下运行。你可以在设备或模拟器上的多个位置找到这些数据库，包括以下位置：
- en: • */Library/Caches/*.localstorage*
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: • */Library/Caches/*.localstorage*
- en: • */Library/Caches/Databases.db*
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: • */Library/Caches/Databases.db*
- en: • */Library/Caches/file__0/*.db*
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: • */Library/Caches/file__0/*.db*
- en: You can feed these locations to File Juicer the same way you do with HTTP caches
    to get access to the plaintext data. One obvious application for larger local
    storage and SQL databases is storing structured information about communications
    such as email so that those communications can be accessed when the user doesn’t
    have cell phone reception. This can leave traces around the storage databases,
    as shown in [Figure 10-5](ch10.html#ch10fig5).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像处理HTTP缓存一样，将这些位置提供给File Juicer，以便访问纯文本数据。对于更大的本地存储和SQL数据库，一个明显的应用场景是存储关于通信的结构化信息，例如电子邮件，这样即使用户没有手机信号，也能访问这些通信。这可能会在存储数据库中留下痕迹，如[图
    10-5](ch10.html#ch10fig5)所示。
- en: This exposure is probably an acceptable risk for metadata, but storing it in
    an encrypted SQLite store might be better, especially when storing full message
    contents. I’ll talk more about how to do this in “[Data Protection API](ch13.html#ch13lev1sec02)”
    on [page 219](ch13.html#page_219).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这种暴露可能是元数据可以接受的风险，但将其存储在加密的SQLite存储中可能更好，特别是当存储完整的消息内容时。我将在“[数据保护 API](ch13.html#ch13lev1sec02)”中详细讲解如何实现这一点，见[第219页](ch13.html#page_219)。
- en: '![image](graphics/f10-05.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f10-05.jpg)'
- en: '*Figure 10-5: Email metadata left in a mail client*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-5：邮件客户端中留下的电子邮件元数据*'
- en: '**Keylogging and the Autocorrection Database**'
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**键盘记录与自动修正数据库**'
- en: Everyone is familiar with iOS’s word autocompletion mechanism, the source of
    endless entertainment and amusing typos (and of frustration when trying to use
    expletives). One aspect of this system that’s gained some attention in the press
    is that the autocompletion mechanism acts as an accidental keylogger, recording
    portions of the text that a user types in what is basically a plaintext file to
    help with future completions. A forensic attacker could then retrieve that completion
    database.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人都熟悉iOS的自动完成功能，它是源源不断的娱乐和有趣的打字错误（当试图输入脏话时，尤其令人沮丧）。这个系统的一个方面在媒体中引起了一些关注，即自动完成功能充当了一个意外的键盘记录器，记录用户键入的部分文本，基本上是一个纯文本文件，用来帮助未来的自动补全。一个取证攻击者可以从中检索到这个补全数据库。
- en: This behavior is already disabled for password fields—that is, `UITextField`
    objects with `setSecureTextEntry:YES` set—but many other forms in an application
    may take sensitive data. As such, developers have to consider the all too common
    trade-off between user experience and security. For some applications, no amount
    of unencrypted data stored to disk is acceptable. Other applications handle sensitive
    data, but they involve so much text entry that disabling autocorrection would
    be extremely burdensome.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为已经在密码字段中被禁用——也就是说，对于设置了`setSecureTextEntry:YES`的`UITextField`对象——但应用程序中的许多其他表单也可能包含敏感数据。因此，开发人员必须考虑用户体验和安全性之间常见的权衡。对于某些应用程序，存储任何未加密的数据到磁盘都是不可接受的。其他应用程序处理敏感数据，但涉及大量文本输入，因此禁用自动更正将变得非常麻烦。
- en: Fields that take smaller amounts of sensitive data, though, are a no-brainer.
    Consider answers to security questions, for example. For these fields, you’ll
    want to disable autocorrection behavior by setting the `autocorrectionType` property
    to `UITextAutocorrectionTypeNo` on `UITextField` and `UITextView` objects. This
    is also applicable (and a good idea) for `UISearchBar` objects because having
    search contents leak to disk is usually undesirable. Check out [Listing 10-12](ch10.html#ch10ex12)
    for an example of how you might try to disable this attribute.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，处理少量敏感数据的字段，毫无疑问是简单明了的。例如，考虑一下安全问题的答案。对于这些字段，你需要通过将`autocorrectionType`属性设置为`UITextAutocorrectionTypeNo`来禁用自动更正功能，适用于`UITextField`和`UITextView`对象。这对于`UISearchBar`对象同样适用（也是个不错的主意），因为搜索内容泄露到磁盘通常是不希望的。查看[清单
    10-12](ch10.html#ch10ex12)了解如何禁用此属性的示例。
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 10-12: Disabling autocorrection on a* `UITextField`'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-12：禁用* `UITextField` *的自动更正功能*'
- en: Of course, note that I say, “You’ll want to disable this behavior.” You’ll *want*
    to, but you can’t. Around iOS 5.1, a bug crept in that causes the on-disk word
    cache to be updated even if you disable autocorrection, autocapitalization, spellcheck,
    and so on. There are currently two ways around this, ranging from very silly to
    utterly ridiculous.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，注意我说的是，“你将想要禁用这个行为。”你*想要*禁用，但你做不到。在iOS 5.1左右，一个bug悄悄出现，即使你禁用了自动更正、自动大写、拼写检查等，磁盘上的单词缓存仍会被更新。目前有两种绕过这种情况的方法，从非常傻到完全荒谬。
- en: The silly approach (shown in [Listing 10-13](ch10.html#ch10ex13)) is to use
    a `UITextView` (note `View`, rather than `Field`) and send it the message `setSecureTextEntry:YES`.
    The `UITextView` class doesn’t actually implement the `UITextInputTraits` protocol^([9](footnote.html#fn91))
    correctly, so text isn’t obscured by circles like it would be in a `UITextField`
    configured for password entry. It *does*, however, prevent text from getting written
    to the disk.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 傻乎乎的做法（如[清单 10-13](ch10.html#ch10ex13)所示）是使用`UITextView`（注意是`View`，而不是`Field`），并发送消息`setSecureTextEntry:YES`。`UITextView`类实际上并没有正确实现`UITextInputTraits`协议^([9](footnote.html#fn91))，因此文本不会像在配置为密码输入的`UITextField`中那样被圆圈遮挡。然而，它确实可以防止文本写入磁盘。
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 10-13: Setting the* `SecureTextEntry` *attribute on a* `UITextView`'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-13：设置* `SecureTextEntry` *属性在* `UITextView` *上的应用*'
- en: The ridiculous method, which works on both `UITextView` and `UITextField` objects,
    is shown in [Listing 10-14](ch10.html#ch10ex14).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 可笑的方法，适用于`UITextView`和`UITextField`对象，显示在[清单 10-14](ch10.html#ch10ex14)中。
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 10-14: Twiddling* `setSecureTextEntry` *on a* `UITextField`'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-14：在* `UITextField` *上摆弄* `setSecureTextEntry` *功能*'
- en: Yes, seriously. Just switch keylogging on and then turn it off.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，真的。只需开启按键记录，然后再关闭它。
- en: The classes are implemented such that they forget to turn keylogging back on
    if you simply wiggle it on and off again. Unfortunately, `UISearchbar` *also*
    doesn’t implement the protocol correctly, so you can’t pull this trick on one
    of the search bars. If preventing data leakage from your search bar is critical,
    you may want to replace the search bar with an appropriately styled text field
    instead.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类的实现方式是，如果你只是简单地切换它，它会忘记重新开启按键记录。遗憾的是，`UISearchbar` *也*没有正确实现协议，因此你无法在搜索框上使用这个技巧。如果防止搜索框数据泄露至关重要，你可能想要用一个适当样式的文本框来替代搜索框。
- en: Of course, that bug might be fixed in a future version of the OS, so just be
    prudent and ensure that the OS your app is running on is a version that you’ve
    tested the behavior on before you do this yes/no flipping trick. [Listing 10-15](ch10.html#ch10ex15)
    shows how to do this.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个bug可能会在未来的操作系统版本中得到修复，所以你应该谨慎，确保你的应用运行在你已经测试过行为的操作系统版本上，然后再执行这种“是/否切换”技巧。[清单
    10-15](ch10.html#ch10ex15)展示了如何做到这一点。
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 10-15: Checking iOS version*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-15：检查 iOS 版本*'
- en: To help verify that your application isn’t leaking anything unexpected, you
    can also check *<device ID>/data/Library/Keyboard/dynamic-text.dat* on the simulator
    or on a jailbroken device. ([Figure 10-6](ch10.html#ch10fig6) shows an example
    *dynamic-text.dat* file.) This isn’t going to catch every corner case of what
    might be committed to the database, but the file should give you a reasonable
    idea. Note that the database may not actually get updated until you hit the Home
    button.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助验证您的应用程序是否泄露了任何意外信息，您还可以检查模拟器或越狱设备上的*<device ID>/data/Library/Keyboard/dynamic-text.dat*。([图
    10-6](ch10.html#ch10fig6) 显示了一个示例 *dynamic-text.dat* 文件。) 这并不能捕捉到可能被提交到数据库的所有边缘情况，但该文件应该能为您提供合理的线索。请注意，数据库可能直到按下
    Home 按钮后才会实际更新。
- en: '![image](graphics/f10-06.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f10-06.jpg)'
- en: '*Figure 10-6: Contents of* dynamic-text.dat *after using the keyboard to enter
    message contents. Note that the order of words does not reflect the order in which
    they were entered.*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-6：使用键盘输入消息内容后的 dynamic-text.dat 内容。请注意，单词的顺序并不反映它们被输入的顺序。*'
- en: 'In iOS 8 and later, additional information is stored in the Keyboard cache.
    This data is used to help with the QuickType word prediction system, but it also
    leaks more information about conversations and people who have communicated with
    the device owner. In the *<device ID>/data/Library/Keyboard/en-dynamic.lm* directory,^([10](footnote.html#fn92))
    you’ll find four additional data files: *dynamic.dat*, *lexicon.dat*, *meta.dat*,
    and *tags.dat*. Check all these files for data entered into your application.
    Because QuickType adapts based on the recipient, the *tags.dat* file also includes
    a list of past message recipients so the completion system can use the correct
    cache for the correct recipient.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在 iOS 8 及更高版本中，额外的信息被存储在键盘缓存中。这些数据用于帮助快速输入预测系统（QuickType），但它也泄露了关于对话和与设备所有者交流过的人更多的信息。在*<device
    ID>/data/Library/Keyboard/en-dynamic.lm* 目录中，^([10](footnote.html#fn92)) 您将找到四个额外的数据文件：*dynamic.dat*、*lexicon.dat*、*meta.dat*
    和 *tags.dat*。请检查所有这些文件中是否有您应用程序输入的数据。因为 QuickType 会根据接收者进行适应，*tags.dat* 文件还包含过去的消息接收者列表，以便完成系统为正确的接收者使用正确的缓存。
- en: '**Misusing User Preferences**'
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**误用用户偏好设置**'
- en: As I briefly mentioned in [Chapter 3](ch03.html#ch03), user preferences often
    contain sensitive information. But user defaults are actually intended to define,
    say, what URL an app’s API should be at or other nonsensitive preference information.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在[第3章](ch03.html#ch03)中简要提到的，用户偏好设置通常包含敏感信息。但实际上，用户默认设置的目的是定义诸如应用程序的 API
    应该使用哪个 URL 或其他非敏感的偏好信息。
- en: Preferences are manipulated through the `NSUserDefaults` API or, less commonly,
    the `CFPreferences` API, and many developers clearly must not know what happens
    to that data on the device. Restrictions on these files are fairly loose, and
    user preferences can easily be read and manipulated using commonly available tools,
    such as iExplorer.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 用户偏好设置通过`NSUserDefaults` API 或较少使用的`CFPreferences` API 进行操作，许多开发者显然并不清楚这些数据在设备上的处理方式。这些文件的限制相对宽松，用户的偏好设置可以很容易地被读取和修改，使用常见的工具（如
    iExplorer）即可实现。
- en: '[Listing 10-16](ch10.html#ch10ex16) shows an intentionally terrible usage of
    `NSUserDefaults` from the iGoat project.^([11](footnote.html#fn93))'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 10-16](ch10.html#ch10ex16) 显示了来自 iGoat 项目的一个故意糟糕的`NSUserDefaults`使用方式。^([11](footnote.html#fn93))'
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 10-16: The worst possible way to use* `NSUserDefaults`'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-16：使用`NSUserDefaults`的最糟糕方式*'
- en: 'This is essentially the worst-case scenario for data leakage: the credentials
    are stored in plaintext in a plist belonging to the app. Many applications in
    the wild store user credentials this way, and many have been called out for it.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这本质上是数据泄露的最坏情况：凭证以明文存储在属于应用的 plist 文件中。许多实际应用程序就是以这种方式存储用户凭证的，且许多因此受到了批评。
- en: One less common problem with `NSUserDefaults` is that developers may use it
    to store information that really shouldn’t be under a user’s control. For example,
    some apps hand over the reins for security controls that dictate whether users
    can download and store files locally or whether they’re required to enter a PIN
    before using the app. To protect users, let the server enforce such decisions
    as often as possible instead.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一个较不常见的问题是，`NSUserDefaults` 可能被开发者用来存储一些实际上不应该由用户控制的信息。例如，有些应用会交出控制权，允许用户决定是否可以下载和存储文件，或是否需要在使用应用之前输入
    PIN 码。为了保护用户，尽可能让服务器来执行这些决策。
- en: When auditing an application, check each use of the `NSUserDefaults` or `CFPreferences`
    APIs to ensure that the data being stored there is appropriate. There should be
    no secret information or information you don’t want a user to change.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在审核应用程序时，请检查每次使用`NSUserDefaults`或`CFPreferences` API的情况，以确保存储的数据是合适的。那里不应存储任何机密信息或用户不希望被修改的信息。
- en: '**Dealing with Sensitive Data in Snapshots**'
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**处理快照中的敏感数据**'
- en: As I also discussed in [Chapter 3](ch03.html#ch03), iOS snapshots an app’s current
    screen state before sending the app to the background so it can generate an animation
    when the app is opened again. This results in potentially sensitive information
    littering the disk, sometimes even if the user doesn’t intentionally background
    the app. For example, if someone happens to answer a call in the middle of entering
    sensitive information into an application, that screen state will be written to
    disk and remain there until overwritten with another snapshot. I’ve seen many
    applications willing to record people’s SSNs or credit card numbers in this fashion.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在[第 3 章](ch03.html#ch03)中所讨论的，iOS 会在将应用发送到后台之前拍摄当前屏幕的快照，这样在重新打开应用时就可以生成动画。这导致潜在的敏感信息散布在磁盘上，有时即使用户并未故意将应用送入后台也会发生。例如，如果某人在输入敏感信息时接了电话，那么该屏幕状态将被写入磁盘，并一直保留，直到被另一个快照覆盖。我见过许多应用程序在这种方式下记录用户的社会安全号码或信用卡号码。
- en: Once these snapshots are written to disk, a physical attacker can easily retrieve
    them with common forensics tools. You can even observe the file being written
    using the Simulator, as shown in [Figure 10-7](ch10.html#ch10fig7).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些快照被写入磁盘，物理攻击者可以使用常见的取证工具轻松地恢复它们。你甚至可以使用模拟器观察文件被写入的过程，如[图 10-7](ch10.html#ch10fig7)所示。
- en: '![image](graphics/f10-07.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f10-07.jpg)'
- en: '*Figure 10-7: A snapshot of a user searching for embarrassing material on Wikipedia,
    saved to local storage*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-7：用户在 Wikipedia 上搜索尴尬材料的快照，已保存到本地存储*'
- en: Just suspend your application and open *UIApplicationAutomaticSnapshot Default-Portrait.png*,
    which you’ll find under your app’s *Library/Caches/Snapshots/com.mycompany.myapp*
    directory. Unfortunately, applications can’t just go and remove snapshots manually.
    There are, however, a couple of other ways you can prevent this data from leaking.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 只需挂起应用程序并打开*UIApplicationAutomaticSnapshot Default-Portrait.png*，你可以在应用程序的*Library/Caches/Snapshots/com.mycompany.myapp*目录下找到该文件。不幸的是，应用程序不能直接手动删除快照。然而，还是有几种其他方法可以防止这些数据泄露。
- en: '***Screen Sanitization Strategies***'
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***屏幕清理策略***'
- en: First, you can alter the screen state before the screenshot actually occurs.
    You’ll want to implement this in the `applicationDidEnterBackground` delegate
    method, which is the message that your program receives when the application is
    going to be suspended, giving you a few seconds to complete any tasks before this
    occurs.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以在实际截取屏幕截图之前改变屏幕状态。你应该在`applicationDidEnterBackground`委托方法中实现这一点，这是当应用程序即将挂起时系统发送给你的消息，给你几秒钟时间来完成任何任务。
- en: This delegate is distinct from the `applicationWillResignActive` or `applicationWillTerminate`
    events. The former is invoked when the application temporarily loses focus (for
    example, when interrupted by an incoming phone call overlay) and the latter when
    the application is forcibly killed or has opted out of background operation.^([12](footnote.html#fn94))
    For an abbreviated example of the events received over the life cycle of an iOS
    application, see [Figure 10-8](ch10.html#ch10fig8).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个委托与`applicationWillResignActive`或`applicationWillTerminate`事件不同。前者在应用程序暂时失去焦点时触发（例如，当被来电覆盖时），后者则在应用程序被强制终止或选择退出后台操作时触发。^([12](footnote.html#fn94))有关
    iOS 应用生命周期中接收到的事件的简化示例，请参见[图 10-8](ch10.html#ch10fig8)。
- en: '![image](graphics/f10-08.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f10-08.jpg)'
- en: '*Figure 10-8: The simplified iOS application life cycle. Code for handling
    these events can be defined in the application delegate.*'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-8：简化的 iOS 应用生命周期。可以在应用委托中定义处理这些事件的代码。*'
- en: After these tasks are complete, the snapshot should be taken, and the application
    should disappear with its little “whoosh” animation. But how can you sanitize
    your user’s screen?
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这些任务后，应该拍摄快照，并且应用程序应该消失，伴随着轻微的“嗖”声动画。但你如何清理用户的屏幕呢？
- en: The simplest and most reliable method of obscuring screen contents, and the
    one that I primarily recommend, is simply placing a splash screen with some logo
    art on top of all the current views. You can implement this as shown in [Listing
    10-17](ch10.html#ch10ex17).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单且最可靠的屏幕内容遮掩方法，也是我主要推荐的方法，就是在所有当前视图上方放置一个包含一些logo艺术的启动画面。你可以按照[Listing 10-17](ch10.html#ch10ex17)所示来实现。
- en: '[PRE19]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 10-17: Applying a splash screen*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 10-17：应用启动画面*'
- en: With this code in place, on entering the background, your application should
    set whatever image you have stored in *myimage.png* as the splash screen. Alternatively,
    you could set the `hidden` attribute of the relevant container objects—for example,
    `UITextField`s, whose contents might be sensitive. You can use this same approach
    to hide the entire `UIView`. This is less visually appealing but easily does the
    job in a pinch.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了这段代码后，当应用程序进入后台时，你应该将存储在*myimage.png*中的图像设置为启动画面。或者，你可以设置相关容器对象的`hidden`属性——例如，`UITextField`，它的内容可能是敏感的。你也可以用这种方法隐藏整个`UIView`。这种方法不太好看，但在紧急情况下能轻松完成任务。
- en: A slightly fancier option is to perform some of your own animation,^([13](footnote.html#fn95))
    as in [Listing 10-18](ch10.html#ch10ex18). This just does a fade-out before removing
    the content from the view.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一个稍微复杂一点的选项是执行你自己的动画^([13](footnote.html#fn95))，如[Listing 10-18](ch10.html#ch10ex18)所示。这只是做了一个渐变消失的动画，然后再从视图中移除内容。
- en: '[PRE20]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 10-18: Animating a fade to transparency*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 10-18：动画渐变到透明*'
- en: I even saw one application that took its own screenshot of the current screen
    state and ran the screenshot through a blur algorithm. It looked pretty, but hitting
    all the corner cases is tricky, and you’d have to ensure that the blur is destructive
    enough that an attacker couldn’t reverse it.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我甚至看到有一个应用程序会自动截图当前屏幕状态，并将截图通过模糊算法处理。它看起来很漂亮，但处理所有角落情况非常棘手，而且你需要确保模糊效果足够强烈，以至于攻击者无法还原它。
- en: Regardless of your obfuscation approach, you’ll also need to reverse your changes
    in either the `applicationDidBecomeActive` or `applicationWillEnter Foreground`
    delegate method. For example, to remove the splash image placed over the screen
    in [Listing 10-17](ch10.html#ch10ex17), you could add something like [Listing
    10-19](ch10.html#ch10ex19) to the `applicationWillEnterForeground` method.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 不管你采用哪种混淆方法，你还需要在`applicationDidBecomeActive`或`applicationWillEnterForeground`委托方法中撤销这些更改。例如，为了移除[Listing
    10-17](ch10.html#ch10ex17)中放置的屏幕上的启动画面，你可以在`applicationWillEnterForeground`方法中添加类似[Listing
    10-19](ch10.html#ch10ex19)的内容。
- en: '[PRE21]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 10-19: Removing a splash screen*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 10-19：移除启动画面*'
- en: Before you’re done, ensure that your sanitization technique is effective by
    repeatedly suspending your app in different application states while monitoring
    your application’s *Library/Caches/Snapshots/com.mycompany.myapp* directory. Check
    that the PNG images saved there have all parts of the window obscured by the splash
    image.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在你完成之前，通过反复将应用程序置于不同的状态，同时监控应用程序的*Library/Caches/Snapshots/com.mycompany.myapp*目录，确保你的清理技术有效。检查保存在该目录中的PNG图片，确保窗口的所有部分都被启动画面遮盖。
- en: '**NOTE**'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The* com.mycompany.myapp *directory is re-created on every suspension of the
    application. If you’re watching for the file to be created in that directory from
    the Terminal, you’ll have to reenter the directory using* `*cd $PWD*` *or similar
    for the file to appear.*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*com.mycompany.myapp*目录在每次应用程序挂起时都会重新创建。如果你通过终端监视该目录中的文件创建，你需要重新进入该目录，使用`*cd
    $PWD*`或类似的命令才能看到文件。'
- en: '***Why Do Those Screen Sanitization Strategies Work?***'
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***这些屏幕清理策略为什么有效？***'
- en: People often misunderstand the fixes I just described because they don’t grasp
    how iOS lays out its views and windows, so I’ve created a flowchart ([Figure 10-9](ch10.html#ch10fig9))
    that shows everything you need to know.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 人们常常误解我刚才描述的修复方法，因为他们没有理解iOS是如何布局视图和窗口的，所以我制作了一个流程图（[图10-9](ch10.html#ch10fig9)），展示了你需要知道的一切。
- en: '![image](graphics/f10-09.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f10-09.jpg)'
- en: '*Figure 10-9: The hierarchy of iOS views*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-9：iOS视图层级*'
- en: Every application that displays contents on the screen is backed by a *layer*,
    which is `CALayer` by default. On top of the layer is an instance of the `UIWindow`
    class, which manages one or more *views*, instances of the `UIView` class. `UIView`s
    are hierarchical, so a view can have multiple subviews along with buttons, text
    fields, and so forth.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 每个在屏幕上显示内容的应用程序都由一个*图层*支持，默认情况下是`CALayer`。在图层之上是一个`UIWindow`类的实例，它管理一个或多个*视图*，即`UIView`类的实例。`UIView`是层次结构的，因此一个视图可以有多个子视图，包括按钮、文本框等等。
- en: iOS apps typically have only one `UIWindow`, but multiple windows are quite
    possible. By default, windows have a `windowLevel` property of 0.0, specifying
    that the window is at the `UIWindowLevelNormal` level. Other defined levels are
    `UIWindowlevelAlert` and `UIWindowlevelStatusBar`, both of which have level priority
    over `UIWindowLevelNormal`, meaning that they’ll appear on top of other windows.
    The most obvious scenario is that of an alert, and in that case, `UIAlertView`
    creates a new window on top of all others except the status bar by default.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: iOS应用程序通常只有一个`UIWindow`，但多个窗口也是完全可能的。默认情况下，窗口的`windowLevel`属性值为0.0，表示该窗口处于`UIWindowLevelNormal`级别。其他定义的级别包括`UIWindowLevelAlert`和`UIWindowLevelStatusBar`，这两个级别优先于`UIWindowLevelNormal`，意味着它们会出现在其他窗口之上。最明显的场景是弹出警告框，在这种情况下，`UIAlertView`默认会在所有其他窗口之上创建一个新窗口，但不包括状态栏。
- en: The window currently receiving user events is referred to as the key window,
    and it can be referenced via the `keyWindow` method in `UIApplication`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当前接收用户事件的窗口被称为关键窗口，可以通过`UIApplication`中的`keyWindow`方法来引用它。
- en: '***Common Sanitization Mistakes***'
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***常见的清理错误***'
- en: 'Developers who don’t understand iOS windows and views frequently sanitize screens
    incorrectly. I’ve seen several applications that have taken a few development
    iterations to get it right. One flaw I’ve seen is to set only the key window’s
    `rootViewController` to `hidden`, like so:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 不理解iOS窗口和视图的开发者经常会错误地清理屏幕。我见过一些应用程序需要经过几次开发迭代才能正确实现。我看到的一个问题是只将关键窗口的`rootViewController`设置为`hidden`，如下所示：
- en: '[PRE22]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This mistake is understandable because most developers are used to working
    with `UIView`s when programming GUIs. While the code will *look* like it works
    much of the time, it still leaves any subviews of the root visible. An improvement
    would be to hide the entire key window, like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误是可以理解的，因为大多数开发者在编写图形界面时习惯使用`UIView`。虽然代码看起来*像*是正常工作的，但它仍然会让根视图的任何子视图保持可见。一个改进的方法是隐藏整个关键窗口，如下所示：
- en: '[PRE23]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: But hiding the key window isn’t a failsafe option either because any `UIAlertView`
    windows will appear above other content and become the key window; effectively,
    you’d end up hiding only the alert.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 但是隐藏关键窗口也不是一种万无一失的选择，因为任何`UIAlertView`窗口都会出现在其他内容之上并成为关键窗口；实际上，您将只会隐藏警告框。
- en: 'Because several methods of hiding content are error prone, I almost always
    recommend that developers use the splash screen approach. There is, however, an
    even easier, foolproof approach for some use cases: preventing suspension entirely.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 由于几种隐藏内容的方法容易出错，我几乎总是建议开发者使用启动画面方法。然而，对于某些使用场景，还有一种更简单、万无一失的方法：完全防止挂起。
- en: '***Avoiding Snapshots by Preventing Suspension***'
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***通过防止挂起来避免快照***'
- en: If your application never really needs to be suspended and resumed (that is,
    if you want a fresh start with every app launch), then use the Xcode plist editor
    to add “Application does not run in background” to your plist and set the value
    to `YES`, as in [Figure 10-10](ch10.html#ch10fig10). You can also set `UIApplicationExitsOnSuspend`
    to `YES` in your *Info.plist* file from your favored text editor.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序根本不需要挂起和恢复（也就是说，如果您希望每次启动应用时都有一个全新的开始），那么可以使用Xcode的plist编辑器将“应用程序在后台不运行”项添加到您的plist文件中，并将其值设置为`YES`，如[图10-10](ch10.html#ch10fig10)所示。您还可以在您喜欢的文本编辑器中，将`UIApplicationExitsOnSuspend`设置为`YES`，以便在*Info.plist*文件中实现。
- en: Adding that item will cause the application to jump to the `applicationWillTerminate`
    event rather than stopping at the `applicationDidEnterBackground` event, which
    normally immediately precedes the taking of the screenshot.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 添加该项将使应用程序跳转到`applicationWillTerminate`事件，而不是停留在`applicationDidEnterBackground`事件，该事件通常会紧接着屏幕截图的捕捉过程。
- en: '![image](graphics/f10-10.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f10-10.jpg)'
- en: '*Figure 10-10: Adding the “Application does not run in background” item to
    the plist*'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-10：将“应用程序在后台不运行”项添加到plist文件中*'
- en: '**Leaks Due to State Preservation**'
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**由于状态保存导致的内存泄漏**'
- en: iOS 6 introduced the concept of *state preservation*, which provides a method
    for maintaining application state between invocations, even if the application
    is killed in the meantime. When state preservation is triggered, each preservable
    object’s `encodeRestorableStateWithCoder` delegate method, which contains instructions
    for how to serialize various UI elements to disk, is called. Then, the `decodeRestorableStateWithCoder`
    method is called on relaunch of the application. This system presents a possibility
    for sensitive information to leak from the user interface to storage on disk since
    the contents of text fields and other interface data will be put on local storage.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 6引入了*状态保存*的概念，这为在应用程序调用之间保持状态提供了一种方法，即使在此过程中应用程序被终止。当触发状态保存时，调用每个可保存对象的`encodeRestorableStateWithCoder`委托方法，其中包含如何将各种UI元素序列化到磁盘的指令。然后，在应用程序重新启动时调用`decodeRestorableStateWithCoder`方法。该系统存在一个可能性，即敏感信息可能会从用户界面泄露到磁盘存储中，因为文本字段的内容和其他界面数据将被存储在本地存储中。
- en: When you are examining a new codebase, you can quickly determine whether any
    state preservation is happening by grepping the codebase for `restorationIdentifier`,
    rather than clicking your way through all the Storyboard UI elements.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当你检查一个新的代码库时，你可以通过在代码库中查找`restorationIdentifier`，快速判断是否有状态保存发生，而不需要逐个点击所有Storyboard
    UI元素。
- en: 'If preservation is in use, you should find results like this one in the **.storyboard*
    files:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果启用了状态保存功能，你应该在**.storyboard**文件中找到像这样的结果：
- en: '[PRE24]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that there is a view controller with a `restorationIdentifier` attribute,
    and this controller contains a subview with a `textView` object. If the application
    delegate implements the `encodeRestorableStateWithCoder` method, it can specify
    an `encodeObject` method that preserves the `.text` attribute of the `UITextView`
    for later restoration. This method can be used to ensure that text typed into
    the field isn’t lost if the application is terminated,^([14](footnote.html#fn96))
    as shown in [Listing 10-20](ch10.html#ch10ex20).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，有一个视图控制器具有`restorationIdentifier`属性，并且该控制器包含一个子视图，其中有一个`textView`对象。如果应用程序代理实现了`encodeRestorableStateWithCoder`方法，它可以指定一个`encodeObject`方法，以保存`UITextView`的`.text`属性以供后续恢复。这个方法可以用来确保在应用程序被终止时，输入框中的文本不会丢失，^([14](footnote.html#fn96))
    如[示例 10-20](ch10.html#ch10ex20)所示。
- en: '[PRE25]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 10-20: An example* `encodeRestorableStateWithCoder` *method*'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 10-20：一个`encodeRestorableStateWithCoder`方法示例*'
- en: After performing functional testing, you can also examine the application’s
    *Library/Saved Application State/com.company.appname.savedState* directory, where
    you’ll find the descriptively named *data.data* file. This file contains the serialized
    state of the application for objects that have `restorationIdentifiers` assigned.
    Examine this file to determine whether any sensitive data from the user interface
    may have been encoded. You can also do this on the device, if you’re performing
    black-box testing.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 完成功能测试后，你还可以检查应用程序的*Library/Saved Application State/com.company.appname.savedState*目录，在那里你会找到命名描述性的*data.data*文件。这个文件包含了具有`restorationIdentifiers`的对象的序列化状态。检查这个文件以确定是否有来自用户界面的敏感数据被编码。如果你正在进行黑盒测试，也可以在设备上执行此操作。
- en: '**Secure State Preservation**'
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**安全状态保存**'
- en: If a product needs the UX and convenience of state preservation but needs data
    to be stored securely while on disk, you can encrypt sensitive object contents
    before passing them to the `encodeObject` method. I discuss encryption in more
    detail in [Chapter 13](ch13.html#ch13)), but here’s how you’d encrypt this particular
    sort of data.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个产品需要状态保存的用户体验和便捷性，但需要将数据安全地存储在磁盘上，你可以在将敏感对象内容传递给`encodeObject`方法之前对其进行加密。我在[第13章](ch13.html#ch13)中详细讨论了加密，但这里是如何加密这种特定类型的数据的。
- en: When the application is installed, generate an encryption key and store it in
    the Keychain with `secItemAdd`. Then, in your `encodeRestorableStateWithCoder`
    methods, read the key out of the Keychain and use it as the key for an encryption
    operation.^([15](footnote.html#fn97)) Take the resulting data and serialize it
    with the `NSCoder`’s `encodeObject` method. Finally, in the `decodeRestorableStateWithCoder`
    method, perform the same operations in reverse to restore the application’s state.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序安装时，生成一个加密密钥并通过`secItemAdd`将其存储在钥匙串中。然后，在`encodeRestorableStateWithCoder`方法中，从钥匙串中读取密钥，并将其作为加密操作的密钥。^([15](footnote.html#fn97))
    获取生成的数据并使用`NSCoder`的`encodeObject`方法进行序列化。最后，在`decodeRestorableStateWithCoder`方法中，执行相同的操作来恢复应用程序的状态。
- en: You can use the SecureNSCoder project^([16](footnote.html#fn98)) to help implement
    that functionality. SecureNSCoder can automatically generate a key for your application,
    store it in the Keychain, and use it to encode and decode your program state.
    For the rest of this section, I’ll walk you through a sample project that demonstrates
    how to use this tool in your own programs.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用SecureNSCoder项目^([16](footnote.html#fn98))来帮助实现该功能。SecureNSCoder可以为你的应用自动生成一个密钥，存储在钥匙串中，并用它来编码和解码你的程序状态。在接下来的部分中，我将带你通过一个示例项目，展示如何在你的程序中使用这个工具。
- en: First, include the *SecureArchiveDelegate* and *SimpleKeychainWrapper* files
    in your project. Then, include *SecureArchiverDelegate.h* in your view controller’s
    *.h* file, as shown in [Listing 10-21](ch10.html#ch10ex21).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将*SecureArchiveDelegate*和*SimpleKeychainWrapper*文件包含到你的项目中。然后，在你的视图控制器的*.h*文件中包含*SecureArchiverDelegate.h*，如[示例
    10-21](ch10.html#ch10ex21)所示。
- en: '[PRE26]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 10-21: A basic* ViewController.h'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 10-21：一个基础的* ViewController.h'
- en: Next, implement the `initWithCoder` method, as in [Listing 10-22](ch10.html#ch10ex22).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，按照[示例 10-22](ch10.html#ch10ex22)中的内容实现`initWithCoder`方法。
- en: '[PRE27]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 10-22:* `initWithCoder` *in* ViewController.m'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 10-22：`initWithCoder`* 在 ViewController.m 中'
- en: Then implement the `awakeFromNib` method shown in [Listing 10-23](ch10.html#ch10ex23).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然后实现[示例 10-23](ch10.html#ch10ex23)中显示的`awakeFromNib`方法。
- en: '[PRE28]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 10-23:* `awakeFromNib` *in ViewController.m*'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 10-23：`awakeFromNib`* 在 ViewController.m 中'
- en: Finally, implement the two state preservation methods in [Listing 10-24](ch10.html#ch10ex24).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，按照[示例 10-24](ch10.html#ch10ex24)中的内容实现两个状态保存方法。
- en: '[PRE29]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 10-24: Encode and decode methods in* ViewController.m'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 10-24：在* ViewController.m 中的编码与解码方法'
- en: 'You’ve seen how data can leak from applications on a device, but what about
    data that’s been backed up to iCloud? Well, if you’re dealing with sensitive data,
    there’s really only one technique I can recommend there: avoid storing it on iCloud
    entirely.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了数据如何从设备上的应用程序中泄漏，但备份到 iCloud 的数据怎么样？如果你处理的是敏感数据，实际上我只能推荐一个方法：完全避免将其存储在
    iCloud 上。
- en: '**Getting Off iCloud to Avoid Leaks**'
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**离开 iCloud 避免泄漏**'
- en: In recent versions of iOS, much of your application’s data can be synced to
    a user’s iCloud account, where it can be shared across devices. By default, only
    three of your application directories are safe from the clutches of iCloud.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在 iOS 的最新版本中，应用程序的大部分数据可以同步到用户的 iCloud 账户，并可以在多个设备之间共享。默认情况下，只有三个应用程序目录能够免受
    iCloud 的控制。
- en: • *AppName.app*
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: • *AppName.app*
- en: • *Library/Caches*
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: • *Library/Caches*
- en: • */tmp*
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: • */tmp*
- en: If you want any of your other files to remain only on the device, you’ll have
    to take responsibility for them yourself.^([17](footnote.html#fn99)) Set the `NSURLIsExcludedFromBackupKey`
    attribute on those files, using an `NSURL` as the path to the file, to prevent
    the file from backing up to iCloud, as in [Listing 10-25](ch10.html#ch10ex25).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望其他任何文件仅保留在设备上，你需要自行负责这些文件的管理。^([17](footnote.html#fn99)) 使用`NSURLIsExcludedFromBackupKey`属性来标记这些文件，并使用`NSURL`作为文件路径，以防止文件备份到
    iCloud，如[示例 10-25](ch10.html#ch10ex25)所示。
- en: '[PRE30]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 10-25: Setting file attributes to exclude a file from backup*'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 10-25：设置文件属性以排除文件备份*'
- en: You can set the `NSURLIsExcludedFromBackupKey` with the `setResourceValue NSURL`
    method, shown at ➊.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`setResourceValue NSURL`方法设置`NSURLIsExcludedFromBackupKey`，如➊所示。
- en: '**Closing Thoughts**'
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结束语**'
- en: Data leakage on mobile devices is a broad and ever-changing area that makes
    up a large percentage of issues found in mobile applications when subjected to
    security audits. Ideally, some of the things you’ve examined in this chapter will
    help you find useful bugs, as well as help you identify changes when newer versions
    of iOS are released. I’ll now move on to cover some basic C and memory corruption
    attacks, which are usually rarer on iOS but potentially much more dangerous.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 移动设备上的数据泄漏是一个广泛且不断变化的领域，构成了在移动应用进行安全审计时发现的大量问题。理想情况下，本章中你所检查的内容将帮助你发现有用的漏洞，并帮助你识别在
    iOS 更新版本发布时可能出现的变化。接下来，我将介绍一些基本的 C 语言和内存腐败攻击，这些攻击在 iOS 上通常较少见，但潜在的危害却大得多。
