- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 2 FLOW CONTROL AND TEXT PROCESSING
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 流程控制与文本处理
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: This chapter covers bash concepts that can make your scripts more intelligent.
    You’ll learn how to test conditions, use loops, consolidate code into functions,
    send commands to the background, and more. You’ll also learn some ways of customizing
    your bash environment for penetration testing.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了可以使脚本更智能的 Bash 概念。你将学习如何测试条件、使用循环、将代码整合为函数、将命令发送到后台等。你还将学习一些定制 Bash 环境的方法，适用于渗透测试。
- en: Test Operators
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试操作符
- en: Bash lets us selectively execute commands when certain conditions of interest
    are met. We can use *test operators* to craft a wide variety of conditions, such
    as whether one value equals another value, whether a file is of a certain type,
    or whether one value is greater than another. We often rely on such tests to determine
    whether to continue running a block of code, so being able to construct them is
    fundamental to bash programming.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Bash 让我们在满足某些特定条件时有选择地执行命令。我们可以使用 *测试操作符* 来构造各种条件，比如检查一个值是否等于另一个值，文件是否为某种类型，或者一个值是否大于另一个值。我们经常依赖这些测试来决定是否继续执行一段代码，因此构造这些测试是
    Bash 编程的基础。
- en: Bash has multiple kinds of test operators. *File test operators* allow us to
    perform tests against files on the filesystem, such as checking whether a file
    is executable or whether a certain directory exists. [Table 2-1](chapter2.xhtml#tab2-1)
    shows a short list of the available tests.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Bash 有多种类型的测试操作符。*文件测试操作符* 允许我们对文件系统中的文件进行测试，例如检查文件是否可执行或某个目录是否存在。[表 2-1](chapter2.xhtml#tab2-1)
    显示了可用测试的简短列表。
- en: 'Table 2-1: File Test Operators'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-1：文件测试操作符
- en: '| Operator | Description |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| 操作符 | 描述 |'
- en: '| --- | --- |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| -d | Checks whether the file is a directory |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| -d | 检查文件是否为目录 |'
- en: '| -r | Checks whether the file is readable |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| -r | 检查文件是否可读 |'
- en: '| -x | Checks whether the file is executable |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| -x | 检查文件是否可执行 |'
- en: '| -w | Checks whether the file is writable |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| -w | 检查文件是否可写 |'
- en: '| -f | Checks whether the file is a regular file |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| -f | 检查文件是否为常规文件 |'
- en: '| -s | Checks whether the file size is greater than zero |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| -s | 检查文件大小是否大于零 |'
- en: You can find the full list of file test operators at *[https://ss64.com/bash/test.html](https://ss64.com/bash/test.html)*
    or by running the man test command.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *[https://ss64.com/bash/test.html](https://ss64.com/bash/test.html)* 找到完整的文件测试操作符列表，或者通过运行
    `man test` 命令来查看。
- en: '*String comparison operators* allow us to perform tests related to strings,
    such as testing whether one string is equal to another. [Table 2-2](chapter2.xhtml#tab2-2)
    shows the string comparison operators.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*字符串比较操作符* 允许我们进行与字符串相关的测试，例如检查一个字符串是否等于另一个字符串。[表 2-2](chapter2.xhtml#tab2-2)
    显示了字符串比较操作符。'
- en: 'Table 2-2: String Comparison Operators'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-2：字符串比较操作符
- en: '| Operator | Description |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 操作符 | 描述 |'
- en: '| --- | --- |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| = | Checks whether a string is equal to another string |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: = | 检查一个字符串是否等于另一个字符串 |
- en: '| == | Synonym of = when used within [[]] constructs |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| == | 在 [[]] 构造中，= 的同义词 |'
- en: '| != | Checks whether a string is not equal to another string |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| != | 检查一个字符串是否不等于另一个字符串 |'
- en: '| < | Checks whether a string comes before another string (in alphabetical
    order) |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| < | 检查一个字符串是否在另一个字符串之前（按字母顺序） |'
- en: '| > | Checks whether a string comes after another string (in alphabetical order)
    |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| > | 检查一个字符串是否在另一个字符串之后（按字母顺序） |'
- en: '| -z | Checks whether a string is null |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| -z | 检查字符串是否为空 |'
- en: '| -n | Checks whether a string is not null |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| -n | 检查字符串是否非空 |'
- en: '*Integer comparison operators* allow us to perform checks on integers, such
    as whether an integer is less than or greater than another. [Table 2-3](chapter2.xhtml#tab2-3)
    shows the available operators.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*整数比较操作符* 允许我们对整数进行检查，例如检查一个整数是否小于或大于另一个整数。[表 2-3](chapter2.xhtml#tab2-3) 显示了可用的操作符。'
- en: 'Table 2-3: Integer Comparison Operators'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-3：整数比较操作符
- en: '| Operator | Description |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 操作符 | 描述 |'
- en: '| --- | --- |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| -eq | Checks whether a number is equal to another number |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| -eq | 检查一个数字是否等于另一个数字 |'
- en: '| -ne | Checks whether a number is not equal to another number |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| -ne | 检查一个数字是否不等于另一个数字 |'
- en: '| -ge | Checks whether a number is greater than or equal to another number
    |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| -ge | 检查一个数字是否大于或等于另一个数字 |'
- en: '| -gt | Checks whether a number is greater than another number |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| -gt | 检查一个数字是否大于另一个数字 |'
- en: '| -lt | Checks whether a number is less than another number |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| -lt | 检查一个数字是否小于另一个数字 |'
- en: '| -le | Checks whether a number is less than or equal to another number |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| -le | 检查一个数是否小于或等于另一个数 |'
- en: Let’s use these operators in flow-control mechanisms to decide what code to
    run next.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在流控制机制中使用这些操作符，以决定接下来要运行哪些代码。
- en: if Conditions
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: if条件
- en: In bash, we can use an if condition to execute code only when a certain condition
    is met. [Listing 2-1](chapter2.xhtml#Lis2-1) shows its syntax.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在bash中，我们可以使用if条件来仅在满足特定条件时执行代码。[清单 2-1](chapter2.xhtml#Lis2-1)展示了它的语法。
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 2-1: The structure of an if statement'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 2-1：if语句的结构
- en: We start with the if keyword, followed by a test condition between double square
    brackets ([[]]). We then use the ; character to separate the if keyword from the
    then keyword, which allows us to introduce a block of code that runs only if the
    condition is met.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以if关键字开始，接着是在双方括号（[[]]）之间的测试条件。然后使用;字符将if关键字与then关键字分开，这允许我们引入一个仅在条件满足时运行的代码块。
- en: Next, we use the else keyword to introduce a fallback code block that runs if
    the condition is not met. Note that else is optional, and you may not always need
    it. Finally, we close the if condition with the fi keyword (which is if inversed).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用else关键字引入一个回退代码块，当条件不满足时运行。请注意，else是可选的，有时候你可能不需要它。最后，我们使用fi关键字（这是if的反义词）来关闭if条件。
- en: NOTE
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*In some operating systems, such as those often used in containers, the default
    shell might not necessarily be bash. To account for these cases, you may want
    to use single square brackets (*[...]*) rather than double to enclose your condition.
    This use of single brackets meets the Portable Operating System Interface standard
    and should work on almost any Unix derivative, including Linux.*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*在某些操作系统中（如经常用于容器的操作系统），默认shell可能不一定是bash。为了考虑这些情况，您可能希望使用单方括号（* [...] *）而不是双方括号来包含您的条件。单方括号的使用符合可移植操作系统接口标准，并且几乎可以在包括Linux在内的任何Unix衍生系统上运行。*'
- en: Let’s see an if condition in practice. [Listing 2-2](chapter2.xhtml#Lis2-2)
    uses an if condition to test whether a file exists and, if not, creates it.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看if条件在实践中的运用。[清单 2-2](chapter2.xhtml#Lis2-2)使用if条件来测试文件是否存在，如果不存在则创建它。
- en: test_if_file _exists.sh
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: test_if_file _exists.sh
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 2-2: An if condition to test for the existence of a file'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 2-2：用于检查文件是否存在的if条件
- en: We first create a variable named FILENAME containing the name of the file we
    need. This saves us from having to repeat the filename in the code. We then introduce
    the if statement, which includes a condition that uses the -f file test operator
    to test for the existence of the file. If this condition is true, we use echo
    to print to the screen a message explaining that the file already exists and then
    use the status code 1 (failure) to exit the program. In the else block, which
    will execute only if the file does not exist, we create the file by using the
    touch command.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个名为FILENAME的变量，其中包含我们需要的文件名。这样可以避免在代码中重复文件名。然后，我们引入if语句，其中包含使用-f文件测试操作符来测试文件是否存在的条件。如果这个条件为真，则使用echo打印一条消息到屏幕上，解释文件已经存在，并使用状态码1（失败）退出程序。在else块中，只有当文件不存在时才会执行，我们使用touch命令创建文件。
- en: NOTE
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*You can download this chapter’s scripts from* [https://github.com/dolevf/Black-Hat-Bash/blob/master/ch02](https://github.com/dolevf/Black-Hat-Bash/blob/master/ch02).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以从* [https://github.com/dolevf/Black-Hat-Bash/blob/master/ch02](https://github.com/dolevf/Black-Hat-Bash/blob/master/ch02)
    *下载本章的脚本。*'
- en: Save the file and execute it. You should see the *flow_control_with_if.txt*
    file in your current directory when you run ls.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件并执行它。当您运行ls时，您应该在当前目录中看到*flow_control_with_if.txt*文件。
- en: '[Listing 2-3](chapter2.xhtml#Lis2-3) shows a different way of achieving the
    same outcome: it uses the NOT operator (!) to check whether a directory *doesn’t*
    exist and, if it doesn’t, creates it. This example has fewer lines of code and
    eliminates the need for an else block altogether.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 2-3](chapter2.xhtml#Lis2-3)展示了实现相同结果的另一种方法：它使用非运算符（!）来检查目录*不存在*，如果不存在则创建它。这个示例代码行数更少，并且完全消除了else块的需要。'
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 2-3: Using a negative check to test file existence'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 2-3：使用否定检查来测试文件是否存在
- en: Let’s explore if conditions that use some of the other kinds of test operators
    we’ve covered. [Listing 2-4](chapter2.xhtml#Lis2-4) shows a string comparison
    test. It tests whether two variables are equal by performing string comparison
    with the equal-to operator (==).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨使用我们已经涵盖的其他类型测试操作符的if条件。[清单 2-4](chapter2.xhtml#Lis2-4)展示了一个字符串比较测试。它使用等于运算符（==）进行字符串比较，测试两个变量是否相等。
- en: string _comparison.sh
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: string _comparison.sh
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 2-4: Comparing two string variables'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2-4](chapter2.xhtml#Lis2-4)：比较两个字符串变量'
- en: The script will compare the two variables, both of which have the value nostarch,
    and print They are equal! by using the echo command.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本将比较两个值都为 nostarch 的变量，并使用echo命令打印出 They are equal!。
- en: Next is an integer comparison test, which takes two integers and checks which
    one is the larger number ([Listing 2-5](chapter2.xhtml#Lis2-5)).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个整数比较测试，它接受两个整数并检查哪一个是较大的数（[图2-5](chapter2.xhtml#Lis2-5)）。
- en: integer _comparison.sh
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: integer _comparison.sh
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 2-5: Comparing integers'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2-5](chapter2.xhtml#Lis2-5)：比较整数'
- en: We create two variables, VARIABLE_ONE and VARIABLE_TWO, and assign them values
    of 10 and 20, respectively. We then use the -gt operator to compare the two values
    and print the result based on an integer comparison.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个变量，VARIABLE_ONE 和 VARIABLE_TWO，并分别赋值为10和20。然后我们使用 -gt 运算符比较这两个值，并基于整数比较打印结果。
- en: Linking Conditions
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 链接条件
- en: So far, we’ve used if to check whether a single condition is met. But as with
    most programming languages, we can also use the OR (||) and AND (&&) operators
    to check for multiple conditions at once.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用if来检查单个条件是否满足。但与大多数编程语言一样，我们也可以使用OR（||）和AND（&&）运算符同时检查多个条件。
- en: For example, what if we want to check that a file exists and that its size is
    greater than zero? [Listing 2-6](chapter2.xhtml#Lis2-6) does so.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想要检查文件是否存在并且其大小大于零，[图2-6](chapter2.xhtml#Lis2-6) 就是这样做的。
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 2-6: Using AND to chain two file test conditions'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2-6](chapter2.xhtml#Lis2-6)：使用AND链接两个文件测试条件'
- en: This code writes content to a file, then checks whether that file exists and
    whether its size is greater than zero. Both conditions have to be met in order
    for the echo command to be executed. If either returns false, nothing will happen.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码向文件写入内容，然后检查该文件是否存在以及其大小是否大于零。只有在这两个条件均满足时，echo命令才会执行。如果任一条件返回false，则什么也不会发生。
- en: To demonstrate an OR condition, [Listing 2-7](chapter2.xhtml#Lis2-7) checks
    whether a variable is either a file or a directory.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要演示OR条件，[图2-7](chapter2.xhtml#Lis2-7) 检查一个变量是文件还是目录。
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 2-7: Chaining two file test conditions by using OR'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2-7](chapter2.xhtml#Lis2-7)：使用OR链接两个文件测试条件'
- en: This code first creates a directory, then uses an if condition with the OR (||)
    operator to check whether the variable is a file (-f) or a directory (-d). The
    second condition should evaluate to true, and the echo command should execute.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码首先创建一个目录，然后使用OR（||）运算符的if条件检查变量是文件（-f）还是目录（-d）。第二个条件应该评估为true，并且echo命令应该执行。
- en: Testing Command Success
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试命令成功
- en: We can even test the exit code of commands to determine whether they were successful
    ([Listing 2-8](chapter2.xhtml#Lis2-8)).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以测试命令的退出代码，以确定它们是否成功（[图2-8](chapter2.xhtml#Lis2-8)）。
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 2-8: Executing commands based on exit code values'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2-8](chapter2.xhtml#Lis2-8)：基于退出代码值执行命令'
- en: 'You’ll often find yourself using this technique in bash, as commands aren’t
    guaranteed to succeed. Failures could happen for reasons such as these:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 bash 中，你经常会使用这种技术，因为命令并不保证成功。失败可能是以下原因之一：
- en: A lack of the necessary permissions when creating resources
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建资源时缺少必要的权限
- en: An attempt to execute a command that is not available on the operating system
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试执行操作系统上不可用的命令
- en: The disk being full when downloading a file
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载文件时磁盘空间已满
- en: The network being down while executing network utilities
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在执行网络工具时网络断开
- en: 'To see how this technique works, execute the following in your terminal:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这种技术的工作原理，请在终端中执行以下操作：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We attempt to create a file. Because the file creation succeeds, we print a
    message to indicate this.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试创建一个文件。因为文件创建成功，我们打印一条消息以指示这一点。
- en: Checking Subsequent Conditions
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查后续条件
- en: If the first if condition fails, you can check for other conditions by using
    the elif keyword (short for *else if*). To show how this works, let’s write a
    program that checks the arguments passed to it on the command line. [Listing 2-9](chapter2.xhtml#Lis2-9)
    will output a message clarifying whether the argument is a file or a directory.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个if条件失败，你可以使用elif关键字（*else if* 的简写）检查其他条件。为了展示其工作原理，让我们编写一个程序来检查传递给它的命令行参数。
    [图2-9](chapter2.xhtml#Lis2-9) 将输出一个消息，说明参数是文件还是目录。
- en: if_elif.sh
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: if_elif.sh
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 2-9: Using if and elif statements'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2-9](chapter2.xhtml#Lis2-9)：使用if和elif语句'
- en: We begin with an if statement that checks whether the variable USER_INPUT is
    null ❶. This allows us to exit the script early by using exit 1 if we receive
    no command line arguments from the user. We then begin a second if condition that
    uses the file test operator to check whether the input is a file ❷. Below this
    condition, we use elif to test whether the argument is a directory ❸. This condition
    won’t be tested unless the file test fails. If neither of these conditions is
    true, the script responds that the argument is neither a file nor a directory
    ❹.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Functions* help us reuse blocks of code so we can avoid repeating them. They
    allow us to run multiple commands and other bash code simultaneously by simply
    entering the function’s name. To define a new function, enter a name for it, followed
    by parentheses. Then place the code you would like the function to run within
    curly brackets ([Listing 2-10](chapter2.xhtml#Lis2-10)).'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 2-10: Defining a function'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we define a function called say_name() that executes a single echo command.
    To call a function, simply enter its name:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If the function is not called, the commands within it won’t run.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Returning Values
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like commands and their exit statuses, functions can return values by using
    the return keyword. If there is no return statement, the function will return
    the exit code of the last command it ran. For example, the function in [Listing
    2-11](chapter2.xhtml#Lis2-11) returns a different value based on whether the current
    user is root.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: check_root _function.sh
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 2-11: An if condition to test whether a function returned true or false'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: We define the check_if_root() function ❶. Within this function, we use an if
    condition with an integer comparison test ❷, accessing the environment variable
    EUID to get the effective running user’s ID and checking whether it equals 0\.
    If so, the user is root, and the function returns 0; if not, it returns 1\. Next,
    we call the check_if_root function and check if it returned 0, which means the
    user is root. Otherwise, we print that the user is not root.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Bash scripts that perform privileged actions often check whether the user is
    root before attempting to install software, create users, delete groups, and so
    on. Attempting to perform privileged actions on Linux without the necessary privileges
    will result in errors, so this check helps handle these cases.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Accepting Arguments
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 1](chapter1.xhtml), we covered the passing of arguments to commands
    on the command line. Functions can also take arguments by using the same syntax.
    For example, the function in [Listing 2-12](chapter2.xhtml#Lis2-12) prints the
    first three arguments it receives.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 2-12: A function with arguments'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'To call a function with arguments, enter its name and the arguments separated
    by spaces ❶. Save this script as *function_with_args.sh* and run it:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You should see output similar to that shown here.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Loops and Loop Controls
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like many programming languages, bash lets you repeat chunks of code by using
    *loops*. Loops can be particularly useful in your penetration-testing adventures
    because they can help you accomplish tasks such as the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 和许多编程语言一样，bash 通过使用 *循环* 让你重复执行代码块。循环在你的渗透测试冒险中尤其有用，因为它们可以帮助你完成如下任务：
- en: Continuously checking whether an IP address is online after a reboot until the
    IP address is responsive
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在重启后持续检查某个 IP 地址是否在线，直到该 IP 地址响应
- en: Iterating through a list of hostnames (for example, to run a specific exploit
    against each of them or determine whether a firewall is protecting them)
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代主机名列表（例如，针对每个主机运行特定的漏洞攻击或判断是否有防火墙在保护它们）
- en: Testing for a certain condition and then running a loop when it is met (for
    example, checking whether a host is online and, if so, performing a brute-force
    attack against it)
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试某个条件并在满足时运行循环（例如，检查某个主机是否在线，如果在线，则对其进行暴力破解攻击）
- en: The following sections introduce you to the three kinds of loops in bash (while,
    until, and for) as well as the break and continue statements for working with
    loops.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将介绍 bash 中的三种循环（while、until 和 for），以及用于处理循环的 break 和 continue 语句。
- en: while
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: while
- en: In bash, while loops allow you to run a code block until a test returns a successful
    exit status code. You might use them in penetration testing to continuously perform
    a port scan on a network and pick up any new hosts that join the network, for
    example.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在 bash 中，while 循环允许你运行一个代码块，直到测试返回成功的退出状态代码。例如，你可能会在渗透测试中使用它们，持续对网络进行端口扫描，并捕捉加入网络的任何新主机。
- en: '[Listing 2-13](chapter2.xhtml#Lis2-13) shows the syntax of a while loop.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 2-13](chapter2.xhtml#Lis2-13) 显示了 while 循环的语法。'
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 2-13: A while loop'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 2-13：一个 while 循环
- en: This loop starts with the keyword while, followed by an expression that describes
    the condition. We then surround the code to be executed with the do and done keywords,
    which define the start and end of the code block.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 该循环以 while 关键字开始，后面跟着描述条件的表达式。然后，我们用 do 和 done 关键字将要执行的代码包围起来，这些关键字定义了代码块的开始和结束。
- en: You can use while loops to run a chunk of code infinitely by using true as the
    condition; because true always returns a successful exit code, the code will always
    run. Let’s use a while loop to repeatedly print a command to the screen. Save
    [Listing 2-14](chapter2.xhtml#Lis2-14) to a file named *basic_while.sh* and run
    it.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 while 循环通过将 true 作为条件来无限次运行一段代码；因为 true 总是返回成功的退出代码，所以代码将一直运行。让我们使用 while
    循环重复地将命令打印到屏幕上。将 [清单 2-14](chapter2.xhtml#Lis2-14) 保存为名为 *basic_while.sh* 的文件并运行它。
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 2-14: Repeatedly running a command at two-second intervals'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 2-14：以两秒间隔重复运行命令
- en: 'You should see the following output:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Next, let’s write a more sophisticated while loop that runs until it finds a
    specific file on the filesystem ([Listing 2-15](chapter2.xhtml#Lis2-15)). Use
    CTRL-C to stop the code from executing at any point.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们编写一个更复杂的 while 循环，直到它在文件系统中找到特定文件为止（[清单 2-15](chapter2.xhtml#Lis2-15)）。使用
    CTRL-C 随时停止代码执行。
- en: while_loop.sh
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: while_loop.sh
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 2-15: File monitoring'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 2-15：文件监控
- en: 'At ❶, we define a variable representing the name of the file for which the
    while loop ❷ checks, using a file test operator. The loop won’t exit until the
    condition is satisfied. Once the file is available, the loop will stop, and the
    script will continue to the echo command ❸. Save this file as *while_loop.sh*
    and run it:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ❶ 处，我们定义了一个变量，表示 while 循环 ❷ 检查的文件名，并使用文件测试操作符。直到条件满足，循环才会退出。一旦文件可用，循环将停止，脚本将继续执行
    echo 命令 ❸。将此文件保存为 *while_loop.sh* 并运行：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'While the script is running, open a second terminal in the same directory as
    the script and create the *stoploop* file:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本运行时，在与脚本相同的目录中打开第二个终端，并创建 *stoploop* 文件：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once you’ve done so, you should see the script break out of the loop and print
    the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你应该看到脚本跳出循环并打印以下内容：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We can use while loops to monitor for filesystem events, such as file creations
    or deletions, or when a process starts. This may come in handy if an application
    is suffering from a vulnerability we can only temporarily abuse. For example,
    consider an application that runs daily at a particular hour and checks whether
    the file */tmp/update.sh* exists; if it does, the application executes it as the
    *root* user. Using a while loop, we can monitor when that application has started
    and then create the file just in time so our commands are executed by that application.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 while 循环来监视文件系统事件，例如文件创建或删除，或者进程启动时。这在应用程序存在只能暂时利用的漏洞时非常有用。例如，考虑一个每天在特定时间运行的应用程序，它检查文件*/tmp/update.sh*是否存在；如果存在，应用程序将以*root*用户身份执行该文件。使用
    while 循环，我们可以监视该应用程序的启动，然后及时创建该文件，以便我们的命令能被该应用程序执行。
- en: until
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: until
- en: Whereas while runs so long as the condition succeeds, until runs so long as
    it fails. [Listing 2-16](chapter2.xhtml#Lis2-16) shows the until loop syntax.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 而 while 在条件成功时持续运行，until 在条件失败时持续运行。[清单 2-16](chapter2.xhtml#Lis2-16)展示了 until
    循环的语法。
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 2-16: An until loop'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 2-16：一个 until 循环
- en: '[Listing 2-17](chapter2.xhtml#Lis2-17) uses until to run some commands until
    a file’s size is greater than zero (meaning it is not empty).'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 2-17](chapter2.xhtml#Lis2-17)使用 until 来运行一些命令，直到文件大小大于零（意味着它不再为空）。'
- en: until_loop.sh
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: until_loop.sh
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 2-17: Checking a file’s size'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 2-17：检查文件的大小
- en: 'We first create an empty file, then begin a loop that runs until the file is
    no longer empty. Within the loop, we print messages to the terminal. Save this
    file as *until_loop.sh* and run it:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个空文件，然后开始一个循环，直到文件不再为空。在循环内部，我们将消息打印到终端。将此文件保存为*until_loop.sh*并运行：
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'At this point, the script has created the file *output.txt*, but it’s an empty
    file. We can check this by using the du (disk usage) command:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，脚本已经创建了文件*output.txt*，但它是一个空文件。我们可以使用 du（磁盘使用情况）命令来检查这一点：
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Open another terminal and navigate to the location at which your script is
    saved, then append some content to the file so its size is no longer zero:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 打开另一个终端并导航到脚本保存的位置，然后向文件追加一些内容，使其大小不再为零：
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The script should exit the loop, and you should see it print the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本应退出循环，您应该看到它打印以下内容：
- en: '[PRE27]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: for
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: for
- en: The for loop iterates over a *sequence*, such as a list of filenames or variables,
    or even a group of values generated by running a command. Inside the for loop,
    we define a block of commands that are run against each value in the list, and
    each value in the list is assigned to a variable name we define.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: for 循环会遍历一个*序列*，例如文件名或变量的列表，甚至是通过运行命令生成的一组值。在 for 循环内部，我们定义一组命令，这些命令会对列表中的每个值执行，每个值会被赋给我们定义的变量名。
- en: '[Listing 2-18](chapter2.xhtml#Lis2-18) shows the syntax of a for loop.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 2-18](chapter2.xhtml#Lis2-18)展示了 for 循环的语法。'
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 2-18: A for loop'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 2-18：一个 for 循环
- en: A simple way to use a for loop is to execute the same command multiple times.
    For example, [Listing 2-19](chapter2.xhtml#Lis2-19) prints the numbers 1 through
    10.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for 循环的一种简单方法是多次执行相同的命令。例如，[清单 2-19](chapter2.xhtml#Lis2-19)打印从 1 到 10 的数字。
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 2-19: Counting to 10 in a for loop'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 2-19：在 for 循环中计数到 10
- en: 'Save and run this script. You should see the following output:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 保存并运行此脚本。您应该看到以下输出：
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: A more practical example might use a for loop to run commands against a bunch
    of IP addresses passed on the command line. [Listing 2-20](chapter2.xhtml#Lis2-20)
    retrieves all arguments passed to the script, then iterates through them and prints
    a message for each.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更实际的例子可能是使用 for 循环对传递到命令行的一组 IP 地址运行命令。[清单 2-20](chapter2.xhtml#Lis2-20) 获取传递给脚本的所有参数，然后遍历它们并为每个参数打印一条消息。
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Listing 2-20: Iterating through command line arguments'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 2-20：遍历命令行参数
- en: 'Save this script as *for_loop_arguments.sh* and run it as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 将此脚本保存为*for_loop_arguments.sh*并按以下方式运行：
- en: '[PRE32]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We can even run a for loop on the output of commands such as ls. In [Listing
    2-21](chapter2.xhtml#Lis2-21), we print the names of all files in the current
    working directory.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以对命令的输出运行 for 循环，例如 ls。在[清单 2-21](chapter2.xhtml#Lis2-21)中，我们打印当前工作目录中所有文件的名称。
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Listing 2-21: Iterating through files in the current directory'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 2-21：遍历当前目录中的文件
- en: We use a for loop to iterate over the output of the ls . command, which lists
    the files in the current directory. Each file will be assigned to the file variable
    as part of the for loop, so we can then use echo to print its name. This technique
    would be useful, for example, if we wanted to perform an upload of all files in
    the directory or even rename them in bulk.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 for 循环迭代 ls . 命令的输出，后者列出当前目录中的文件。每个文件会作为 for 循环的一部分被赋值给 file 变量，因此我们可以使用
    echo 来打印它的名称。例如，如果我们想对目录中的所有文件进行批量上传或重命名，这种技术将会很有用。
- en: break and continue
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: break 和 continue
- en: Loops can run forever or until a condition is met. But we can also exit a loop
    at any point by using the break keyword. This keyword provides an alternative
    to the exit command, which would cause the entire script, not just the loop, to
    exit. Using break, we can leave the loop and advance to the next code block ([Listing
    2-22](chapter2.xhtml#Lis2-22)).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 循环可以无限运行，或者直到满足某个条件为止。但我们也可以通过使用 break 关键字在任何时刻退出循环。这个关键字提供了一种替代 exit 命令的方式，后者会导致整个脚本退出，而不仅仅是循环。使用
    break，我们可以离开循环并进入下一个代码块（[Listing 2-22](chapter2.xhtml#Lis2-22)）。
- en: '[PRE34]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 2-22: Breaking from a loop'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 2-22：从循环中跳出
- en: In this case, the last echo command will be executed.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，最后的 echo 命令将被执行。
- en: 'The continue statement is used to jump to the next iteration of a loop. We
    can use it to skip a certain value in a sequence. To illustrate this, let’s create
    three empty files so we can iterate through them:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: continue 语句用于跳转到循环的下一次迭代。我们可以用它跳过序列中的某个值。为了说明这一点，下面我们创建三个空文件，以便我们能对它们进行迭代：
- en: '[PRE35]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Next, our for loop will write content to each file, excluding the first one,
    *example_file1*, which the loop will leave empty ([Listing 2-23](chapter2.xhtml#Lis2-23)).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们的 for 循环将向每个文件写入内容，跳过第一个文件 *example_file1*，这个文件会被留空（[Listing 2-23](chapter2.xhtml#Lis2-23)）。
- en: '[PRE36]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Listing 2-23: Skipping an element in a for loop'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 2-23：在 for 循环中跳过元素
- en: We start a for loop with the example_file* glob, which will expand to match
    the names of all files starting with *example_file* in the directory where the
    script runs ❶. As a result, the loop should iterate over all three files we created
    earlier. Within the loop, we use string comparison to check whether the filename
    is equal to *example_file1* because we want to skip this file and not make any
    changes to it. If the condition is met, we use the continue statement ❷ to proceed
    to the next iteration, leaving the file unmodified. Later in the loop, we use
    the echo command with the environment variable ${RANDOM} to generate a random
    number and write it into the file.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 example_file* 通配符开始一个 for 循环，它将扩展为匹配脚本运行的目录中所有以 *example_file* 开头的文件 ❶。因此，循环应该会遍历我们之前创建的所有三个文件。在循环内，我们使用字符串比较来检查文件名是否等于
    *example_file1*，因为我们想跳过这个文件，不对它进行任何修改。如果条件成立，我们使用 continue 语句 ❷ 继续到下一次迭代，保持该文件不变。然后，在循环的后续部分，我们使用
    echo 命令和环境变量 ${RANDOM} 生成一个随机数并将其写入文件。
- en: 'Save this script as *for_loop_continue.sh* and execute it in the same directory
    as the three files:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个脚本保存为 *for_loop_continue.sh*，并在与这三个文件相同的目录下执行：
- en: '[PRE37]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If you examine the files, you should see that the first file is empty, while
    the other two contain a random number as a result of the script echoing the value
    of the ${RANDOM} environment variable into them.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查这些文件，你应该看到第一个文件是空的，而其他两个文件包含一个随机数，这是因为脚本将 ${RANDOM} 环境变量的值回显到它们中。
- en: case Statements
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: case 语句
- en: In bash, case statements allow you to test multiple conditions in a cleaner
    way by using more readable syntax. Often, they help you avoid many if conditions,
    which can become harder to read as they grow in size.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在 bash 中，case 语句允许你以更简洁的方式测试多个条件，通过使用更易读的语法。通常，它们帮助你避免使用许多 if 语句，这些语句随着代码量的增加，可能变得更难阅读。
- en: '[Listing 2-24](chapter2.xhtml#Lis2-24) shows the case statement syntax.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 2-24](chapter2.xhtml#Lis2-24) 展示了 case 语句的语法。'
- en: '[PRE38]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Listing 2-24: A case statement'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 2-24：一个 case 语句
- en: A case statement starts with the keyword case followed by an expression, such
    as a variable you want to match a pattern against. PATTERN1 and PATTERN2 in this
    example represent a pattern case (such as a regular expression, a string, or an
    integer) that you want to compare to the expression. To close a case statement,
    you use the keyword esac (case inverted).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: case 语句以关键字 case 开头，后跟一个表达式，比如你希望匹配模式的变量。此示例中的 PATTERN1 和 PATTERN2 代表你希望与表达式进行比较的模式（例如正则表达式、字符串或整数）。要结束一个
    case 语句，使用关键字 esac（case 的反转）。
- en: Let’s take a look at an example case statement that checks whether an IP address
    is present in a specific private network ([Listing 2-25](chapter2.xhtml#Lis2-25)).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个示例 case 语句，该语句检查 IP 地址是否存在于特定的私有网络中（[列表 2-25](chapter2.xhtml#Lis2-25)）。
- en: case_ip_address _check.sh
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: case_ip_address_check.sh
- en: '[PRE39]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Listing 2-25: Checking an IP address and determining its network'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-25：检查 IP 地址并确定其网络
- en: We define a variable that expects one command line argument to be passed (${1})
    and saves it to the IP_ADDRESS variable. We then use a pattern to check whether
    the IP_ADDRESS variable starts with 192.168. and a second pattern to check whether
    it starts with 10.0.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义一个变量，期望传入一个命令行参数（${1}），并将其保存到 IP_ADDRESS 变量中。然后使用一个模式检查 IP_ADDRESS 变量是否以
    192.168. 开头，第二个模式检查它是否以 10.0. 开头。
- en: We also define a default wildcard pattern using *, which returns a default message
    to the user if nothing else has matched.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了一个默认的通配符模式 *，如果没有其他模式匹配，它会向用户返回默认信息。
- en: 'Save this file as *case_ip_address_check.sh* and run it:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为 *case_ip_address_check.sh* 并运行：
- en: '[PRE40]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: A case statement can be used for a variety of use cases. For example, it can
    be used to run functions based on input the user has entered. Using case statements
    is a great way to handle the evaluation of multiple conditions without sacrificing
    the readability of the code.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: case 语句可用于各种应用场景。例如，它可以根据用户输入的内容运行不同的函数。使用 case 语句是一种很好的方法，可以在不牺牲代码可读性的情况下处理多个条件的评估。
- en: Text Processing and Parsing
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本处理与解析
- en: One of the most common things you’ll find yourself doing in bash is processing
    text. You can parse text on the command line by running one-off commands, or use
    a script to store parsed data in a variable that you can act on in some way. Both
    approaches are important to many scenarios.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在 bash 中，你最常做的事情之一就是处理文本。你可以通过运行一次性的命令来解析文本，或者使用脚本将解析后的数据存储在一个变量中，以便后续使用。这两种方法对于许多场景都很重要。
- en: To test the commands in this section on your own, download the sample logfile
    from *[https://github.com/dolevf/Black-Hat-Bash/blob/master/ch02/log.txt](https://github.com/dolevf/Black-Hat-Bash/blob/master/ch02/log.txt)*.
    This file is space-separated, and each segment represents a specific data type,
    such as the client’s source IP address, timestamp, HyperText Transfer Protocol
    (HTTP) method, HTTP path, HTTP User Agent field, HTTP status code, and more.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 若要自行测试本节中的命令，请从 *[https://github.com/dolevf/Black-Hat-Bash/blob/master/ch02/log.txt](https://github.com/dolevf/Black-Hat-Bash/blob/master/ch02/log.txt)*
    下载示例日志文件。此文件使用空格分隔，每个段落代表特定的数据类型，如客户端的源 IP 地址、时间戳、超文本传输协议（HTTP）方法、HTTP 路径、HTTP
    用户代理字段、HTTP 状态码等。
- en: Filtering with grep
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 grep 过滤
- en: The grep command is one of the most popular Linux commands out there today.
    We use grep to filter out information of interest from streams. At its most basic
    form, we can use it as shown in [Listing 2-26](chapter2.xhtml#Lis2-26).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: grep 命令是当前最流行的 Linux 命令之一。我们使用 grep 从数据流中过滤出感兴趣的信息。在最基本的形式中，我们可以像[列表 2-26](chapter2.xhtml#Lis2-26)中展示的那样使用它。
- en: '[PRE41]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Listing 2-26: Filtering for a specific string from a file'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-26：从文件中筛选特定字符串
- en: This grep command will read the file and extract any lines containing the IP
    address 35.237.4.214 from it.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 此 grep 命令将读取文件并提取包含 IP 地址 35.237.4.214 的所有行。
- en: 'We can even use grep for multiple patterns simultaneously. The following backslash
    pipe (\|) acts as an OR condition:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以同时使用 grep 来匹配多个模式。以下的反斜杠管道符号（\|）作为“或”条件：
- en: '[PRE42]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Alternatively, we could use multiple grep patterns with the -e argument to
    accomplish the same thing:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用多个 grep 模式与 -e 参数来完成相同的操作：
- en: '[PRE43]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'As you learned in [Chapter 1](chapter1.xhtml), we can use the pipe (|) command
    to provide one command’s output as the input to another. In the following example,
    we run the ps command and use grep to filter out a specific line. The ps command
    lists the processes on the system:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在[第 1 章](chapter1.xhtml)中学到的，我们可以使用管道（|）命令将一个命令的输出作为另一个命令的输入。在以下示例中，我们运行 ps
    命令并使用 grep 来筛选特定的行。ps 命令列出了系统中的进程：
- en: '[PRE44]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'By default, grep is case sensitive. We can make our search case insensitive
    by using the -i flag:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，grep 是区分大小写的。我们可以通过使用 -i 标志使搜索不区分大小写：
- en: '[PRE45]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can also use grep with the -v argument to exclude lines containing a certain
    pattern:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 grep 的 -v 参数来排除包含某个模式的行：
- en: '[PRE46]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To print only the matched pattern, and not the entire line at which the matched
    pattern was found, use -o:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 若只打印匹配的模式，而不打印整个包含该模式的行，请使用 -o：
- en: '[PRE47]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The command also supports regular expressions, anchoring, grouping, and much
    more. Use the man grep command to read more about its capabilities.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令还支持正则表达式、锚定、分组等功能。使用man grep命令可以了解更多关于它的功能。
- en: Filtering with awk
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用awk进行过滤
- en: 'The awk command is a data processing and extraction Swiss Army knife. You can
    use it to identify and return specific fields from a file. To see how awk works,
    take another close look at our logfile. What if we need to print just the IP addresses
    from this file? This is easy to do with awk:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: awk命令是一个数据处理和提取的瑞士军刀。你可以用它从文件中识别并返回特定的字段。要看看awk是如何工作的，可以再次仔细查看我们的日志文件。如果我们需要从文件中打印出所有IP地址呢？这可以通过awk轻松完成：
- en: '[PRE48]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The $1 represents the first field of every line in the file where the IP addresses
    are. By default, awk treats spaces or tabs as separators or delimiters.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: $1表示文件中每一行的第一个字段，其中包含IP地址。默认情况下，awk将空格或制表符视为分隔符或定界符。
- en: 'Using the same syntax, we can print additional fields, such as the timestamps.
    The following command filters the first three fields of every line in the file:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的语法，我们可以打印其他字段，比如时间戳。以下命令过滤文件中每一行的前三个字段：
- en: '[PRE49]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Using similar syntax, we can print the first and last field simultaneously.
    In this case, NF represents the last field:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类似的语法，我们可以同时打印第一个和最后一个字段。在这种情况下，NF表示最后一个字段：
- en: '[PRE50]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We can also change the default delimiter. For example, if we had a file separated
    by commas (that is, a CSV, or comma-separated values file), rather than by spaces
    or tabs, we could pass awk the -F flag to specify the type of delimiter:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以更改默认的分隔符。例如，如果我们有一个由逗号分隔的文件（即CSV文件，逗号分隔值文件），而不是由空格或制表符分隔，我们可以通过传递-F标志给awk来指定分隔符的类型：
- en: '[PRE51]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can even use awk to print the first 10 lines of a file. This emulates the
    behavior of the head Linux command; NR represents the total number of records
    and is built into awk:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以使用awk打印文件的前10行。这模仿了Linux命令head的行为；NR表示记录的总数，并且是awk内建的：
- en: '[PRE52]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'You’ll often find it useful to combine grep and awk. For example, you might
    want to first find the lines in a file containing the IP address 42.236.10.117
    and then print the HTTP paths requested by this IP:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现将grep和awk结合使用非常有用。例如，你可能想先找到文件中包含IP地址42.236.10.117的行，然后打印该IP请求的HTTP路径：
- en: '[PRE53]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The awk command is a superpowerful tool, and we encourage you to dig deeper
    into its capabilities by running man awk for more information.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: awk命令是一个功能强大的工具，我们鼓励你通过运行man awk进一步深入了解它的功能。
- en: Editing Streams with sed
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用sed编辑流
- en: The sed (stream editor) command takes actions on text. For example, it can replace
    the text in a file, modify the text in a command’s output, and even delete selected
    lines from files.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: sed（流编辑器）命令对文本执行操作。例如，它可以替换文件中的文本，修改命令输出中的文本，甚至删除文件中的特定行。
- en: 'Let’s use sed to replace any mentions of the word *Mozilla* with the word *Godzilla*
    in the *log.txt* file. We use its s (substitution) command and g (global) command
    to make the substitution across the whole file, rather than to just the first
    occurrence:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用sed将文件*log.txt*中任何提到*Mozilla*的地方替换为*Godzilla*。我们使用它的s（替换）命令和g（全局）命令，以便在整个文件中进行替换，而不仅仅是第一个出现的位置：
- en: '[PRE54]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This will output the modified version of the file but won’t change the original
    version. You can redirect the output to a new file to save your changes:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出文件的修改版本，但不会改变原始版本。你可以将输出重定向到一个新文件来保存更改：
- en: '[PRE55]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We could also use sed to remove any whitespace from the file with the / //
    syntax, which will replace whitespace with nothing, removing it from the output
    altogether:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用sed通过/ //语法删除文件中的任何空白字符，这将把空白字符替换为空值，完全从输出中去除它们：
- en: '[PRE56]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If you need to delete lines of a file, use the d command. In the following
    command, 1d deletes (d) the first line (1):'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要删除文件的行，可以使用d命令。在以下命令中，1d删除（d）第1行（1）：
- en: '[PRE57]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'To delete the last line of a file, use the dollar sign ($), which represents
    the last line, along with d:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除文件的最后一行，可以使用美元符号（$），它表示最后一行，配合d命令：
- en: '[PRE58]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'You can also delete multiple lines, such as lines 5 and 7:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以删除多行，比如第5行和第7行：
- en: '[PRE59]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Finally, you can print (p) specific line ranges, such as lines 2 through 15:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以打印（p）特定的行范围，比如第2行到第15行：
- en: '[PRE60]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'When you pass sed the -i argument, it will make the changes to the file itself
    rather than create a modified copy:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当你传递-i参数给sed时，它会直接修改文件本身，而不是创建一个修改过的副本：
- en: '[PRE61]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This rich utility can do a whole lot more. Use the man sed command to find additional
    ways to use sed.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这个强大的工具还可以做更多的事情。使用 `man sed` 命令可以找到更多使用 `sed` 的方法。
- en: Job Control
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作业控制
- en: As you become proficient in bash, you’ll start to build complex scripts that
    take an hour to complete or must run continuously. Not all scripts need to execute
    in the foreground, blocking execution of other commands. Instead, you may want
    to run certain scripts as background jobs, either because they take a while to
    complete or because their runtime output isn’t interesting and you care about
    only the end result.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当你逐渐精通 bash 时，你会开始编写需要一个小时完成的复杂脚本，或者需要持续运行的脚本。并非所有脚本都需要在前台执行并阻塞其他命令的执行。相反，你可能希望将某些脚本作为后台作业运行，无论是因为它们需要较长时间才能完成，还是因为它们的运行输出不重要，你只关心最终结果。
- en: Commands that you run in a terminal occupy that terminal until the command is
    finished. These commands are considered *foreground jobs*. In [Chapter 1](chapter1.xhtml),
    we used the ampersand character (&) to send a command to the background. This
    command then becomes a *background job* that allows us to unblock the execution
    of other commands.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 你在终端中运行的命令会占用该终端，直到命令执行完毕。这些命令被认为是 *前台作业*。在[第 1 章](chapter1.xhtml)中，我们使用了符号
    `&` 将命令发送到后台。这样，命令就变成了 *后台作业*，允许我们不阻塞其他命令的执行。
- en: Managing the Background and Foreground
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 后台与前台管理
- en: 'To practice working with background and foreground jobs, let’s run a command
    directly in the terminal and send it to the background:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 为了练习管理后台和前台作业，我们直接在终端运行一个命令并将其发送到后台：
- en: '[PRE62]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Notice that we can continue working on the terminal while this sleep command
    runs for 100 seconds. We can verify that the spawned process is running by using
    the ps command:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这个 `sleep` 命令运行 100 秒的过程中，我们仍然可以继续在终端上工作。我们可以使用 `ps` 命令验证这个已启动的进程是否在运行：
- en: '[PRE63]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now that this job is in the background, we can use the jobs command to see
    what jobs are currently running:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个作业已经在后台运行，我们可以使用 `jobs` 命令查看当前正在运行的作业：
- en: '[PRE64]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The output shows that the sleep command is in Running state and that its job
    ID is 1.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示 `sleep` 命令处于运行状态，且其作业 ID 为 1。
- en: 'We can migrate the job from the background to the foreground by issuing the
    fg command and the job ID:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过执行 `fg` 命令并指定作业 ID 将作业从后台迁移到前台：
- en: '[PRE65]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'At this point, the sleep command is occupying the terminal, since it’s running
    in the foreground. You can press CTRL-Z to suspend the process, which will produce
    the following output in the jobs table:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，`sleep` 命令正在占用终端，因为它在前台运行。你可以按下 CTRL-Z 来挂起该进程，这将在作业表中显示如下输出：
- en: '[PRE66]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'To send this job to the background again in a running state, use the bg command
    with the job ID:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 若要将该任务再次以运行状态发送到后台，使用 `bg` 命令并指定作业 ID：
- en: '[PRE67]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Here, we supply the job ID of 1.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们提供了作业 ID 为 1。
- en: Keeping Jobs Running After Logout
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 登出后保持作业运行
- en: Whether you send a job to the background or are running a job in the foreground,
    the process won’t survive if you close the terminal or log out. If you close the
    terminal, the process will receive a SIGHUP signal and terminate.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是将作业发送到后台，还是在前台运行作业，如果关闭终端或登出，进程都无法继续存活。如果关闭终端，进程将收到一个 SIGHUP 信号并终止。
- en: 'What if we want to keep running a script in the background even after we’ve
    logged out of the terminal window or closed it? To do so, we could start a script
    or command with the nohup (no hangup) command prepended:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望在退出终端窗口或关闭终端后仍然保持脚本在后台运行该怎么办？为了实现这一点，我们可以在脚本或命令前添加 `nohup`（无挂断）命令：
- en: '[PRE68]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The nohup command will create a file named *nohup.out* with standard output
    stream data. Make sure you delete this file if you don’t want it on the filesystem.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`nohup` 命令会创建一个名为 *nohup.out* 的文件，存储标准输出流数据。如果你不希望这个文件存在于文件系统中，请确保删除它。'
- en: There are additional ways to run background scripts, such as by plugging into
    system and service managers like *systemd*. These managers provide additional
    features, such as monitoring that the process is running, restarting it if it
    isn’t, and capturing failures. We encourage you to read more about systemd at
    *[https://man7.org/linux/man-pages/man1/init.1.html](https://man7.org/linux/man-pages/man1/init.1.html)*
    if you have such use cases.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他方法可以运行后台脚本，比如通过接入系统和服务管理器，如 *systemd*。这些管理器提供了额外的功能，比如监控进程是否在运行，如果进程停止则重新启动，并捕获故障。如果你有这样的使用场景，我们建议你阅读有关
    systemd 的更多资料，地址是 *[https://man7.org/linux/man-pages/man1/init.1.html](https://man7.org/linux/man-pages/man1/init.1.html)*。
- en: Bash Customizations for Penetration Testers
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渗透测试者的 Bash 自定义
- en: As penetration testers, we often follow standard workflows for all ethical hacking
    engagements, whether they are consulting work, bug bounty hunting, or red teaming.
    We can optimize some of this work with a few bash tips and tricks.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 作为渗透测试员，我们通常会遵循所有道德黑客参与的标准工作流程，无论是咨询工作、漏洞赏金狩猎，还是红队演练。我们可以通过一些 bash 技巧和窍门来优化这些工作。
- en: Placing Scripts in Searchable Paths
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将脚本放入可搜索路径
- en: Bash searches for programs within directories defined by the PATH environment
    variable. Commands such as ls are always available to you because system and user
    binaries are located in directories that are part of the PATH.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: Bash 在由 PATH 环境变量定义的目录中搜索程序。像 ls 这样的命令始终可用，因为系统和用户的二进制文件位于 PATH 中的一些目录下。
- en: 'To see your PATH, run this command:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看你的 PATH，运行以下命令：
- en: '[PRE69]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The output might look different, depending on your operating system.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 输出可能会有所不同，具体取决于你的操作系统。
- en: 'When you write a bash script, place it in a directory such as */usr/local/bin*,
    which, as you can see, is part of the PATH. If you don’t do this, you have a few
    other options available:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写 bash 脚本时，可以将其放入如*/usr/local/bin* 这样的目录中，正如你所看到的，它是 PATH 的一部分。如果你不这样做，还有其他几种选择：
- en: Call the script directly, using the full path.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用完整路径直接调用脚本。
- en: Change the directory to the one in which your script lives and execute it from
    there.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将目录切换到脚本所在的目录，然后从那里执行它。
- en: Use aliases (shown in the next section).
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用别名（在下一部分展示）。
- en: Add paths to the PATH environment variable.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将路径添加到 PATH 环境变量中。
- en: The benefit of placing the script in a searchable path is that you can simply
    call it by its name. You don’t have to provide the full path or have the terminal
    be in the same directory.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 将脚本放入可搜索路径的好处是，你可以仅通过命令名来调用它。你不需要提供完整路径，或者让终端位于同一目录中。
- en: Shortening Commands with Aliases
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缩短命令与别名
- en: When you find yourself frequently using a long Linux command, you can use an
    *alias* to map the command to a shorter custom name that will save you time when
    you need to run it.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 当你经常使用一个较长的 Linux 命令时，可以使用*别名*将命令映射为一个较短的自定义名称，这样在需要运行时就能节省时间。
- en: 'For example, imagine that you often use Nmap (discussed in [Chapter 4](chapter4.xhtml))
    with special parameters to scan for all 65,535 ports on a given IP address:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你经常使用 Nmap（在[第4章](chapter4.xhtml)中讨论）带有特殊参数来扫描给定 IP 地址上的所有 65,535 个端口：
- en: '[PRE70]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This command is quite hard to remember. With aliases, we can make it more accessible
    on the command line or to our scripts. Here, we assign the command to the alias
    quicknmap:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令相当难记。使用别名后，我们可以使它在命令行或脚本中更容易访问。在这里，我们将命令分配给别名 quicknmap：
- en: '[PRE71]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now we can run the aliased command by using the name of the alias:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过使用别名的名称来运行别名命令：
- en: '[PRE72]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'You can even assign an alias to your own scripts:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以为自己的脚本分配别名：
- en: '[PRE73]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Aliases aren’t permanent, but they can be. In the next section, you’ll learn
    how to use bash profiles to make permanent changes to your shell.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 别名不是永久性的，但它们可以是永久的。在下一部分，你将学习如何使用 bash 配置文件使更改在 shell 中永久生效。
- en: Customizing the ~/.bashrc Profile
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义 ~/.bashrc 配置文件
- en: We can use the *~/.bashrc* file to load functions, variables, and just about
    any other custom bash code we desire into a new bash session. For example, we
    can create variables containing information we’ll frequently need to access, such
    as the IP address of a vulnerable host we’re testing.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用*~/.bashrc* 文件加载函数、变量和几乎任何其他自定义 bash 代码到新的 bash 会话中。例如，我们可以创建包含我们经常需要访问的信息的变量，比如我们正在测试的易受攻击主机的
    IP 地址。
- en: 'We could append the following to the end of the *~/.bashrc* file, for instance.
    These lines define a few custom variables and save our aliased Nmap command:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以将以下内容附加到*~/.bashrc* 文件的末尾。这些行定义了几个自定义变量，并保存了我们别名的 Nmap 命令：
- en: '[PRE74]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The next time you open a terminal, you’ll be able to access these values. Make
    these new values available immediately by using the source command to reimport
    the *~/.bashrc* file:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 下次打开终端时，你就可以访问这些值。通过使用 source 命令重新导入*~/.bashrc* 文件，可以立即使这些新值生效：
- en: '[PRE75]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Now you can use these variables even after you close the terminal and start
    a new session.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，即使你关闭终端并启动一个新会话，你也可以使用这些变量。
- en: Importing Custom Scripts
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入自定义脚本
- en: 'Another way to introduce changes to your bash session is to create a dedicated
    script that contains pentesting-related customizations and then have the *~/.bashrc*
    file import it by using the source command. To achieve this, create a *~/.pentest.sh*
    file containing your new logic and then make a one-time modification to *~/.bashrc*
    to import *pentest.sh* at the end of the file:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种引入更改到你的 bash 会话的方法是创建一个专门的脚本，包含渗透测试相关的自定义设置，然后让 *~/.bashrc* 文件通过 source 命令加载它。为此，创建一个
    *~/.pentest.sh* 文件，包含你的新逻辑，然后对 *~/.bashrc* 文件做一次性修改，加载 *pentest.sh* 文件：
- en: '[PRE76]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Note that you can also source a bash file by using the . (dot) command:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你还可以通过使用 `.`（点）命令来 source 一个 bash 文件：
- en: '[PRE77]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This command provides an alternative to source.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令提供了一个替代 source 的方法。
- en: Capturing Terminal Session Activity
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捕捉终端会话活动
- en: Penetration testing often involves having dozens of terminals open simultaneously,
    all running many tools that can produce a lot of output. When we find something
    of interest, we may need some of that output as evidence for later. To avoid losing
    track of an important piece of information, we can use some clever bash.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 渗透测试通常涉及同时打开数十个终端，每个终端运行多个工具，产生大量输出。当我们发现有用信息时，可能需要将一些输出作为证据保留下来。为了避免丢失重要信息，我们可以使用一些巧妙的
    bash 技巧。
- en: The script command allows us to capture terminal session activity. One approach
    is to load a small bash script that uses script to save every session to a file
    for later inspection. The script might look like [Listing 2-27](chapter2.xhtml#Lis2-27).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本命令允许我们捕捉终端会话活动。一个方法是加载一个小的 bash 脚本，使用 script 将每个会话保存到文件中，以便后续检查。这个脚本可能如下所示：[清单
    2-27](chapter2.xhtml#Lis2-27)。
- en: '[PRE78]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Listing 2-27: Saving terminal activity to a file'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 2-27：将终端活动保存到文件
- en: Having *~/.bashrc* load this script, as shown earlier, will result in the creation
    of the *~/sessions* directory, containing each terminal session capture in a separate
    file. The recording stops when you enter exit in the terminal or close the terminal
    window.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，通过让 *~/.bashrc* 加载这个脚本，将会创建 *~/sessions* 目录，其中包含每个终端会话的捕获文件。录制将在你输入 `exit`
    或关闭终端窗口时停止。
- en: 'Exercise 2: Pinging a Domain'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 2：Ping 一个域名
- en: 'In this exercise, you’ll write a bash script that accepts two arguments: a
    name (for example, *mysite*) and a target domain (for example, *nostarch.com*).
    The script should be able to do the following:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将编写一个 bash 脚本，接受两个参数：一个名称（例如，*mysite*）和一个目标域名（例如，*nostarch.com*）。该脚本应能执行以下操作：
- en: 1.  Throw an error if the arguments are missing and exit using the right exit
    code.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 如果缺少参数，抛出错误并使用正确的退出代码退出。
- en: 2.  Ping the domain and return an indication of whether the ping was successful.
    To learn about the ping command, run man ping.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 对域名进行 ping 测试，并返回 ping 是否成功的指示。要了解 ping 命令，可以运行 `man ping`。
- en: '3.  Write the results to a CSV file containing the following information:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 将结果写入包含以下信息的 CSV 文件：
- en: a.  The name provided to the script
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: a. 提供给脚本的名称
- en: b.  The target domain provided to the script
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: b. 提供给脚本的目标域名
- en: c.  The ping result (either success or failure)
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: c. ping 结果（成功或失败）
- en: d.  The current date and time
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: d. 当前的日期和时间
- en: As with most tasks in bash, there are multiple ways to achieve this goal. You
    can find an example solution to this exercise, *exercise_solution.sh*, in the
    book’s GitHub repository.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 与 bash 中的大多数任务一样，有多种方法可以实现此目标。你可以在本书的 GitHub 仓库中找到这个练习的示例解决方案，*exercise_solution.sh*。
- en: Summary
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to perform flow control by using conditions,
    loops, and functions; how to control scripts by using jobs; and how to search
    and parse text. We also highlighted bash tips and tricks for building more effective
    penetration-testing workflows.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何通过使用条件、循环和函数来执行流程控制；如何通过使用作业来控制脚本；以及如何搜索和解析文本。我们还强调了构建更有效渗透测试工作流的
    bash 技巧和窍门。
