- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 2 FLOW CONTROL AND TEXT PROCESSING
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This chapter covers bash concepts that can make your scripts more intelligent.
    You’ll learn how to test conditions, use loops, consolidate code into functions,
    send commands to the background, and more. You’ll also learn some ways of customizing
    your bash environment for penetration testing.
  prefs: []
  type: TYPE_NORMAL
- en: Test Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bash lets us selectively execute commands when certain conditions of interest
    are met. We can use *test operators* to craft a wide variety of conditions, such
    as whether one value equals another value, whether a file is of a certain type,
    or whether one value is greater than another. We often rely on such tests to determine
    whether to continue running a block of code, so being able to construct them is
    fundamental to bash programming.
  prefs: []
  type: TYPE_NORMAL
- en: Bash has multiple kinds of test operators. *File test operators* allow us to
    perform tests against files on the filesystem, such as checking whether a file
    is executable or whether a certain directory exists. [Table 2-1](chapter2.xhtml#tab2-1)
    shows a short list of the available tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 2-1: File Test Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| -d | Checks whether the file is a directory |'
  prefs: []
  type: TYPE_TB
- en: '| -r | Checks whether the file is readable |'
  prefs: []
  type: TYPE_TB
- en: '| -x | Checks whether the file is executable |'
  prefs: []
  type: TYPE_TB
- en: '| -w | Checks whether the file is writable |'
  prefs: []
  type: TYPE_TB
- en: '| -f | Checks whether the file is a regular file |'
  prefs: []
  type: TYPE_TB
- en: '| -s | Checks whether the file size is greater than zero |'
  prefs: []
  type: TYPE_TB
- en: You can find the full list of file test operators at *[https://ss64.com/bash/test.html](https://ss64.com/bash/test.html)*
    or by running the man test command.
  prefs: []
  type: TYPE_NORMAL
- en: '*String comparison operators* allow us to perform tests related to strings,
    such as testing whether one string is equal to another. [Table 2-2](chapter2.xhtml#tab2-2)
    shows the string comparison operators.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 2-2: String Comparison Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| = | Checks whether a string is equal to another string |'
  prefs: []
  type: TYPE_TB
- en: '| == | Synonym of = when used within [[]] constructs |'
  prefs: []
  type: TYPE_TB
- en: '| != | Checks whether a string is not equal to another string |'
  prefs: []
  type: TYPE_TB
- en: '| < | Checks whether a string comes before another string (in alphabetical
    order) |'
  prefs: []
  type: TYPE_TB
- en: '| > | Checks whether a string comes after another string (in alphabetical order)
    |'
  prefs: []
  type: TYPE_TB
- en: '| -z | Checks whether a string is null |'
  prefs: []
  type: TYPE_TB
- en: '| -n | Checks whether a string is not null |'
  prefs: []
  type: TYPE_TB
- en: '*Integer comparison operators* allow us to perform checks on integers, such
    as whether an integer is less than or greater than another. [Table 2-3](chapter2.xhtml#tab2-3)
    shows the available operators.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 2-3: Integer Comparison Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| -eq | Checks whether a number is equal to another number |'
  prefs: []
  type: TYPE_TB
- en: '| -ne | Checks whether a number is not equal to another number |'
  prefs: []
  type: TYPE_TB
- en: '| -ge | Checks whether a number is greater than or equal to another number
    |'
  prefs: []
  type: TYPE_TB
- en: '| -gt | Checks whether a number is greater than another number |'
  prefs: []
  type: TYPE_TB
- en: '| -lt | Checks whether a number is less than another number |'
  prefs: []
  type: TYPE_TB
- en: '| -le | Checks whether a number is less than or equal to another number |'
  prefs: []
  type: TYPE_TB
- en: Let’s use these operators in flow-control mechanisms to decide what code to
    run next.
  prefs: []
  type: TYPE_NORMAL
- en: if Conditions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In bash, we can use an if condition to execute code only when a certain condition
    is met. [Listing 2-1](chapter2.xhtml#Lis2-1) shows its syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-1: The structure of an if statement'
  prefs: []
  type: TYPE_NORMAL
- en: We start with the if keyword, followed by a test condition between double square
    brackets ([[]]). We then use the ; character to separate the if keyword from the
    then keyword, which allows us to introduce a block of code that runs only if the
    condition is met.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use the else keyword to introduce a fallback code block that runs if
    the condition is not met. Note that else is optional, and you may not always need
    it. Finally, we close the if condition with the fi keyword (which is if inversed).
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*In some operating systems, such as those often used in containers, the default
    shell might not necessarily be bash. To account for these cases, you may want
    to use single square brackets (*[...]*) rather than double to enclose your condition.
    This use of single brackets meets the Portable Operating System Interface standard
    and should work on almost any Unix derivative, including Linux.*'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see an if condition in practice. [Listing 2-2](chapter2.xhtml#Lis2-2)
    uses an if condition to test whether a file exists and, if not, creates it.
  prefs: []
  type: TYPE_NORMAL
- en: test_if_file _exists.sh
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-2: An if condition to test for the existence of a file'
  prefs: []
  type: TYPE_NORMAL
- en: We first create a variable named FILENAME containing the name of the file we
    need. This saves us from having to repeat the filename in the code. We then introduce
    the if statement, which includes a condition that uses the -f file test operator
    to test for the existence of the file. If this condition is true, we use echo
    to print to the screen a message explaining that the file already exists and then
    use the status code 1 (failure) to exit the program. In the else block, which
    will execute only if the file does not exist, we create the file by using the
    touch command.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*You can download this chapter’s scripts from* [https://github.com/dolevf/Black-Hat-Bash/blob/master/ch02](https://github.com/dolevf/Black-Hat-Bash/blob/master/ch02).'
  prefs: []
  type: TYPE_NORMAL
- en: Save the file and execute it. You should see the *flow_control_with_if.txt*
    file in your current directory when you run ls.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 2-3](chapter2.xhtml#Lis2-3) shows a different way of achieving the
    same outcome: it uses the NOT operator (!) to check whether a directory *doesn’t*
    exist and, if it doesn’t, creates it. This example has fewer lines of code and
    eliminates the need for an else block altogether.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-3: Using a negative check to test file existence'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore if conditions that use some of the other kinds of test operators
    we’ve covered. [Listing 2-4](chapter2.xhtml#Lis2-4) shows a string comparison
    test. It tests whether two variables are equal by performing string comparison
    with the equal-to operator (==).
  prefs: []
  type: TYPE_NORMAL
- en: string _comparison.sh
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-4: Comparing two string variables'
  prefs: []
  type: TYPE_NORMAL
- en: The script will compare the two variables, both of which have the value nostarch,
    and print They are equal! by using the echo command.
  prefs: []
  type: TYPE_NORMAL
- en: Next is an integer comparison test, which takes two integers and checks which
    one is the larger number ([Listing 2-5](chapter2.xhtml#Lis2-5)).
  prefs: []
  type: TYPE_NORMAL
- en: integer _comparison.sh
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-5: Comparing integers'
  prefs: []
  type: TYPE_NORMAL
- en: We create two variables, VARIABLE_ONE and VARIABLE_TWO, and assign them values
    of 10 and 20, respectively. We then use the -gt operator to compare the two values
    and print the result based on an integer comparison.
  prefs: []
  type: TYPE_NORMAL
- en: Linking Conditions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, we’ve used if to check whether a single condition is met. But as with
    most programming languages, we can also use the OR (||) and AND (&&) operators
    to check for multiple conditions at once.
  prefs: []
  type: TYPE_NORMAL
- en: For example, what if we want to check that a file exists and that its size is
    greater than zero? [Listing 2-6](chapter2.xhtml#Lis2-6) does so.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-6: Using AND to chain two file test conditions'
  prefs: []
  type: TYPE_NORMAL
- en: This code writes content to a file, then checks whether that file exists and
    whether its size is greater than zero. Both conditions have to be met in order
    for the echo command to be executed. If either returns false, nothing will happen.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate an OR condition, [Listing 2-7](chapter2.xhtml#Lis2-7) checks
    whether a variable is either a file or a directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-7: Chaining two file test conditions by using OR'
  prefs: []
  type: TYPE_NORMAL
- en: This code first creates a directory, then uses an if condition with the OR (||)
    operator to check whether the variable is a file (-f) or a directory (-d). The
    second condition should evaluate to true, and the echo command should execute.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Command Success
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can even test the exit code of commands to determine whether they were successful
    ([Listing 2-8](chapter2.xhtml#Lis2-8)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-8: Executing commands based on exit code values'
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll often find yourself using this technique in bash, as commands aren’t
    guaranteed to succeed. Failures could happen for reasons such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: A lack of the necessary permissions when creating resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An attempt to execute a command that is not available on the operating system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The disk being full when downloading a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The network being down while executing network utilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To see how this technique works, execute the following in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We attempt to create a file. Because the file creation succeeds, we print a
    message to indicate this.
  prefs: []
  type: TYPE_NORMAL
- en: Checking Subsequent Conditions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the first if condition fails, you can check for other conditions by using
    the elif keyword (short for *else if*). To show how this works, let’s write a
    program that checks the arguments passed to it on the command line. [Listing 2-9](chapter2.xhtml#Lis2-9)
    will output a message clarifying whether the argument is a file or a directory.
  prefs: []
  type: TYPE_NORMAL
- en: if_elif.sh
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-9: Using if and elif statements'
  prefs: []
  type: TYPE_NORMAL
- en: We begin with an if statement that checks whether the variable USER_INPUT is
    null ❶. This allows us to exit the script early by using exit 1 if we receive
    no command line arguments from the user. We then begin a second if condition that
    uses the file test operator to check whether the input is a file ❷. Below this
    condition, we use elif to test whether the argument is a directory ❸. This condition
    won’t be tested unless the file test fails. If neither of these conditions is
    true, the script responds that the argument is neither a file nor a directory
    ❹.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Functions* help us reuse blocks of code so we can avoid repeating them. They
    allow us to run multiple commands and other bash code simultaneously by simply
    entering the function’s name. To define a new function, enter a name for it, followed
    by parentheses. Then place the code you would like the function to run within
    curly brackets ([Listing 2-10](chapter2.xhtml#Lis2-10)).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-10: Defining a function'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we define a function called say_name() that executes a single echo command.
    To call a function, simply enter its name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If the function is not called, the commands within it won’t run.
  prefs: []
  type: TYPE_NORMAL
- en: Returning Values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like commands and their exit statuses, functions can return values by using
    the return keyword. If there is no return statement, the function will return
    the exit code of the last command it ran. For example, the function in [Listing
    2-11](chapter2.xhtml#Lis2-11) returns a different value based on whether the current
    user is root.
  prefs: []
  type: TYPE_NORMAL
- en: check_root _function.sh
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-11: An if condition to test whether a function returned true or false'
  prefs: []
  type: TYPE_NORMAL
- en: We define the check_if_root() function ❶. Within this function, we use an if
    condition with an integer comparison test ❷, accessing the environment variable
    EUID to get the effective running user’s ID and checking whether it equals 0\.
    If so, the user is root, and the function returns 0; if not, it returns 1\. Next,
    we call the check_if_root function and check if it returned 0, which means the
    user is root. Otherwise, we print that the user is not root.
  prefs: []
  type: TYPE_NORMAL
- en: Bash scripts that perform privileged actions often check whether the user is
    root before attempting to install software, create users, delete groups, and so
    on. Attempting to perform privileged actions on Linux without the necessary privileges
    will result in errors, so this check helps handle these cases.
  prefs: []
  type: TYPE_NORMAL
- en: Accepting Arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 1](chapter1.xhtml), we covered the passing of arguments to commands
    on the command line. Functions can also take arguments by using the same syntax.
    For example, the function in [Listing 2-12](chapter2.xhtml#Lis2-12) prints the
    first three arguments it receives.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-12: A function with arguments'
  prefs: []
  type: TYPE_NORMAL
- en: 'To call a function with arguments, enter its name and the arguments separated
    by spaces ❶. Save this script as *function_with_args.sh* and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You should see output similar to that shown here.
  prefs: []
  type: TYPE_NORMAL
- en: Loops and Loop Controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like many programming languages, bash lets you repeat chunks of code by using
    *loops*. Loops can be particularly useful in your penetration-testing adventures
    because they can help you accomplish tasks such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Continuously checking whether an IP address is online after a reboot until the
    IP address is responsive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterating through a list of hostnames (for example, to run a specific exploit
    against each of them or determine whether a firewall is protecting them)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing for a certain condition and then running a loop when it is met (for
    example, checking whether a host is online and, if so, performing a brute-force
    attack against it)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following sections introduce you to the three kinds of loops in bash (while,
    until, and for) as well as the break and continue statements for working with
    loops.
  prefs: []
  type: TYPE_NORMAL
- en: while
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In bash, while loops allow you to run a code block until a test returns a successful
    exit status code. You might use them in penetration testing to continuously perform
    a port scan on a network and pick up any new hosts that join the network, for
    example.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 2-13](chapter2.xhtml#Lis2-13) shows the syntax of a while loop.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-13: A while loop'
  prefs: []
  type: TYPE_NORMAL
- en: This loop starts with the keyword while, followed by an expression that describes
    the condition. We then surround the code to be executed with the do and done keywords,
    which define the start and end of the code block.
  prefs: []
  type: TYPE_NORMAL
- en: You can use while loops to run a chunk of code infinitely by using true as the
    condition; because true always returns a successful exit code, the code will always
    run. Let’s use a while loop to repeatedly print a command to the screen. Save
    [Listing 2-14](chapter2.xhtml#Lis2-14) to a file named *basic_while.sh* and run
    it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-14: Repeatedly running a command at two-second intervals'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s write a more sophisticated while loop that runs until it finds a
    specific file on the filesystem ([Listing 2-15](chapter2.xhtml#Lis2-15)). Use
    CTRL-C to stop the code from executing at any point.
  prefs: []
  type: TYPE_NORMAL
- en: while_loop.sh
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-15: File monitoring'
  prefs: []
  type: TYPE_NORMAL
- en: 'At ❶, we define a variable representing the name of the file for which the
    while loop ❷ checks, using a file test operator. The loop won’t exit until the
    condition is satisfied. Once the file is available, the loop will stop, and the
    script will continue to the echo command ❸. Save this file as *while_loop.sh*
    and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'While the script is running, open a second terminal in the same directory as
    the script and create the *stoploop* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you’ve done so, you should see the script break out of the loop and print
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We can use while loops to monitor for filesystem events, such as file creations
    or deletions, or when a process starts. This may come in handy if an application
    is suffering from a vulnerability we can only temporarily abuse. For example,
    consider an application that runs daily at a particular hour and checks whether
    the file */tmp/update.sh* exists; if it does, the application executes it as the
    *root* user. Using a while loop, we can monitor when that application has started
    and then create the file just in time so our commands are executed by that application.
  prefs: []
  type: TYPE_NORMAL
- en: until
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whereas while runs so long as the condition succeeds, until runs so long as
    it fails. [Listing 2-16](chapter2.xhtml#Lis2-16) shows the until loop syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-16: An until loop'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 2-17](chapter2.xhtml#Lis2-17) uses until to run some commands until
    a file’s size is greater than zero (meaning it is not empty).'
  prefs: []
  type: TYPE_NORMAL
- en: until_loop.sh
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-17: Checking a file’s size'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first create an empty file, then begin a loop that runs until the file is
    no longer empty. Within the loop, we print messages to the terminal. Save this
    file as *until_loop.sh* and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, the script has created the file *output.txt*, but it’s an empty
    file. We can check this by using the du (disk usage) command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Open another terminal and navigate to the location at which your script is
    saved, then append some content to the file so its size is no longer zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The script should exit the loop, and you should see it print the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: for
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The for loop iterates over a *sequence*, such as a list of filenames or variables,
    or even a group of values generated by running a command. Inside the for loop,
    we define a block of commands that are run against each value in the list, and
    each value in the list is assigned to a variable name we define.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 2-18](chapter2.xhtml#Lis2-18) shows the syntax of a for loop.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-18: A for loop'
  prefs: []
  type: TYPE_NORMAL
- en: A simple way to use a for loop is to execute the same command multiple times.
    For example, [Listing 2-19](chapter2.xhtml#Lis2-19) prints the numbers 1 through
    10.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-19: Counting to 10 in a for loop'
  prefs: []
  type: TYPE_NORMAL
- en: 'Save and run this script. You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: A more practical example might use a for loop to run commands against a bunch
    of IP addresses passed on the command line. [Listing 2-20](chapter2.xhtml#Lis2-20)
    retrieves all arguments passed to the script, then iterates through them and prints
    a message for each.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-20: Iterating through command line arguments'
  prefs: []
  type: TYPE_NORMAL
- en: 'Save this script as *for_loop_arguments.sh* and run it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We can even run a for loop on the output of commands such as ls. In [Listing
    2-21](chapter2.xhtml#Lis2-21), we print the names of all files in the current
    working directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-21: Iterating through files in the current directory'
  prefs: []
  type: TYPE_NORMAL
- en: We use a for loop to iterate over the output of the ls . command, which lists
    the files in the current directory. Each file will be assigned to the file variable
    as part of the for loop, so we can then use echo to print its name. This technique
    would be useful, for example, if we wanted to perform an upload of all files in
    the directory or even rename them in bulk.
  prefs: []
  type: TYPE_NORMAL
- en: break and continue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Loops can run forever or until a condition is met. But we can also exit a loop
    at any point by using the break keyword. This keyword provides an alternative
    to the exit command, which would cause the entire script, not just the loop, to
    exit. Using break, we can leave the loop and advance to the next code block ([Listing
    2-22](chapter2.xhtml#Lis2-22)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-22: Breaking from a loop'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the last echo command will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The continue statement is used to jump to the next iteration of a loop. We
    can use it to skip a certain value in a sequence. To illustrate this, let’s create
    three empty files so we can iterate through them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Next, our for loop will write content to each file, excluding the first one,
    *example_file1*, which the loop will leave empty ([Listing 2-23](chapter2.xhtml#Lis2-23)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-23: Skipping an element in a for loop'
  prefs: []
  type: TYPE_NORMAL
- en: We start a for loop with the example_file* glob, which will expand to match
    the names of all files starting with *example_file* in the directory where the
    script runs ❶. As a result, the loop should iterate over all three files we created
    earlier. Within the loop, we use string comparison to check whether the filename
    is equal to *example_file1* because we want to skip this file and not make any
    changes to it. If the condition is met, we use the continue statement ❷ to proceed
    to the next iteration, leaving the file unmodified. Later in the loop, we use
    the echo command with the environment variable ${RANDOM} to generate a random
    number and write it into the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save this script as *for_loop_continue.sh* and execute it in the same directory
    as the three files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: If you examine the files, you should see that the first file is empty, while
    the other two contain a random number as a result of the script echoing the value
    of the ${RANDOM} environment variable into them.
  prefs: []
  type: TYPE_NORMAL
- en: case Statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In bash, case statements allow you to test multiple conditions in a cleaner
    way by using more readable syntax. Often, they help you avoid many if conditions,
    which can become harder to read as they grow in size.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 2-24](chapter2.xhtml#Lis2-24) shows the case statement syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-24: A case statement'
  prefs: []
  type: TYPE_NORMAL
- en: A case statement starts with the keyword case followed by an expression, such
    as a variable you want to match a pattern against. PATTERN1 and PATTERN2 in this
    example represent a pattern case (such as a regular expression, a string, or an
    integer) that you want to compare to the expression. To close a case statement,
    you use the keyword esac (case inverted).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at an example case statement that checks whether an IP address
    is present in a specific private network ([Listing 2-25](chapter2.xhtml#Lis2-25)).
  prefs: []
  type: TYPE_NORMAL
- en: case_ip_address _check.sh
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-25: Checking an IP address and determining its network'
  prefs: []
  type: TYPE_NORMAL
- en: We define a variable that expects one command line argument to be passed (${1})
    and saves it to the IP_ADDRESS variable. We then use a pattern to check whether
    the IP_ADDRESS variable starts with 192.168. and a second pattern to check whether
    it starts with 10.0.
  prefs: []
  type: TYPE_NORMAL
- en: We also define a default wildcard pattern using *, which returns a default message
    to the user if nothing else has matched.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save this file as *case_ip_address_check.sh* and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: A case statement can be used for a variety of use cases. For example, it can
    be used to run functions based on input the user has entered. Using case statements
    is a great way to handle the evaluation of multiple conditions without sacrificing
    the readability of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Text Processing and Parsing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most common things you’ll find yourself doing in bash is processing
    text. You can parse text on the command line by running one-off commands, or use
    a script to store parsed data in a variable that you can act on in some way. Both
    approaches are important to many scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: To test the commands in this section on your own, download the sample logfile
    from *[https://github.com/dolevf/Black-Hat-Bash/blob/master/ch02/log.txt](https://github.com/dolevf/Black-Hat-Bash/blob/master/ch02/log.txt)*.
    This file is space-separated, and each segment represents a specific data type,
    such as the client’s source IP address, timestamp, HyperText Transfer Protocol
    (HTTP) method, HTTP path, HTTP User Agent field, HTTP status code, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering with grep
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The grep command is one of the most popular Linux commands out there today.
    We use grep to filter out information of interest from streams. At its most basic
    form, we can use it as shown in [Listing 2-26](chapter2.xhtml#Lis2-26).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-26: Filtering for a specific string from a file'
  prefs: []
  type: TYPE_NORMAL
- en: This grep command will read the file and extract any lines containing the IP
    address 35.237.4.214 from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can even use grep for multiple patterns simultaneously. The following backslash
    pipe (\|) acts as an OR condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we could use multiple grep patterns with the -e argument to
    accomplish the same thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'As you learned in [Chapter 1](chapter1.xhtml), we can use the pipe (|) command
    to provide one command’s output as the input to another. In the following example,
    we run the ps command and use grep to filter out a specific line. The ps command
    lists the processes on the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, grep is case sensitive. We can make our search case insensitive
    by using the -i flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use grep with the -v argument to exclude lines containing a certain
    pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'To print only the matched pattern, and not the entire line at which the matched
    pattern was found, use -o:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The command also supports regular expressions, anchoring, grouping, and much
    more. Use the man grep command to read more about its capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering with awk
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The awk command is a data processing and extraction Swiss Army knife. You can
    use it to identify and return specific fields from a file. To see how awk works,
    take another close look at our logfile. What if we need to print just the IP addresses
    from this file? This is easy to do with awk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The $1 represents the first field of every line in the file where the IP addresses
    are. By default, awk treats spaces or tabs as separators or delimiters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the same syntax, we can print additional fields, such as the timestamps.
    The following command filters the first three fields of every line in the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Using similar syntax, we can print the first and last field simultaneously.
    In this case, NF represents the last field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also change the default delimiter. For example, if we had a file separated
    by commas (that is, a CSV, or comma-separated values file), rather than by spaces
    or tabs, we could pass awk the -F flag to specify the type of delimiter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even use awk to print the first 10 lines of a file. This emulates the
    behavior of the head Linux command; NR represents the total number of records
    and is built into awk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll often find it useful to combine grep and awk. For example, you might
    want to first find the lines in a file containing the IP address 42.236.10.117
    and then print the HTTP paths requested by this IP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The awk command is a superpowerful tool, and we encourage you to dig deeper
    into its capabilities by running man awk for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Editing Streams with sed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The sed (stream editor) command takes actions on text. For example, it can replace
    the text in a file, modify the text in a command’s output, and even delete selected
    lines from files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use sed to replace any mentions of the word *Mozilla* with the word *Godzilla*
    in the *log.txt* file. We use its s (substitution) command and g (global) command
    to make the substitution across the whole file, rather than to just the first
    occurrence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output the modified version of the file but won’t change the original
    version. You can redirect the output to a new file to save your changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We could also use sed to remove any whitespace from the file with the / //
    syntax, which will replace whitespace with nothing, removing it from the output
    altogether:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to delete lines of a file, use the d command. In the following
    command, 1d deletes (d) the first line (1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'To delete the last line of a file, use the dollar sign ($), which represents
    the last line, along with d:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also delete multiple lines, such as lines 5 and 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can print (p) specific line ranges, such as lines 2 through 15:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'When you pass sed the -i argument, it will make the changes to the file itself
    rather than create a modified copy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This rich utility can do a whole lot more. Use the man sed command to find additional
    ways to use sed.
  prefs: []
  type: TYPE_NORMAL
- en: Job Control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you become proficient in bash, you’ll start to build complex scripts that
    take an hour to complete or must run continuously. Not all scripts need to execute
    in the foreground, blocking execution of other commands. Instead, you may want
    to run certain scripts as background jobs, either because they take a while to
    complete or because their runtime output isn’t interesting and you care about
    only the end result.
  prefs: []
  type: TYPE_NORMAL
- en: Commands that you run in a terminal occupy that terminal until the command is
    finished. These commands are considered *foreground jobs*. In [Chapter 1](chapter1.xhtml),
    we used the ampersand character (&) to send a command to the background. This
    command then becomes a *background job* that allows us to unblock the execution
    of other commands.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the Background and Foreground
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To practice working with background and foreground jobs, let’s run a command
    directly in the terminal and send it to the background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we can continue working on the terminal while this sleep command
    runs for 100 seconds. We can verify that the spawned process is running by using
    the ps command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that this job is in the background, we can use the jobs command to see
    what jobs are currently running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The output shows that the sleep command is in Running state and that its job
    ID is 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can migrate the job from the background to the foreground by issuing the
    fg command and the job ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, the sleep command is occupying the terminal, since it’s running
    in the foreground. You can press CTRL-Z to suspend the process, which will produce
    the following output in the jobs table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'To send this job to the background again in a running state, use the bg command
    with the job ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Here, we supply the job ID of 1.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping Jobs Running After Logout
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whether you send a job to the background or are running a job in the foreground,
    the process won’t survive if you close the terminal or log out. If you close the
    terminal, the process will receive a SIGHUP signal and terminate.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if we want to keep running a script in the background even after we’ve
    logged out of the terminal window or closed it? To do so, we could start a script
    or command with the nohup (no hangup) command prepended:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The nohup command will create a file named *nohup.out* with standard output
    stream data. Make sure you delete this file if you don’t want it on the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: There are additional ways to run background scripts, such as by plugging into
    system and service managers like *systemd*. These managers provide additional
    features, such as monitoring that the process is running, restarting it if it
    isn’t, and capturing failures. We encourage you to read more about systemd at
    *[https://man7.org/linux/man-pages/man1/init.1.html](https://man7.org/linux/man-pages/man1/init.1.html)*
    if you have such use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Bash Customizations for Penetration Testers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As penetration testers, we often follow standard workflows for all ethical hacking
    engagements, whether they are consulting work, bug bounty hunting, or red teaming.
    We can optimize some of this work with a few bash tips and tricks.
  prefs: []
  type: TYPE_NORMAL
- en: Placing Scripts in Searchable Paths
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bash searches for programs within directories defined by the PATH environment
    variable. Commands such as ls are always available to you because system and user
    binaries are located in directories that are part of the PATH.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see your PATH, run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The output might look different, depending on your operating system.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you write a bash script, place it in a directory such as */usr/local/bin*,
    which, as you can see, is part of the PATH. If you don’t do this, you have a few
    other options available:'
  prefs: []
  type: TYPE_NORMAL
- en: Call the script directly, using the full path.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the directory to the one in which your script lives and execute it from
    there.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use aliases (shown in the next section).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add paths to the PATH environment variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The benefit of placing the script in a searchable path is that you can simply
    call it by its name. You don’t have to provide the full path or have the terminal
    be in the same directory.
  prefs: []
  type: TYPE_NORMAL
- en: Shortening Commands with Aliases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you find yourself frequently using a long Linux command, you can use an
    *alias* to map the command to a shorter custom name that will save you time when
    you need to run it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, imagine that you often use Nmap (discussed in [Chapter 4](chapter4.xhtml))
    with special parameters to scan for all 65,535 ports on a given IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'This command is quite hard to remember. With aliases, we can make it more accessible
    on the command line or to our scripts. Here, we assign the command to the alias
    quicknmap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can run the aliased command by using the name of the alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'You can even assign an alias to your own scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Aliases aren’t permanent, but they can be. In the next section, you’ll learn
    how to use bash profiles to make permanent changes to your shell.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the ~/.bashrc Profile
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can use the *~/.bashrc* file to load functions, variables, and just about
    any other custom bash code we desire into a new bash session. For example, we
    can create variables containing information we’ll frequently need to access, such
    as the IP address of a vulnerable host we’re testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could append the following to the end of the *~/.bashrc* file, for instance.
    These lines define a few custom variables and save our aliased Nmap command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The next time you open a terminal, you’ll be able to access these values. Make
    these new values available immediately by using the source command to reimport
    the *~/.bashrc* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Now you can use these variables even after you close the terminal and start
    a new session.
  prefs: []
  type: TYPE_NORMAL
- en: Importing Custom Scripts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another way to introduce changes to your bash session is to create a dedicated
    script that contains pentesting-related customizations and then have the *~/.bashrc*
    file import it by using the source command. To achieve this, create a *~/.pentest.sh*
    file containing your new logic and then make a one-time modification to *~/.bashrc*
    to import *pentest.sh* at the end of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that you can also source a bash file by using the . (dot) command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: This command provides an alternative to source.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing Terminal Session Activity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Penetration testing often involves having dozens of terminals open simultaneously,
    all running many tools that can produce a lot of output. When we find something
    of interest, we may need some of that output as evidence for later. To avoid losing
    track of an important piece of information, we can use some clever bash.
  prefs: []
  type: TYPE_NORMAL
- en: The script command allows us to capture terminal session activity. One approach
    is to load a small bash script that uses script to save every session to a file
    for later inspection. The script might look like [Listing 2-27](chapter2.xhtml#Lis2-27).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-27: Saving terminal activity to a file'
  prefs: []
  type: TYPE_NORMAL
- en: Having *~/.bashrc* load this script, as shown earlier, will result in the creation
    of the *~/sessions* directory, containing each terminal session capture in a separate
    file. The recording stops when you enter exit in the terminal or close the terminal
    window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2: Pinging a Domain'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this exercise, you’ll write a bash script that accepts two arguments: a
    name (for example, *mysite*) and a target domain (for example, *nostarch.com*).
    The script should be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Throw an error if the arguments are missing and exit using the right exit
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Ping the domain and return an indication of whether the ping was successful.
    To learn about the ping command, run man ping.
  prefs: []
  type: TYPE_NORMAL
- en: '3.  Write the results to a CSV file containing the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: a.  The name provided to the script
  prefs: []
  type: TYPE_NORMAL
- en: b.  The target domain provided to the script
  prefs: []
  type: TYPE_NORMAL
- en: c.  The ping result (either success or failure)
  prefs: []
  type: TYPE_NORMAL
- en: d.  The current date and time
  prefs: []
  type: TYPE_NORMAL
- en: As with most tasks in bash, there are multiple ways to achieve this goal. You
    can find an example solution to this exercise, *exercise_solution.sh*, in the
    book’s GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned how to perform flow control by using conditions,
    loops, and functions; how to control scripts by using jobs; and how to search
    and parse text. We also highlighted bash tips and tricks for building more effective
    penetration-testing workflows.
  prefs: []
  type: TYPE_NORMAL
