<html><head></head><body>
<div id="sbo-rt-content"><section>&#13;
<header>&#13;
<h1 class="chapter">&#13;
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_3" title="3"/>1</span><br/>&#13;
<span class="ChapterTitle">I<sup>2</sup>C Low-Level Hardware</span></h1>&#13;
</header>&#13;
<figure class="opener">&#13;
<img alt="" height="203" src="image_fi/book_art/chapterart.png" width="203"/>&#13;
</figure>&#13;
<p class="ChapterIntro">The I<sup>2</sup>C bus is a worldwide standard for communication between integrated circuits (ICs) on printed circuit boards (PCBs) and across multiple PCBs within a system. According to NXP Semiconductors, I<sup>2</sup>C is in use on more than 1,000 different ICs made by more than 50 different manufacturers. Without question, I<sup>2</sup>C is one of the more popular inter-IC data communication schemes available (Serial Peripheral Interface [SPI] being another). </p>&#13;
<p>The popularity of the I<sup>2</sup>C bus increased with the introduction of hobbyist-level single-board computers (SBCs) such as the Arduino and Raspberry Pi that include I<sup>2</sup>C support. Today, tens of thousands of programmers have learned the basics of the I<sup>2</sup>C bus because they wanted to interface some device to an Arduino- or Pi-class system. Because of the <span epub:type="pagebreak" id="Page_4" title="4"/>vast amount of open source library code available, it is possible to use and program devices on the I<sup>2</sup>C bus without really understanding its low-level signal protocols. However, to truly make the most of a design employing I<sup>2</sup>C peripherals, you need to understand those protocols, both hardware and software. This chapter introduces the low-level hardware aspects of the I<sup>2</sup>C, which you’ll need to understand before learning about the signal protocols.</p>&#13;
<h2 id="h1-502468c01-0001">	1.1	I<sup>2</sup>C Overview</h2>&#13;
<p class="BodyFirst">Before buses such as the I<sup>2</sup>C bus, different components of a computer system communicated with one another using traditional CPU-style buses. These buses typically used 8 to 32 data lines and some number of address signals. Connecting a single 8-bit parallel I/O device to a CPU required a fair amount of PCB space to hold all the signal traces. Of course, adding additional I/O increased signal, space, and noise accordingly. In addition to space, those lines also increased the amount of noise that system engineers had to deal with in their designs. </p>&#13;
<p>The I<sup>2</sup>C bus was invented to alleviate these problems. With the I<sup>2</sup>C bus, a single pair of signal lines (PCB traces) can connect a wide variety of different I/O peripherals to a CPU. This reduces cost and eliminates many problems when building complex (embedded) computer systems (see the text box “Advantages of the I<sup>2</sup>C Bus” for more information).</p>&#13;
<p>I<sup>2</sup>C devices are divided into two general categories: controller devices (formerly known as masters) and peripheral devices (formerly slaves). A <em>controller device</em>, as its name suggests, controls the communication between the controller and the peripheral device. The <em>peripheral device</em> does not initiate any communication on its own and relies on the controller to manage the communication process.</p>&#13;
<p>The I<sup>2</sup>C protocol is a synchronous serial communication using two signal lines: <em>SCL</em>, which stands for “serial clock,” and <em>SDA</em>, which stands for “serial data.” The controller drives the clock line. When the peripheral is sending data to the controller, it puts the data bits on the data line; when the peripheral is receiving data, the controller places the serial data bits on the data line. Except for one special case—clock stretching, discussed later in this chapter—the peripheral never controls the clock line.</p>&#13;
<p>A typical system has a single controller and one or more peripheral devices. Each peripheral device has an address unique to a given I<sup>2</sup>C bus, which the controller uses to differentiate multiple peripherals on the same bus. In theory, a single I<sup>2</sup>C bus supports up to 127 or even 1,024 different peripheral devices, though practical matters limit the number of peripheral devices to a much smaller number.</p>&#13;
<p>Although a typical system has only a single controller, the I<sup>2</sup>C bus supports multiple controllers on the same bus. This allows multiple controllers to share a common set of peripheral devices. A given system can also support multiple I<sup>2</sup>C buses, so peripheral devices with the same address, which cannot be used together on the same I<sup>2</sup>C bus, can still be deployed in a given system.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="box">&#13;
<h2><span epub:type="pagebreak" id="Page_5" title="5"/>Advantages of the I<sup>2</sup>C Bus</h2>&#13;
<p class="BoxBodyFirst">The I<sup>2</sup>C bus offers several advantages over other inter-IC connection schemes, including the following:</p>&#13;
<ul>&#13;
<li>Only two signal lines are required: SDA (the data line) and SCL (the clock line). For this reason, I<sup>2</sup>C is sometimes known as the two-wire interface (TWI), though technically a ground wire is also required. (Note that TWI may refer either to I<sup>2</sup>C in general or to a subset of the I<sup>2</sup>C protocol with limited capabilities.)</li>&#13;
<li>Each peripheral connected to the bus has its own unique address. A controller-peripheral relationship exists at all times.</li>&#13;
<li>The I<sup>2</sup>C bus supports multicontroller relationships on the same I<sup>2</sup>C bus, with arbitration to prevent data corruption.</li>&#13;
<li>The I<sup>2</sup>C bus supports several standard bidirectional data transmission rates, including 100 kbit/sec, 400 kbit/sec, 1 Mbit/sec, and up to 3.4 Mbit/sec, depending on bus capacitance. A special unidirectional transfer mode supports up to 5 Mbit/sec.</li>&#13;
<li>The number of ICs that can be connected to the bus is limited only by bus capacitance. Technically, the number of I<sup>2</sup>C addresses (128 or 1,024) is another limitation, but a typical system will probably reach the bus capacitance limit before reaching the addressing limit.</li>&#13;
<li>Wiring an I<sup>2</sup>C peripheral onto the bus is extremely simple and usually consists of connecting only three wires (SDA, SCL, and Gnd).</li>&#13;
<li>Because I<sup>2</sup>C peripherals have their own unique address, there’s no need for bus address decoding hardware and extra decoding lines.</li>&#13;
</ul>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
<p>The controller-peripheral relationship is fundamental to the I<sup>2</sup>C protocol. While, in theory, it is possible for a single IC to behave either as a controller or as a peripheral and even switch between these two functions in a given system, such activity is rare; in general, a device functions either as a peripheral or as a controller within a system.</p>&#13;
<h2 id="h1-502468c01-0002">	1.2	Open-Drain (Open-Collector) Logic and Four-Wire Mode</h2>&#13;
<p class="BodyFirst">One of the most fundamental electrical aspects of the I<sup>2</sup>C bus is that it is based on an open-drain (or open-collector) logic system. That is, a device connected to the I<sup>2</sup>C bus does not <em>drive</em> the signal lines high or low; instead, it can only <em>pull</em> these lines low using an open-drain (FET) connection. Pullup resistors that connect the signal lines on the I<sup>2</sup>C bus to a power supply pull the two bus lines, SDA and SCL, high by default. This design allows multiple controllers and peripherals to control the data and clock lines without running into problems associated with connecting multiple output pins to the same signal line.</p>&#13;
<p><span epub:type="pagebreak" id="Page_6" title="6"/>To place a logic 1 on one of the lines, a device puts its open-drain (or open-collector, if using bipolar devices) into the high-impedance state. This allows the default logic 1 to appear on the line, placed there by the pullup resistor. To place a logic 0 on one of the lines, the device activates its open-drain device, which shorts the line to ground.</p>&#13;
<p>Most I<sup>2</sup>C devices provide open-drain signals to connect to the I<sup>2</sup>C bus, so you don’t need to have any additional hardware to interface such devices to the bus. However, it is also possible to connect arbitrary logic devices to the I<sup>2</sup>C bus by routing them through a bipolar transistor (open-collector), JFET, MOSFET, or other open-drain device to control the electrical access to the I<sup>2</sup>C bus. The following subsection provides an example of this. </p>&#13;
<p>The SDA and SCL lines, by definition, are bidirectional on the controller device and are often bidirectional on peripheral devices. Certain single-board computers or CPUs might not support digital I/O pins that can operate in a bidirectional mode—that is, they can be programmed only as an input pin or an output pin. To resolve this, some system designers implement I<sup>2</sup>C in <em>four-wire mode</em>. In four-wire mode the I<sup>2</sup>C bus still has two wires, but the controller uses two wires to implement each of the signals: two output pins and two input pins. <a href="#figure1-1" id="figureanchor1-1">Figure 1-1</a> diagrams this four-wire controller connection. </p>&#13;
<figure>&#13;
<img alt="" class="" height="479" src="image_fi/502468c01/f01001.png" width="407"/>&#13;
<figcaption><p><a id="figure1-1">Figure 1-1</a>: Four-wire controller connection</p></figcaption>&#13;
</figure>&#13;
<p>To prevent electrical conflicts (connecting two outputs together), the output pins drive the base of a transistor (gate on a FET or MOSFET), and the collector (drain) connects to the appropriate bus line. Then the <span epub:type="pagebreak" id="Page_7" title="7"/>controller CPU can simultaneously read the data on the bus lines using the input pins while writing data on the output pins with no electrical conflict and without support for bidirectional I/O pins.</p>&#13;
<h2 id="h1-502468c01-0003">	1.3	I<sup>2</sup>C Signal Levels</h2>&#13;
<p class="BodyFirst">When the I<sup>2</sup>C was designed in the early 1980s, 5 V logic was the prevalent design technology, so the original I<sup>2</sup>C assumed the use of 5-V logic signals. However, as the I<sup>2</sup>C bus is based on open-drain connections, the high voltage level is completely determined by the power supply that the pullup resistors connect to when designing the system. As computer systems started using 3.3 V or even down to 1.8 V, system designers began hooking up those pullup resistors to power supplies other than 5 V. </p>&#13;
<p>From the perspective of the I<sup>2</sup>C bus, as long as the controllers and peripherals can handle and properly work with the voltage levels appearing on the bus, any voltage <em>should</em> work fine. In reality, however, some voltages may cause problems. For this reason, recent I<sup>2</sup>C standards state that the voltage on the bus must be at least 2 V (so 1.8-V logic won’t work). They also specify that a logic high is defined as greater than 70 percent of the power supply voltage and a logic low is defined as less than 30 percent of the power supply voltage. Today, generic I<sup>2</sup>C devices almost always expect 5-V or 3.3-V logic.</p>&#13;
<h3 id="h2-502468c01-0001">1.3.1	Level Shifting</h3>&#13;
<p class="BodyFirst">What happens if you want to mix 3.3-V and 5-V I<sup>2</sup>C devices on the same bus? Sending a 3.3-V signal into a 5-V device probably won’t damage it, but the device may not interpret 3.3 V as a logic 1, because the standard calls for a logic 1 are equal to 3.5 V on a 5-V system (70 percent of 5 V is 3.5 V). Sending a 5-V signal into a 3.3-V device is far worse; often, this will destroy the device. Clearly, you should avoid this situation at all costs.</p>&#13;
<p>When mixing 3.3-V and 5-V (or other different voltage range) devices on the same I<sup>2</sup>C bus, you must use <em>voltage translation</em>, or <em>level shifting</em>, to convert the actual voltage on the bus to something that is compatible with the device(s). NXP Semiconductors provides a technical note describing how to do this using discrete MOSFETs (see “For More Information” at the end of this chapter). Another solution is to purchase a commercial-off-the-shelf (COTS) part such as the Adafruit, four-channel, I<sup>2</sup>C-safe, bidirectional logic level converter (BSS138). The Adafruit BSS138 device provides a bridge between two I<sup>2</sup>C buses operating at 3.3 V and 5 V—or, if you need a larger voltage range, it’s rated down to 1.8 V and up to 10 V. As I’m writing this, these Adafruit devices cost about $4 each (US) and support two independent I<sup>2</sup>C bus level shifters (the I<sup>2</sup>C bus requires two level shifters, one for the SDA line and one for the SCL line).</p>&#13;
<p>A third option is to level-shift with the TCA9548A I<sup>2</sup>C multiplexer device. This IC will split the I<sup>2</sup>C bus into eight separately controlled I<sup>2</sup>C buses. Each independent bus can have its own pullup resistor to an <span epub:type="pagebreak" id="Page_8" title="8"/>independent power supply (for example, 3.3 V or 5 V). Therefore, you can put the 3.3-V devices on one bus and the 5-V devices into another. The incoming bus (from the CPU to the TCA9548A) can be either voltage. See Chapter 12 for more information.</p>&#13;
<h2 id="h1-502468c01-0004">	1.4	Choosing Pullup Resistor Sizes</h2>&#13;
<p class="BodyFirst">Choosing resistor sizes for the SDA and SCL pullup resistors requires a bit of thought. While I won’t go into the heavy math behind this choice, keep in mind that pullup resistors should be somewhere in the range of 1 kΩ to about 20 kΩ based on the supply voltage and bus capacitance. The higher the bus capacitance (in particular, the longer your I<sup>2</sup>C bus lines are), the lower the resistor should be. The minimum value is generally determined by the power supply voltage. For 3.3-V systems, you can go to slightly below 1 kΩ, if you have to. For 5-V systems, 1.5 kΩ is probably as low as you should go.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">NOTE</span></h2>&#13;
<p>	To dive into the math behind choosing resistor sizes, see <em>UM10204: I</em><sup>2</sup><em>C Bus Specification and User Manual</em> in “For More Information.”</p>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
<p>Generally, most systems start out with 4.7-kΩ pullups and go down from there if necessary. Note that if you are using commonly available COTS parts, such as breakout boards from Adafruit, SparkFun, or Seeed Studio, the boards often have pullup resistors already installed. If you attach two or more of these devices to your system, you have to compute the final resistance using a parallel resistance calculation (1/<em>R</em> = 1/<em>R</em><sub>1</sub> + 1/<em>R</em><sub>2</sub> + . . . + 1/<em>R</em><sub><em>n</em></sub>). This means if you install two boards, each with a 4.7-kΩ pullup, you’ve actually got 2.35-kΩ pullups on the two lines. If you add too many of these boards on the same bus, you can wind up with pullup values below the minimum suggested resistances.</p>&#13;
<h2 id="h1-502468c01-0005">	1.5	Bus Capacitance and Pullup Resistor Values</h2>&#13;
<p class="BodyFirst">The speed of the I<sup>2</sup>C bus, which I’ll discuss further in the next section, is largely determined by the value of the pullup resistors (<em>R</em><sub><em>p</em></sub>) and the bus capacitance (<em>C</em><sub><em>p</em></sub>). Although the system designer has direct control over the value of the pullup resistors, bus capacitance is mostly a function of two things: input capacitance of the devices connected to the bus, and the length of the bus itself. Capacitance increases with bus length, as does resistance, though only by a small and generally insignificant amount. Why do these two parameters affect bus speed? </p>&#13;
<p>From electronics theory you know that the product of resistance and capacitance is time. In particular, 1 Ω × 1 farad = 1 second. When a device pulls one of the bus lines low or releases a bus line so that the pullup resistor returns the signal high, the bus capacitance and <span epub:type="pagebreak" id="Page_9" title="9"/>resistance affect the amount of time it takes for the signal to rise or fall. If this time exceeds a certain value, the I<sup>2</sup>C bus will not be able to operate at its full rated speed.</p>&#13;
<p>The I<sup>2</sup>C standard limits bus capacitance to 400 pF (<em>picofarads</em>, each of which is one trillionth of a farad). A typical pullup resistor on the I<sup>2</sup>C bus is between 1 kΩ and 10 kΩ. This produces rise times in the range of 0.4 μsec (<em>microseconds</em>) to 4 μsec. If the I<sup>2</sup>C bus is operating at 100 kHz (that is, a 10-μsec period), a 10-kΩ pullup (4-μsec rise time) will likely not work out well. The solution is to reduce the capacitance or the resistance. </p>&#13;
<p>The primary way to reduce bus capacitance is to keep the bus as short as possible. Longer bus lines dramatically increase the bus capacitance. You can also reduce bus capacitance by putting fewer I<sup>2</sup>C devices on the bus. If you must put a fixed number of devices on the bus, you can reduce the number of devices on a given bus by using two separate buses.</p>&#13;
<p>Of course, another solution to reducing the rise time is to reduce the value of the pullup resistor. Using a 4.7-kΩ resistor rather than a 10-kΩ resistor, for example, cuts the rise time by about one half.</p>&#13;
<h3 id="h2-502468c01-0002">1.5.1	What If the Bus Capacitance Is Too High?</h3>&#13;
<p class="BodyFirst">Reducing bus capacitance can be a difficult process. Shortening the I<sup>2</sup>C bus length is the primary approach. You can also use better cabling if the I<sup>2</sup>C signals are transmitted across wires, or you can reduce the number of devices on the bus (for example, move half the devices to a second I<sup>2</sup>C bus). </p>&#13;
<p>If these solutions are impossible or insufficient, reduce the bus speed. If you’re running at 400 kHz, drop down to 100 kHz; if you’re already at 100 kHz, drop down to 50 kHz, and so on. If this doesn’t solve the problem, a major circuit redesign may be necessary. Another solution to consider at this point is a differential bus driver like the SparkFun QwiicBus Kit: <a class="LinkURL" href="https://www.sparkfun.com/products/17250">https://www.sparkfun.com/products/17250</a>. </p>&#13;
<h2 id="h1-502468c01-0006">	1.6	I<sup>2</sup>C Bus Speeds</h2>&#13;
<p class="BodyFirst">As discussed, the I<sup>2</sup>C bus has two signal lines: serial data and serial clock. Controllers transmit data to and from peripherals on the SDA line. The SCL line controls the speed at which this serial data transfer takes place. The frequency of the signal on the SCL line controls how fast data moves between the controller and peripheral devices. The I<sup>2</sup>C bus standard defines the following data transfer rates:</p>&#13;
<ul>&#13;
<li><em>Standard mode</em>: 100-kHz SCL frequency, transferring data between devices at 100 kbit/sec </li>&#13;
<li><em>Fast mode</em>: 400-kHz SCL frequency, transferring data between the controller and peripherals at 400 kbit/sec</li>&#13;
<li><em>Fast mode plus</em>: 1-MHz SCL frequency, transferring data between the controller and peripherals at 1 Mbit/sec</li>&#13;
<li><span epub:type="pagebreak" id="Page_10" title="10"/><em>High-speed mode</em>: Up to 3.4-MHz SCL frequency, transferring data between the controller and peripherals at up to 3.4 Mbit/sec</li>&#13;
<li><em>Ultra-fast mode</em>: 5-MHz SCL frequency, though data transmission is unidirectional only</li>&#13;
</ul>&#13;
<p>In practice, the upper bound on the I<sup>2</sup>C bus frequency is largely determined by the bus capacitance pullup resistors on the bus. However, there generally isn’t a lower bound on the frequency. Indeed, many peripheral devices will actually freeze data transmission using <em>clock stretching</em> (see section 1.9, “Clock Stretching,” later in this chapter) to provide the peripheral time to process data coming from the controller, which effectively reduces the clock speed and average data transmission speed. Furthermore, there is no requirement that the controller device place a 100-kHz signal (or whatever frequency) on the SCL line. It could run SCL at 50 kHz or any other frequency less than the usual clock speed, if desired. </p>&#13;
<p>The SCL signal is <em>not</em> a free-running clock. The I<sup>2</sup>C controller explicitly toggles this line when it shifts a bit onto the SDA line. When the controller is not transmitting or receiving data on the SDA line, the controller leaves the SCL line programmed high. The I<sup>2</sup>C bus frequency, therefore, is the SCL frequency during data transactions on the I<sup>2</sup>C bus.</p>&#13;
<p>Probably the main limitation on the I<sup>2</sup>C bus speed is that you have to run the bus at the speed of the slowest devices on the bus. If there is a 100-kbit/sec peripheral on the bus, you must run the bus at 100 kHz, even when communicating with 400-kbit/sec (or faster) peripherals on the same bus. Because most I<sup>2</sup>C-compatible ICs are 100- or 400-kbit/sec devices, systems rarely run the I<sup>2</sup>C bus above 400 kHz except for some very special hardware-specific cases. Typically, if you want to run above 400 kHz, you switch to the SPI bus.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">Note</span></h2>&#13;
<p>	This book will mainly stick to standard and fast mode I<sup>2</sup>C bus operation. In theory, this material also covers fast mode plus operation, as it is nearly the same as fast mode with tighter hardware specifications. High-speed mode and ultra-fast mode require special hardware to implement. See the I<sup>2</sup>C Bus Specification and User Manual for more information about these two modes, via the link provided in “For More Information.”</p>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="h1-502468c01-0007">	1.7	Multicontroller I<sup>2</sup>C Bus Clock Synchronization</h2>&#13;
<p class="BodyFirst">The I<sup>2</sup>C bus optionally supports multiple controllers on the same bus, which is known as a <em>multicontroller</em> <em>configuration</em>. In such cases the SCL frequencies of the two controllers must match, and they must both support multicontroller operation. However, running at the same frequency is not a sufficient condition for a multicontroller environment; their clocks must also be synchronized. Two controllers operate asynchronously with respect to one other. That is, if the bus is currently not being used by either controller, both controllers could decide to use the bus at the same time. However, it’s unlikely that both controllers will decide to activate their SCL lines at <span epub:type="pagebreak" id="Page_11" title="11"/>exactly the same instant. The I<sup>2</sup>C protocol requires the two controllers’ clock signals to rise and fall at roughly the same time to maintain appropriate timing. To achieve this, the I<sup>2</sup>C protocol introduces a clock synchronization operation that delays the start of one of the signals so they rise and fall approximately together after the synchronization operation.</p>&#13;
<p>Clock synchronization relies on a feature of an open-drain bus known as <em>wired-AND operation</em> that simulates a logical-AND circuit without additional hardware. The (two-input) logical-AND function produces a true result if and only if its two inputs are true. If either or both are false, the logical-AND function produces a false result. If you consider two open-drain devices connected to the SCL line, the result is equivalent to a logical-AND circuit. If both devices are programmed with a 1, so their outputs are in a high-impedance state, the pullup resistor on the SCL line pulls the bus high. If either or both devices are programmed such that the open-drain output is active, this pulls the SCL line to Gnd, resulting in a 0 on the SCL line.</p>&#13;
<p>Clock synchronization uses the wired-AND capabilities of the bus to synchronize the two clocks between controllers competing for the bus. The first controller to pull the SCL line low begins counting off its low period, approximately one half of the clock period. Sometime later (still within the low period), the second controller pulls the SCL line low. When the first controller reaches the end of its low period, it releases the SCL line. However, as the second controller is still pulling the SCL line low, it remains low. Later, when the second controller releases the SCL line, it goes high since both controllers have released the SCL line, as shown in <a href="#figure1-2" id="figureanchor1-2">Figure 1-2</a>.</p>&#13;
<figure>&#13;
<img alt="" class="" height="290" src="image_fi/502468c01/f01002.png" width="520"/>&#13;
<figcaption><p><a id="figure1-2">Figure 1-2</a>: SCL driven low by multiple controllers</p></figcaption>&#13;
</figure>&#13;
<p>The first controller should note that the SCL line has not gone high and will delay counting off a one-half clock period (with SCL high, its <em>high period</em>) until it notices that the SCL line has actually gone high, as shown in <a href="#figure1-3" id="figureanchor1-3">Figure 1-3</a>. Then both controllers will start counting off the high period with the SCL line high. The first to count off the one-half clock period will pull the SCL line low; the second should follow shortly. </p>&#13;
<span epub:type="pagebreak" id="Page_12" title="12"/><figure>&#13;
<img alt="" class="" height="273" src="image_fi/502468c01/f01003.png" width="587"/>&#13;
<figcaption><p><a id="figure1-3">Figure 1-3</a>: SCL clock synchronization by multiple controllers</p></figcaption>&#13;
</figure>&#13;
<p>At this point, the clocks should be fairly synchronized, with the low SCL period being the longest of the two controllers and the high SCL period being the shortest of the two. The two controllers will have similar, but not perfectly identical, timing for their clock periods.</p>&#13;
<h2 id="h1-502468c01-0008">	1.8	Multicontroller I<sup>2</sup>C Bus Arbitration</h2>&#13;
<p class="BodyFirst">Although synchronizing clocks is a necessary condition to allow multicontroller access to the I<sup>2</sup>C bus, it is not a sufficient condition. Even if two controllers have synchronized clocks, they could both be writing different data to the SDA line; that would corrupt the data on the bus and yield unreliable results. <em>Arbitration</em> is the process by which two (or more) controllers decide who can actually control the bus.</p>&#13;
<p>Before grabbing the I<sup>2</sup>C bus for its own use, a controller first checks to see if the bus is already in use. It does this by looking at the SDA and SCL lines for more than one half of a clock period and verifying that both signals remain high during this time. If so, it emits an I<sup>2</sup>C bus <em>start sequence</em> (see Chapter 2) and begins transmitting data. </p>&#13;
<p>Of course, there is no guarantee that the bus is actually free after this sequence, because a second controller could have started this same process at almost the same time. Therefore, the data the two controllers are placing on the bus could be in conflict. To detect this problem, the I<sup>2</sup>C bus arbitration system takes advantage of the wired-AND operation of the bus. If both devices write a 1 to the SDA line or both devices write a 0 to SDA, this line will correctly reflect the data signals being written by both controllers. However, if one controller writes a 0 while the other writes a 1, the controller writing the 0 will “win the war” on the SDA line—that is, the SDA line will be pulled low. To handle bus arbitration, the two controllers always look at the data they write on the SDA line to verify it contains what they’ve written. If a controller writes a value to the bus and then reads back a different value, then the two controllers have lost the arbitration and must stop controlling the bus. </p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="note">&#13;
<span epub:type="pagebreak" id="Page_13" title="13"/><h2><span class="NoteHead">NOTE</span></h2>&#13;
<p>	In theory, two controllers could write the same data sequence to the bus, in which case they will both use the bus simultaneously. Unless the peripheral device is counting accesses, in which case these two controller activities would look like a single access, there is no reason this rare situation would create any problems.</p>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
<p>Note that while the controllers are checking the data on the SDA line, they are also looking at the information appearing on the SCL line to synchronize the clocks while arbitrating for the bus. </p>&#13;
<h2 id="h1-502468c01-0009">	1.9	Clock Stretching</h2>&#13;
<p class="BodyFirst">Clock signals are always generated by controller devices on the I<sup>2</sup>C bus. Controllers expect peripheral devices to operate properly at whatever clock frequency the controller signals on the SCL line. If the peripheral is incapable of operating at that frequency, the controller must be reprogrammed to talk to the peripheral at a lower clock speed.</p>&#13;
<p>As you’ll see in the next chapter, data communication on the I<sup>2</sup>C bus consists of a string of 8-bit bytes transmitted to a peripheral with the peripheral acknowledging each byte, using an <em>acknowledge bit</em>. When transmitting the acknowledge bit back to the controller, the peripheral has the option of holding the clock line inactive for an arbitrary period of time. As noted in a couple of earlier sections, this is known as <em>clock stretching </em>(see sections 1.6 and 1.1, “I<sup>2</sup>C Bus Speeds” and “I<sup>2</sup>C Overview,” respectively). It effectively pauses the controller while the peripheral deals with the data that was transmitted to it (that is, clock stretching adds wait states to the I<sup>2</sup>C clock).</p>&#13;
<p>As with arbitration and clock synchronization, clock stretching takes advantage of the wired-AND operation of the I<sup>2</sup>C bus. If the peripheral is pulling the SCL line low when the controller sets it high, the SCL line remains low. The controller looks for this behavior and pauses data and clock output until the peripheral releases the SCL line.</p>&#13;
<p>Clock stretching is an optional feature of the I<sup>2</sup>C protocol, meaning controllers don’t have to support this feature. Obviously, if a peripheral uses clock stretching, that device will be incompatible with controllers that don’t support this feature.</p>&#13;
<h2 id="h1-502468c01-0010">	1.10	Cross Talk</h2>&#13;
<p class="BodyFirst">Another problem that can befall I<sup>2</sup>C communications is cross talk. If you run the SDA and SCL lines in parallel, especially over a long distance, signal changes on one line can affect the other. The SCL line affecting the SDA line is the most common problem. To reduce the problem of cross talk, the simple solution is to run a ground trace between the SCL and SDA <span epub:type="pagebreak" id="Page_14" title="14"/>lines on a PCB. Likewise, on a ribbon cable, running a ground line—or better yet, a power and a ground line—between the SDA and SCL conductors can reduce the incidence of cross talk.</p>&#13;
<p>Although cross talk between the SCL and SDA lines represents the most common cross talk problems on the I<sup>2</sup>C bus, keep in mind that other signals can also induce noise on these two signal lines. When laying out PCBs, try to keep other high-frequency or high-current lines away from the SDA and SCL traces. Following good PCB design rules can really help. Likewise, when running I<sup>2</sup>C signals or ribbon cables (or other wiring), interleaving a ground wire between the SDA and SCL signals can reduce noise in the system.</p>&#13;
<p>One solution to the cross talk problem is to use differential line drivers on the I<sup>2</sup>C. SparkFun provides the QwiicBus Kit to solve cross talk and other issues with bus length. See “For More Information.”</p>&#13;
<h2 id="h1-502468c01-0011">	1.11	Chapter Summary</h2>&#13;
<p class="BodyFirst">In this chapter, you learned that the I<sup>2</sup>C bus solves several problems that designers of early embedded systems encountered when adding I/O to their designs. The two-wire (serial data and clock) interface reduces PCB size, noise, and design effort. The I<sup>2</sup>C bus features the following specifications:</p>&#13;
<ul>&#13;
<li>Open-drain (open-collector) bus signals allowing multiple controllers and bidirectional communication on a single data line</li>&#13;
<li>100-kHz, 400-kHz, 1-MHz, 3.4 MHz, and 5-MHz bus speeds</li>&#13;
<li>2 V to 5 V operation (via pullup resistors)</li>&#13;
<li>Bus arbitration and clock stretching to resolve timing issues</li>&#13;
<li>A wide variety of I<sup>2</sup>C peripheral ICs that can be connected to any I<sup>2</sup>C bus</li>&#13;
</ul>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="box">&#13;
<h2>For More Information</h2>&#13;
<ol class="none">&#13;
<li><em>UM10204 I</em><sup>2</sup><em>C Bus Specification and User Manual</em>: <a class="LinkURL" href="https://www.nxp.com/docs/en/user-guide/UM10204.pdf">https://www.nxp.com/docs/en/user-guide/UM10204.pdf</a></li>&#13;
<li>The I<sup>2</sup>C Bus: <a class="LinkURL" href="https://www.i2c-bus.org">https://www.i2c-bus.org</a></li>&#13;
<li>Level-shifting the I<sup>2</sup>C bus: <a class="LinkURL" href="https://cdn-shop.adafruit.com/datasheets/AN10441.pdf">https://cdn-shop.adafruit.com/datasheets/AN10441.pdf</a></li>&#13;
<li>I<sup>2</sup>C voltage translator FETs: <a class="LinkURL" href="https://www.nxp.com/products/interfaces/ic-spi-serial-interface-devices/ic-voltage-level-translators:MC_43683">https://www.nxp.com/products/interfaces/ic-spi-serial-interface-devices/ic-voltage-level-translators:MC_43683</a></li>&#13;
<li>Adafruit bidirectional level-shifter breakout boards: <a class="LinkURL" href="https://www.adafruit.com/product/757">https://www.adafruit.com/product/757</a></li>&#13;
<li>SparkFun Qwiic bus differential line drivers: <a class="LinkURL" href="https://www.sparkfun.com/products/17250">https://www.sparkfun.com/products/17250</a></li>&#13;
</ol>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
</section>&#13;
</div>&#13;
</body></html>