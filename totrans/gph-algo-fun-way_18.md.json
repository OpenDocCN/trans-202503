["```\nclass CapacityEdge: \n    def __init__(self, from_node: int, to_node: int, capacity: float):\n        self.from_node: int = from_node\n        self.to_node: int = to_node\n        self.capacity: float = capacity\n      ❶ self.used: float = 0.0\n\n    def adjust_used(self, amount: float): \n      ❷ if self.used + amount < 0.0 or self.used + amount > self.capacity:\n            raise Exception(\"Capacity Error\")\n        self.used += amount\n\n    def capacity_left(self) -> float: \n        return self.capacity - self.used\n\n    def flow_used(self) -> float: \n        return self.used \n```", "```\nclass ResidualGraph: \n    def __init__(self, num_nodes: int, source_index: int, sink_index: int):\n        self.num_nodes: int = num_nodes\n        self.source_index: int = source_index\n        self.sink_index: int = sink_index\n        self.edges: list = [{} for _ in range(num_nodes)]\n        self.all_neighbors: list = [set() for _ in range(num_nodes)]\n\n    def get_edge(self, from_node: int, to_node: int) -> Union[CapacityEdge,\n                                                              None]: \n        if from_node < 0 or from_node >= self.num_nodes:\n            raise IndexError\n        if to_node < 0 or to_node >= self.num_nodes:\n            raise IndexError\n        if to_node in self.edges[from_node]:\n            return self.edges[from_node][to_node]\n        return None\n\n    def insert_edge(self, from_node: int, to_node: int, capacity: float): \n      ❶ if from_node < 0 or from_node >= self.num_nodes:\n            raise IndexError\n        if to_node < 0 or to_node >= self.num_nodes:\n            raise IndexError\n\n      ❷ if from_node == self.sink_index:\n            raise ValueError(\"Tried to insert edge FROM sink node.\")\n        if to_node == self.source_index:\n            raise ValueError(\"Tried to insert edge TO source node.\")\n        if from_node in self.edges[to_node]:\n            raise ValueError(f\"Tried to insert edge {from_node}->{to_node}, \"\n                             f\"edge {to_node}->{from_node} already exists.\")\n        if capacity <= 0:\n            raise ValueError(f\"Tried to insert capacity {capacity}\")\n\n      ❸ self.edges[from_node][to_node] = CapacityEdge(from_node, to_node,\n                                                      capacity) ❹ self.all_neighbors[from_node].add(to_node)\n        self.all_neighbors[to_node].add(from_node)\n\n    def compute_total_flow(self) -> float: \n        total_flow: float = 0.0\n        for to_node in self.edges[self.source_index]:\n            total_flow += self.edges[self.source_index][to_node].flow_used()\n        return total_flow \n```", "```\ndef get_residual(self, from_node: int, to_node: int) -> float: \n  ❶ if to_node not in self.all_neighbors[from_node]:\n        return 0\n\n  ❷ if to_node in self.edges[from_node]:\n        return self.edges[from_node][to_node].capacity_left()\n    else:\n        return self.edges[to_node][from_node].flow_used() \n```", "```\ndef find_augmenting_path_dfs(g: ResidualGraph) -> list: \n    seen: list = [False] * g.num_nodes\n    last: list = [-1] * g.num_nodes\n    augmenting_path_dfs_recursive(g, g.source_index, seen, last)\n    return last\n\ndef augmenting_path_dfs_recursive(g: ResidualGraph, current: int,\n                                  seen: list, last: list): \n    seen[current] = True\n    for n in g.all_neighbors[current]:\n      ❶ if not seen[n] and g.get_residual(current, n) > 0:\n            last[n] = current\n          ❷ if last[g.sink_index] != -1:\n                return\n            augmenting_path_dfs_recursive(g, n, seen, last) \n```", "```\ndef min_residual_on_path(self, last: list) -> float: \n    min_val: float = math.inf\n\n    current: int = self.sink_index\n  ❶ while current != self.source_index:\n        prev: int = last[current]\n        if prev == -1:\n            raise ValueError\n        min_val = min(min_val, self.get_residual(prev, current))\n      ❷ current = prev\n    return min_val \n```", "```\ndef update_along_path(self, last: list, amount: float): \n    current: int = self.sink_index\n  ❶ while current != self.source_index:\n        prev: int = last[current]\n        if prev == -1:\n            raise ValueError\n\n      ❷ if current in self.edges[prev]:\n            self.edges[prev][current].adjust_used(amount) else:\n            self.edges[current][prev].adjust_used(-amount)\n        current = prev \n```", "```\ndef ford_fulkerson(g: Graph, source: int, sink: int) -> ResidualGraph: \n  ❶ residual: ResidualGraph = ResidualGraph(g.num_nodes, source, sink)\n    for node in g.nodes:\n        for edge in node.edges.values():\n            residual.insert_edge(edge.from_node, edge.to_node, edge.weight)\n\n  ❷ done = False\n    while not done:\n      ❸ last: list = find_augmenting_path_dfs(residual)\n      ❹ if last[sink] > -1:\n            min_value: float = residual.min_residual_on_path(last)\n            residual.update_along_path(last, min_value)\n        else:\n            done = True\n\n    return residual \n```", "```\ndef find_augmenting_path_bfs(g: ResidualGraph) -> list: \n    seen: list = [False] * g.num_nodes\n    last: list = [-1] * g.num_nodes\n    pending: queue.Queue = queue.Queue() ❶ seen[g.source_index] = True\n    pending.put(g.source_index)\n  ❷ while not pending.empty() and not seen[g.sink_index]:\n        current: int = pending.get()\n        for n in g.all_neighbors[current]:\n          ❸ if not seen[n] and g.get_residual(current, n) > 0:\n              ❹ pending.put(n)\n                seen[n] = True\n                last[n] = current\n\n    return last \n```", "```\ndef edmonds_karp(g: Graph, source: int, sink: int) -> ResidualGraph: \n    residual: ResidualGraph = ResidualGraph(g.num_nodes, source, sink)\n    for node in g.nodes:\n        for edge in node.edges.values():\n            residual.insert_edge(edge.from_node, edge.to_node, edge.weight)\n\n    done = False\n    while not done:\n      ❶ last: list = find_augmenting_path_bfs(residual)\n        if last[sink] > -1:\n            min_value: float = residual.min_residual_on_path(last)\n            residual.update_along_path(last, min_value)\n        else:\n            done = True\n    return residual \n```", "```\ndef augment_multisource_graph(g: Graph, sources: list) -> int: \n  ❶ new_source: Node = g.insert_node()\n\n  ❷ for old_source in sources:\n        g.insert_edge(new_source.index, old_source, math.inf)\n    return new_source.index \n```", "```\ndef augment_multisink_graph(g: Graph, sinks: list) -> int: \n    new_sink: Node = g.insert_node()\n\n    for old_sink in sinks:\n        g.insert_edge(old_sink, new_sink.index, math.inf)\n    return new_sink.index \n```"]