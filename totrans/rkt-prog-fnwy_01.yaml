- en: '1'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RACKET BASICS
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let’s begin with an introduction to some basic concepts in Racket. In this chapter,
    we’ll cover some of the fundamental data types that will be used throughout the
    book. You’ll want to pay particular attention to the discussion of lists, which
    underpin much of Racket’s functionality. We’ll also cover how to assign values
    to variables and various ways to manipulate strings, and along the way, you’ll
    encounter a first look at vectors and structs. The chapter wraps up with a discussion
    on how to produce formatted output.
  prefs: []
  type: TYPE_NORMAL
- en: Atomic Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Atomic data* is the basic building block of any programming language, and
    Racket is no exception. Atomic data refers to elementary data types that are typically
    considered to be indivisible entities; that is, numbers like `123`, strings like
    `"hello there"`, and identifiers such as `pi`. Numbers and strings evaluate to
    themselves; if bound, identifiers evaluate to their associated value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Evaluating an unbound identifier results in an error. To prevent an unbound
    identifier from being evaluated, you can prefix it with an apostrophe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We can organize atomic data together using lists, which are covered next.
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Racket, lists are the primary non-atomic data structures (that is, something
    other than a number, string, and so on). Racket relies heavily on lists because
    it’s a descendant of *Lisp* (short for LISt Processing). Before we get into the
    details, let’s look at some simple representative samples.
  prefs: []
  type: TYPE_NORMAL
- en: '***A First Look at Lists***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here’s how to make a list with some numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Notice the syntax. Lists typically begin with an open parenthesis, `(`, followed
    by a list of space-separated items and end with a closed parenthesis, `)`. The
    first item in the list is normally an identifier that indicates how the list is
    to be evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: Lists can also contain other lists.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: which prints as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the apostrophe (or tick mark) at the beginning of the last example. This
    is an alias for the `quote` keyword. If you want to enter a literal list (a list
    that is simply accepted as is), you can enter it *quoted*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Either of which print as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: While `list` and `quote` seem like two equivalent ways to build lists, there’s
    an important difference between them. The following sequence illustrates the difference.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notice that `quote` returns the list exactly as it was entered, but when `list`
    was used, the identifier `pi` was evaluated and its value was substituted in its
    place. In general, in a non-quoted list, *all* identifiers are evaluated and replaced
    by their associated values. The keyword `quote` plays an important role in macros
    and symbolic expression evaluation, which are advanced topics that we will not
    cover in this text.
  prefs: []
  type: TYPE_NORMAL
- en: One criticism of the Lisp family of languages is the proliferation of parentheses.
    To alleviate this, Racket allows either square brackets or curly brackets to be
    used instead. For example, it’s perfectly acceptable to write the last expression
    as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '***S-Expressions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A list is a special case of something called an *s-expression*. An s-expression
    (or symbolic expression) is defined as being one of two cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Case 1** The s-expression is an atom.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Case 2** The s-expression is expression of the form `(x . y)` where *x* and
    *y* are other s-expressions.'
  prefs: []
  type: TYPE_NORMAL
- en: The form `(x . y)` is typically called a *pair*. This is a special syntactic
    form used to designate a *cons* cell, which we will have much more to say about
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see if we can construct a few examples of s-expressions. Ah, how about
    `1`? Yes, it’s an atom, so it satisfies case 1\. What about `"spud"`? Yep, strings
    are atoms, and thus `"spud"` is also an s-expression. We can combine these to
    make another s-expression: `(1 . "spud")`, which satisfies case 2\. Since `(1
    . "spud")` is an s-expression, case 2 allows us to form another s-expression as
    `((1 . "spud") . (1 . "spud"))`. We can see from this that s-expressions are actually
    tree-like structures as illustrated in [Figure 1-1](ch01.xhtml#ch1fig1). (Technically
    s-expressions form a *binary tree*, where non-leaf nodes have exactly two child
    nodes).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/01fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-1: `((a . (2 . pi) . x))`*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 1-1](ch01.xhtml#ch1fig1), the square boxes are leaf nodes representing
    atoms, and the circle nodes represent pairs. We’ll see how s-expressions are used
    to construct lists in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '***List Structure***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As mentioned above, a list is a special case of an s-expression. The difference
    is that, in a list, if we follow the rightmost elements in each pair, the final
    node is a special atomic node called *nil*. [Figure 1-2](ch01.xhtml#ch1fig2) illustrates
    what the list ’`(1 2 3)`—which as an s-expression is `(1 . (2 . (3 . nil)))`—looks
    like internally.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/01fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-2: List structure*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve flattened the tree to better resemble a list. We’ve also expanded each
    pair node (aka a *cons cell*) to show that it consists of two cells, each of which
    contains a pointer to another node. These pointer cells, for historical reasons,
    are called *car* and *cdr* respectively (the names of computer registers used
    in early versions of Lisp). We can see that the last cdr cell in the list is pointing
    to nil. Nil is indicated in Racket by an empty list: ’`()` or `null`.'
  prefs: []
  type: TYPE_NORMAL
- en: Cons cells can be created directly by using the `cons` function. Note that the
    `cons` function does not necessarily create a list. For example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: produces a pair but *not* a list. However, if we use an empty list as our second
    s-expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: we produce a list with just one element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Racket provides a couple of functions to test whether something is a list or
    a pair. Note in Racket `#t` means true and `#f` means false:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'From this we can see that a list is always a pair, but the converse is not
    always true: a pair is not always a list.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, `cons` is used to add an atomic value to the beginning of a list,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Racket provides special functions to access the components of a cons cell. The
    function `car` returns the item being pointed to by the car pointer, and correspondingly
    the `cdr` function returns the item being pointed to by the cdr pointer. In Racket
    the functions `first` and `rest` are similar to `car` and `cdr` but are not aliases
    for these functions, since they only work with lists. A few examples are given
    below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: List elements can also be accessed with the functions `second`, `third`, . .
    . , `tenth`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Finally, a value at any position can be extracted by using `list-ref`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `list-ref` function takes a list and the index of the value you want, with
    the list coming first. Notice that Racket uses *zero-based indexes*, meaning for
    any sequence of values, the first value has an index of 0, the second value has
    an index of 1, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '***A Few Useful List Functions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s quickly go through a number of useful list functions.
  prefs: []
  type: TYPE_NORMAL
- en: '**length**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To get the length of a list, you can use the `length` function, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '**reverse**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you need the elements in a list reversed, you can use the `reverse` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '**sort**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `sort` function will sort a list. You can pass in `<` to sort the list
    in ascending order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if you pass in `>`, it will sort the list in descending order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '**append**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To merge two lists together, you can use the `append` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `append` function can take more than two lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '**range**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `range` function will create a list of numbers given some specifications.
    You can pass a start value and an end value, as well as a step to increment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if you just pass an end value, it will start at 0 with a step of 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '**make-list**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Another way to make lists is using the `make-list` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `make-list` takes a number and a value, and makes a list that
    contains that value repeated that number of times.
  prefs: []
  type: TYPE_NORMAL
- en: '**null?**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To test whether a list is empty or not, you can use the `null?` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '**index-of**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If you need to search a list for a value, you can use `index-of`. It’ll return
    the index of the value if it appears:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'It’ll return `#f` if it doesn’t:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '**member**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Another way to search lists is to use `member`, which tests whether a list contains
    an instance of a particular element. It returns the symbol `#f` if it does not,
    and returns the tail of the list starting with the first instance of the matching
    element if it does.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Notice that in the last instance, even though 6 is a member of a sublist of
    the searched list, the `member` function still returns false. However, the following
    does work.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: You’ll see later that in functional programming, you often need to determine
    whether an item is contained in a list. The `member` function not only finds the
    item (if it exists) but returns the actual value so that it can be used in further
    computations.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll have much more to say about lists in the remainder of this text.
  prefs: []
  type: TYPE_NORMAL
- en: Defines, Assigns, and Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Thus far, we’ve seen a few examples of a *function*, something that takes one
    or more input values and provides an output value (some form of data). The first
    element in a function-call expression is an identifier (the function name). The
    remaining elements in a function form are the arguments to the function. These
    elements are each evaluated and then fed to the function, which performs some
    operation on its arguments and returns a value.
  prefs: []
  type: TYPE_NORMAL
- en: More specifically, a *form* or *expression* may define a function, execute a
    function call, or simply return a structure (normally a list), and may or may
    not evaluate all its arguments. Notice that `quote` is a different type of form
    (distinct from a function form, which evaluates its arguments) since it *does
    not* first evaluate its arguments. In the next section you’ll meet `define`, which
    is yet another type of form since it does not evaluate its first argument, but
    it does evaluate its second argument. We will meet many other types of forms as
    we progress through the text.
  prefs: []
  type: TYPE_NORMAL
- en: 'A *variable* is a placeholder for a value. In Racket, variables are specified
    by *identifiers* (specific sequences of characters) associated with one thing
    only. (We’ll have more to say about what constitutes a valid identifier shortly.)
    To define a variable, you use the `define` form. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here `define` is said to *bind* the value `123` to the identifier `a`. Virtually
    anything can be bound to a variable. Here we’ll bind a list to the identifier
    `b`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s possible to bind several variables in parallel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Racket makes a distinction between *defining* a variable and *assigning* a
    value to a variable. Assignments are made with a `set!` expression. Typically
    any form which changes, or *mutates*, a value will end with an exclamation point.
    Attempting to assign to an identifier that hasn’t been previously defined will
    result in an ugly error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'But this is okay:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: One way to think of this is that `define` sets up a location to store a value,
    and `set!` simply places a new value in a previously defined location.
  prefs: []
  type: TYPE_NORMAL
- en: When we speak of a variable *x* that is defined in Racket code, it will be typeset
    as `x`. If we’re simply speaking of the variable in the mathematical sense, it
    will be typeset in italics as *x*.
  prefs: []
  type: TYPE_NORMAL
- en: Symbols, Identifiers, and Keywords
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Unlike most languages, Racket allows just about any string of characters to
    be used as an identifier. For example we can use `2x3` as an identifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: You could conceivably define a function literally called `rags->riches` that
    would convert rags to riches (let me know when you get that working). All this
    seems quite bizarre, but it lends Racket an expressive power not found in many
    other computer languages. There are of course some restrictions to this, but aside
    from a few special characters such as parentheses, brackets, and arithmetic operators
    (even these are usually okay if they aren’t the first character), just about anything
    goes. In fact it’s common to see identifiers containing dashes, as in `solve-for-x`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A *symbol* is essentially just a quoted identifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: They are sort of a second-rate string (more on strings below). They are typically
    used much like an `enum` in other programming languages where they’re used to
    stand for a specific value.
  prefs: []
  type: TYPE_NORMAL
- en: 'A *keyword* is an identifier prefixed with #`:`. Keywords are mainly used to
    identify optional arguments in function calls. Here’s an example of a function
    (˜`r`) that uses a keyword to output *π* as a string with two decimal places of
    accuracy.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here we define the optional `precision` argument to specify that the value of
    `pi` should be rounded to two decimal places.
  prefs: []
  type: TYPE_NORMAL
- en: Equality
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Racket defines two different kinds of equality: things that look exactly alike
    and things that are the same thing. Here’s the difference. Suppose we make the
    following two definitions.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Identifiers `a` and `b` look exactly alike, and if we ask Racket if they are
    the same with the `equal?` predicate, it will respond that they are the same.
    Note a *predicate* is a function that returns a Boolean value of true or false.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: But if we ask whether they are the same thing by using the `eq?` predicate,
    we get a different answer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: So when does `eq?` return true? Here’s an example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In this case we have bound `x` to the list ’`(1 2 3)`. We then bind `y` to the
    same value *location* that `x` is bound to, effectively making `x` and `y` be
    bound to the same thing. The difference is subtle, but important. In most cases
    `equal?` is what you need, but there are scenarios where `eq?` is used to ensure
    that variables are bound to the same object and not just to things that *look*
    the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'One other nuance of equality that must be discussed is numeric equality. In
    the discussion above, we were focused on structural equality. Numbers are a different
    animal. We’ll have much more to say about numbers in the next chapter, but we
    need to clarify a few things about numbers that relate to equality. Examine the
    following sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Above we bound `a` and `b` to identical lists ’`(1 2 3)`, and in that case
    `eq?` returned false. In this case we bound `a` and `b` to the identical number
    `123`, and `eq?` returned true. Numbers (technically *fixnums*, that is, small
    integers that fit into a fixed amount of storage—typically 32 or 64 bits, depending
    on your computing platform) are unique in this sense. There is only one instance
    of every number, no matter how many different identifiers it is bound to. In other
    words, each number is stored in one and only one location. Furthermore, there’s
    a special predicate (=) that can only be used with numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In this section we only cover equality in general. We’ll look at more specifics
    on numerical comparisons in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Strings and Things
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we’ll look at different ways of handling text values in Racket.
    We’ll begin with the simplest kind of text value.
  prefs: []
  type: TYPE_NORMAL
- en: '***Characters***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Individual text values, like single letters, are represented using a *character*,
    a special entity that corresponds to a *Unicode* value. For example, the letter
    A corresponds to the Unicode value 65\. Unicode values are usually specified in
    hexadecimal, so the Unicode value for A is 65[10] = 0041[16]. Character values
    either start with #\ followed by a literal keyboard character or #\`u` followed
    by a Unicode value.'
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a sampling of the multiple ways to write a character using character
    functions. Notice the use of the comment character (`;`), which allows comments
    (non-compiled text) to be added to Racket code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Unicode supports a wide range of characters. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Most Unicode characters should print fine, but this depends to some extent on
    the fonts available on your computer.
  prefs: []
  type: TYPE_NORMAL
- en: '**Strings**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A *string* typically consists of a sequence of keyboard characters surrounded
    by double-quote characters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Unicode characters can be embedded in a string, but in this case, the leading
    `#` is left off.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: You can also use `string-append` on two strings to create a new string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'To access a character within a string, use `string-ref`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The position of each character in a string is numbered starting from 0, so in
    this example using an index of 2 actually returns the third character.
  prefs: []
  type: TYPE_NORMAL
- en: The strings we have seen so far are immutable. To create a mutable string, use
    the `string` function. This allows changing characters in the string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Note that for mutable strings we have to define the string using individual
    characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to create a mutable string is with `string-copy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use `make-string` to do the same thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Depending on what’s needed, any one of the above may be preferred. If you need
    to make an existing string mutable, `string-copy` is the obvious choice. If you
    only want a string of spaces, `make-string` is the clear winner.
  prefs: []
  type: TYPE_NORMAL
- en: '***Useful String Functions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are of course a number of other useful string functions, a few of which
    we illustrate next.
  prefs: []
  type: TYPE_NORMAL
- en: '**string-length**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `string-length` function outputs the number of characters in a string (see
    `wishy-washy` earlier in [“Strings” on page 14](ch01.xhtml#ch00lev2sec_10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '**substring**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `substring` function extracts a substring from a given string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '**string-titlecase**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Use `string-titlecase` to capitalize the first character of each word in a string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '**string-upcase**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To output a string in all caps, use `string-upcase`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '**string-downcase**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Conversely, for a lowercase string, use `string-downcase`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '**string<=?**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To perform an alphabetical comparison, use the `string<=?` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '**string=?**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `string=?` function tests whether two strings are equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '**string-replace**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `string-replace` function replaces part of a string with another string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '**string-contains?**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To test whether one string is contained within another, use `string-contains?`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '**string-split**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `string-split` function can be used to split a string into tokens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the first example above uses the default version that splits on
    spaces whereas the second version explictly uses a comma (,).
  prefs: []
  type: TYPE_NORMAL
- en: '**string-trim**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `string-trim` function gets rid of any leading and/or trailing spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Notice in the last two versions, `#:left?` or `#:right?` is used to suppress
    trimming the corresponding side. The final `#f` argument (the default) is used
    to specify that only one match is removed from each side; otherwise all initial
    or trailing matches are trimmed.
  prefs: []
  type: TYPE_NORMAL
- en: For more advanced string functionality, see [“Regular Expressions” on page 279](ch10.xhtml#ch00lev2sec_75).
  prefs: []
  type: TYPE_NORMAL
- en: '***String Conversion and Formatting Functions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are a number of functions that convert values to and from strings. They
    all have intuitive names and are illustrated below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: For a complete list of these, go to [*https://docs.racket-lang.org/reference/strings.html*](https://docs.racket-lang.org/reference/strings.html).
  prefs: []
  type: TYPE_NORMAL
- en: A handy function to embed other values within a string is `format`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Within the format statement, ˜`a` acts as a placeholder. There should be one
    placeholder for each additional argument. Note that the number 2 is automatically
    converted to a string before it’s embedded in the output string.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to simply convert a number to a string, use the `number->string`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Conversely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Trying to get Racket to translate the value of words into numbers, however,
    will not work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'For more control we can use the ˜`r` function, defined in the *racket/format*
    library, which has many options that can be used to convert a number to a string
    and control the precision and other output characteristics of the number. For
    example, to show *π* to four decimal places, we would use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'To show this right-justified, in a field 20 characters wide, and left padded
    with periods, we execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Additional info on ˜`r` is available in Appendix A, which talks about number
    bases. There are a number of other useful tilde-prefixed string conversion functions
    available, such as ˜`a`, ˜`v`, and ˜`s`. We won’t go into detail here, but you
    can consult the Racket Documentation for details: [*https://docs.racket-lang.org/reference/strings.html*](https://docs.racket-lang.org/reference/strings.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Vectors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Vectors bear a superficial resemblance to lists, but they are quite different.
    In contrast to the internal tree structure of lists, *vectors* are a sequential
    array of cells (much like arrays in imperative languages) that directly contain
    values, as illustrated in [Figure 1-3](ch01.xhtml#ch1fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/01fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-3: Vector structure*'
  prefs: []
  type: TYPE_NORMAL
- en: Vectors can be entered using the `vector` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, vectors can be entered using `#` as follows (note that an unquoted
    `#` implies a quote):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s important to note that these methods are *not* equivalent. Here’s one
    reason why:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: In the first example, just as for `list`, `vector` first evaluates its arguments
    before forming the vector. In the last example, like `quote`, `#` does not evaluate
    its arguments. More importantly, `#` is an alias for `vector-immutable`, which
    leads to our next topic.
  prefs: []
  type: TYPE_NORMAL
- en: '***Accessing Vector Elements***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The function `vector-ref` is an indexing operator that returns an element of
    a vector. This function takes a vector as its first argument and an index as its
    second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'To assign a value to a vector cell, `vector-set!` is used. The `vector-set!`
    expression takes three arguments: a vector, an index, and a value to be assigned
    to the indexed position in the vector.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s try this a bit differently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that `#` is an alias for `vector-immutable`. What this means is that
    vectors created with `#` (or `vector-immutable`) are (drum roll . . . ) *immutable*:
    they cannot be changed or assigned new values. On the other hand, vectors created
    with `vector` are *mutable*, meaning that their cells can be modified.'
  prefs: []
  type: TYPE_NORMAL
- en: One advantage of vectors over lists is that elements of vectors can be accessed
    much faster than elements of lists. This is because to access the 100th element
    of a list, each cell of the list must be accessed sequentially to get to the 100th
    element. Conversely, with vectors, the 100th element can be accessed directly,
    without working through earlier cells. On the other hand, lists are quite flexible
    and can easily be extended as well as being used to represent other data structures
    like trees. They are the bread and butter of Racket (and all Lisp-based languages),
    so much of the functionality of the language depends on the list structure. Predictably,
    functions are provided to easily convert from one to the other.
  prefs: []
  type: TYPE_NORMAL
- en: '***Useful Vector Functions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**vector-length**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `vector-length` function returns the number of elements in a vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '**vector-sort**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `vector-sort` function sorts the elements of a vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: To whet your appetite for what’s to come later, `vector-sort` is a typical example
    of functional programming. The last argument actually evaluates a function that
    determines the direction of the sort.
  prefs: []
  type: TYPE_NORMAL
- en: '**vector->list**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `vector->list` function takes a vector and returns a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '**list->vector**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Conversely `list->vector` takes a list and returns a vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '**make-vector**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To create a mutable vector, use the `make-vector` form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '**vector-append**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To concatenate two vectors together, use `vector-append`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '**vector-member**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `vector-member` function returns the index to where an item is located
    in a vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: There are of course many other useful vector functions, and we will explore
    some of them in the chapters to come.
  prefs: []
  type: TYPE_NORMAL
- en: Using structs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To introduce the next Racket feature, let’s build an example program. Instead
    of keeping your checkbook transactions in a paper bankbook, you could create an
    electronic version using Racket. Typically such transactions have the following
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: Transaction date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Payee
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amount
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One way to keep track of these disparate pieces of information is in a Racket
    structure called a `struct`. A Racket `struct` is conceptually similar to a `struct`
    in languages such as C or C++. It’s a composite data structure that has a set
    of predefined fields. Before you can use a `struct`, you have to tell Racket what
    it looks like. For our bank transaction example, such a definition might look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of the components of a structure (`date`, `payee`, etc.) is called a *field*.
    Once we’ve defined our `transaction struct`, we can create one like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Racket automatically creates an *accessor method* for each of the fields in
    the structure. An accessor method returns the value of the field. They always
    begin with the name of the structure (in this case `transaction`), a hyphen, and
    then the name of the field.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose, however, that you made a mistake and determined that the check to
    John Doe should have been for $100.12 instead of $100.10 and try to correct it
    via `set-transaction-amount!`. Note the exclamation point: this is a signal that
    `set-transaction-amount!` is a *mutator*, that is, a method that modifies a field
    value). These mutators are generated when the struct is defined and typically
    start with `set` and end with `!`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Oops . . . Fields in a structure are immutable by default and hence do not export
    *mutators*. The way around this is to include the `#:mutable` keyword in the structure
    definition for any field that may need to be modified.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: If all the fields should be mutable, adding the `#:mutable` keyword after the
    field list will do the trick.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: While the accessor methods are sufficient for getting the value of a single
    field, they are a bit cumbersome for seeing all the values at once. Just entering
    the structure name does not yield much information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: To make your structure more transparent, include the `#:transparent` option
    in the `struct` definition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: There are additional useful options that can be applied when defining structures,
    but one that is of particular interest is `#:guard`. `#:guard` provides a mechanism
    to validate the fields when a structure is constructed. For instance, to ensure
    that negative check numbers are not used, we could do the following.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Don’t panic. We haven’t covered that funny-looking symbol (*λ*, or *lambda*)
    yet, but you should be able to get the gist of what’s going on. The `#:guard`
    expression is a function that takes one parameter for each field and one additional
    parameter that contains the structure name. In this case we’re only testing whether
    the check number is greater than zero. The `#:guard` expression must return the
    same number of values as the number of fields in the `struct`.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example we simply returned the same values that were entered,
    but suppose we had a variable that contained the last check number called `last-check`.
    In this case, we could enter a 0 for the check number and use the `#:guard` expression
    to plug in the next available number as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, non-zero check numbers are stored as the last check number,
    but if a zero is entered for the check number, the `struct` value gets generated
    with the next available number, which becomes the current value for `last-check`.
    The `cond` statement will be explained in more detail a bit later in the book,
    but its use here should be fairly clear: it’s a way to check multiple cases.'
  prefs: []
  type: TYPE_NORMAL
- en: Controlling Output
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the interactions pane, DrRacket immediately displays the output resulting
    from evaluating any expression. It’s often desirable to have some control over
    how the output is presented. This is especially important when the output is being
    generated by some function or method. Racket provides a number of mechanisms for
    generating formatted output. The main forms are `write`, `print`, and `display`.
    Each of these works in a slightly different way. The best way to illustrate this
    is with examples.
  prefs: []
  type: TYPE_NORMAL
- en: '**write**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `write` expression outputs in such a way that the output value forms a
    valid value that can be used in the input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '**display**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `display` expression is similar to `write`, but strings and character data
    types are written as raw strings and characters without any adornments such as
    quotation or tick marks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '**print**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `print` expression is also similar to `write`, but adds a bit more formatting
    to the output. The intent of `print` is to show an expression that would evaluate
    to the same value as the printed one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the rational value `1/2` is printed (more on rationals in the next
    chapter).
  prefs: []
  type: TYPE_NORMAL
- en: Each of these comes in a form that ends with `ln`. The only difference is that
    the ones that end with `ln` automatically print a new line at the end. Here are
    a couple of examples to highlight the difference.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'One very useful form is `printf`. The `printf` expression works much like the
    `format` function: it takes a format string as its first argument and any number
    of other values as its other argument. The format string uses ˜`a` as a placeholder.
    There must be one placeholder for each of the arguments after the format string.
    The format string is printed exactly as entered, with the exception that for each
    placeholder the corresponding argument is substituted. Here’s `printf` in action.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: There are additional format specifiers (see the Racket Documentation for details),
    but we’ll mostly be using `print` since it gives a better visual indication of
    the data type of the value being output.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we laid the groundwork for what’s to come. Most of the core
    data types have been introduced along with what are hopefully some helpful examples.
    By now you should be comfortable with basic Racket syntax and have a pretty good
    understanding of the structure of lists and how to manipulate them. The next chapter
    will take a detailed look at the various numeric data types provided by Racket.
  prefs: []
  type: TYPE_NORMAL
