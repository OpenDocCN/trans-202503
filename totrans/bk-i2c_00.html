<html><head></head><body>
<div id="sbo-rt-content"><section>&#13;
<header><h1 class="FrontmatterTitle" id="fm-502468f06-0001"><span epub:type="pagebreak" id="Page_xix" title="xix"/>Introduction</h1>&#13;
</header>&#13;
<figure class="opener">&#13;
<img alt="" height="203" src="image_fi/book_art/chapterart.png" width="203"/>&#13;
</figure>&#13;
<p class="ChapterIntro">Welcome to <em>The Book of I</em><sup><em>2</em></sup><em>C</em>. This book provides the resources you need to design and program systems using the Inter-Integrated Circuit Bus (IIC, I2C, or I<sup>2</sup>C), a serial protocol for connecting various integrated circuits (ICs) together in computer systems. This book will teach you how to expand your embedded system design by adding I<sup>2</sup>C peripherals with minimal wiring and software.</p>&#13;
<p>To paraphrase from <a class="LinkURL" href="https://i2c.info">https://i2c.info</a>, I<sup>2</sup>C uses only two wires to easily connect devices such as microcontrollers, A/D and D/A converters, digital I/O, memory, and many others, together in an embedded system. Although it was originally developed by Philips (now NXP Semiconductors), most major IC manufacturers now support I<sup>2</sup>C. I<sup>2</sup>C is popular because it is ubiquitous—most CPUs destined for embedded systems include support for I<sup>2</sup>C—and its peripheral ICs are inexpensive. It is present in hobbyist systems like Arduino and Raspberry Pi, as well as in most professional single-board computers (SBCs) intended for use in embedded systems.</p>&#13;
<p><span epub:type="pagebreak" id="Page_xx" title="xx"/>The I<sup>2</sup>C bus is especially important on hobbyist-level embedded systems employed by “makers” working on personal projects, which typically use a commercially available off-the-shelf (COTS) SBC like an Arduino Uno, Teensy 4.<em>x</em>, or Raspberry Pi as the brains for the system. Such SBCs generally have limited I/O capability or other limitations, so the addition of peripheral ICs may be necessary to realize a given design. The I<sup>2</sup>C bus is one of the most popular and common ways to expand such systems, since it’s easy, convenient, and inexpensive to use. Furthermore, there are hundreds of different devices available as individual ICs with a wide range of capabilities that connect directly to the I<sup>2</sup>C bus. Combined with a huge library of open source code to control these devices (especially for Arduino devices), it’s almost trivial to expand small systems using the I<sup>2</sup>C bus.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">NOTE</span></h2>&#13;
<p>	The SPI bus is another popular option for hobbyist systems, but discussing it will have to wait for a different book.</p>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
<p>Although higher-end custom SBCs intended for professional embedded systems often include many of the peripherals missing in hobbyist-grade SBCs, the I<sup>2</sup>C bus is still a cost-effective way to design such systems. Often, peripherals that don’t have high-performance requirements connect to the CPU on the SBC using the I<sup>2</sup>C bus.</p>&#13;
<p>Because of the ubiquity of the I<sup>2</sup>C, it is difficult to work on embedded systems these days without at least a passing familiarity with the I<sup>2</sup>C bus. Sadly, most programmers are expected to figure out how to use the I<sup>2</sup>C bus on their own by searching the internet and piecing together design and programming information. This book rectifies that situation, collecting into one comprehensive book the resources needed to fully understand how to design and program systems using the I<sup>2</sup>C bus. </p>&#13;
<h2 id="h1-502468f06-0001">Expectations and Prerequisites</h2>&#13;
<p class="BodyFirst">Working with I<sup>2</sup>C peripherals requires some hardware and software expertise. In theory, an electrical engineer with no software experience could design some hardware and hand it off to a software engineer with no hardware experience, and the two of them could get something working. However, this book is not intended to be read by such teams. Rather, it’s meant for software engineers who aren’t afraid to get their hands dirty by working directly with the hardware, or for hardware engineers who aren’t afraid to sit down with a text editor and write software.</p>&#13;
<p><em>The Book of I</em><sup><em>2</em></sup><em>C</em> assumes you are capable of reading schematics and wiring a COTS SBC (such as an Arduino, Pi, or other commercially available SBC) to various peripheral devices using breadboarding or point-to-point wiring on prototyping boards. You should be comfortable using tools such as DVMs, oscilloscopes, logic analyzers, and more to examine and debug such circuits. </p>&#13;
<p>This book also assumes you are familiar with the C/C++ programming language and are capable of creating, testing, and debugging decent-sized <span epub:type="pagebreak" id="Page_xxi" title="xxi"/>programs on the aforementioned SBCs. Although I<sup>2</sup>C code can be written in many different languages (including assembly language, Java, and Python), C/C++ is the universal language for embedded systems. Almost every COTS SBC’s development software supports using C/C++, so the book assumes prior knowledge of this language.</p>&#13;
<p>Most of the examples in this book use the Arduino library due to its widespread use and simplicity. Therefore, it assumes at least a passing familiarity with the Arduino system. The Raspberry Pi examples obviously use the Raspberry Pi OS (Linux) and the Pi OS I<sup>2</sup>C library code; the book provides links to the documentation for those libraries as appropriate. For other systems (for example, µC/OS running on a NetBurner module or MBED running on an STM32 module), this book assumes no prior knowledge and provides either the necessary information or links to the associated documentation.</p>&#13;
<p>The software tools for embedded system programming generally run on Windows, macOS, or Linux. You should be familiar with the particular system running these tools (for example, the C/C++ compilers) and capable of running those tools on your own system, including learning how to use, install, and configure those tools with their accompanying documentation. As necessary, this book will describe how to find those tools and their documentation; however, its focus is the I<sup>2</sup>C bus, not running C/C++ compilers and integrated development environments (IDEs), so it leaves you to learn more about tools on your own.</p>&#13;
<h2 id="h1-502468f06-0002">Source Code in This Book</h2>&#13;
<p class="BodyFirst">This book contains considerable C/C++ source code that comes in one of three forms: code snippets, modules, and full-blown programs. </p>&#13;
<p><em>Code snippets</em> are fragments of a program, provided to make a point or provide an example of some programming technique. They are not stand-alone, and you cannot compile them using a C/C++ compiler. Here is a typical example of a snippet:</p>&#13;
<pre><code>while( inputPin() == 0 )&#13;
{&#13;
   .&#13;
   .&#13;
   .&#13;
}</code></pre>&#13;
<p>The vertical ellipses in this example denote some arbitrary code that could appear in their place.</p>&#13;
<p><em>Modules</em> are small C/C++ code sections that are compilable but won’t run on their own. Modules typically contain a function that some other program will call. Here is a typical example:</p>&#13;
<pre><code>// inputPin function&#13;
&#13;
int inputPin( void )&#13;
<span epub:type="pagebreak" id="Page_xxii" title="xxii"/>{&#13;
    int p = readPort( 0x48 )&#13;
    return p &amp; 1;&#13;
}</code></pre>&#13;
<p>Full-blown programs are called <em>listings</em> in this book, and I refer to them by listing number or filename. For example, the following example listing for an Arduino “blink” program is taken from the file <em>Listing1-1.ino</em>. The name indicates that it is the first listing in Chapter 1, and I refer to it as <a href="#listing1-1" id="listinganchor1-1">Listing 1-1</a> in the surrounding text, labeling the code itself with the filename in the comments: </p>&#13;
<pre><code>// <a href="#listinganchor1-1" id="listing1-1">Listing1-1</a>.ino&#13;
//&#13;
// An Arduino ″Blink″ program.&#13;
&#13;
int led = 13;&#13;
&#13;
void setup()&#13;
{&#13;
    pinMode( led, OUTPUT );&#13;
}&#13;
&#13;
void loop() &#13;
{&#13;
  digitalWrite( led, HIGH );   // Turn on the LED&#13;
  delay( 500 );                // Wait for 1/2 second&#13;
  digitalWrite( led, LOW );    // Turn off the LED&#13;
  delay( 500 );                // Wait for a second&#13;
}</code></pre>&#13;
<p>Note that the <em>Listing1-1.ino</em> filename format applies only to code of my own making. Any other source code retains its original filename. For example, I refer to Chapter 16’s code from the TinyWire library as <em>attiny84_Periph.ino</em>. Certain non-Arduino systems (Pi OS and MBED, for example) use a standard <em>main.cpp</em> filename for their main programs; this book will generally place such programs in a subdirectory with a name such as <em>Listingx-x</em> and refer to that whole directory as the “listing.” Many listings in this book are sufficiently long that I’ve broken them up into sections with text annotation between the sections. In such instances, I will place a comment such as <code>// Listing10-1.ino (cont.)</code> at the beginning of each section to provide continuity.</p>&#13;
<p>All listings and modules are available in electronic form at my website <a class="LinkURL" href="https://bookofi2c.randallhyde.com">https://bookofi2c.randallhyde.com</a>, either individually or as a ZIP file containing all the listings and other support information for this book, including errata, electronic chapters, and more.</p>&#13;
<p>Unless otherwise noted, all source code appearing in this book is covered under the Creative Commons 4.0 license. You may freely use that code in your own projects as per the Creative Commons license. See <a class="LinkURL" href="https://creativecommons.org/licenses/by/4.0">https://creativecommons.org/licenses/by/4.0</a> for more details.</p>&#13;
<h2 id="h1-502468f06-0003"><span epub:type="pagebreak" id="Page_xxiii" title="xxiii"/>Typography and Pedantry</h2>&#13;
<p class="BodyFirst">Computer books have a habit of abusing the English language, and this book is no exception. Whenever source code snippets appear in the middle of an English sentence, there is often a conflict between the grammar rules of the programming language and English. In this section, I describe my choices for differentiating syntactical rules in English versus programming languages, in addition to a few other conventions.</p>&#13;
<p>First, this book uses a monospace font to denote any text that appears as part of a program source file. This includes variable and procedure function names, program output, and user input to a program. Therefore, when you see something like <code>get</code>, you know that the book is describing an identifier in a program, not commanding you to get something.</p>&#13;
<p>There are a few logic operations whose names also have common English meanings. These logic operations are AND, OR, and NOT. When using these terms as logic functions, this book uses all caps to help differentiate otherwise confusing English statements. When using these terms as English, this book uses the standard typeset font. The fourth logic operator, exclusive-OR (XOR), doesn’t normally appear in English statements, but this book still capitalizes it. </p>&#13;
<p>In general, I always try to define any acronym or abbreviation the first time I use it. If I haven’t used the term in a while, I often redefine it when I use it next. I’ve added a glossary where I define most of the acronyms (and other technical terms) appearing in this book. </p>&#13;
<p>Finally, hardcore electrical engineers will often use the term <em>buss</em> when describing a collection of electronic signals, especially when describing buss bars. However, I use the spellings <em>bus</em> and <em>buses</em> simply because they are more prevalent in literature discussing the I<sup>2</sup>C bus. </p>&#13;
<h2 id="h1-502468f06-0004">A Note About Terminology</h2>&#13;
<p class="BodyFirst">In 2020, several major electronics firms and other members of the Open Source Hardware Association (OSHWA) proposed changing the names of various SPI bus terms to eliminate terms that some find morally questionable. The electronics industry has long used the terms <em>master</em> and <em>slave</em> to describe the operating hierarchy of various devices in the system. There is no technical justification for these names; they don’t even precisely describe the relationship between devices, so better terms would be desirable even if other issues weren’t a factor.</p>&#13;
<p>Although this is a book about the I<sup>2</sup>C bus, not the SPI bus, I<sup>2</sup>C is probably next on the list (as SparkFun notes at <a class="LinkURL" href="https://www.sparkfun.com/spi_signal_names">https://www.sparkfun.com/spi_signal_names</a>). Though the I<sup>2</sup>C bus does not have pins using the names master or slave, the terms <em>master</em>, <em>slave</em>, <em>multimaster</em>, and <em>multislave</em> are common in I<sup>2</sup>C literature. This book substitutes the following more descriptive and less offensive terms, as per the OSHWA guidelines for the SPI bus:</p>&#13;
<ul>&#13;
<li><em/>Master becomes <em>controller</em></li>&#13;
<li><em/>Multimaster becomes <em>multicontroller</em></li>&#13;
<li><span epub:type="pagebreak" id="Page_xxiv" title="xxiv"/><em/>Slave becomes <em>peripheral</em></li>&#13;
<li><em/>Multislave becomes <em>multiperipheral</em></li>&#13;
</ul>&#13;
<p class="BodyContinued">Of course, <em>controller</em> and <em>peripheral</em> have their own meanings and may not always correspond to an I<sup>2</sup>C bus controller or peripheral device. However, context within this book will make it clear which meaning I intend. Considerable historical documentation continues to use the terms <em>master</em> and <em>slave</em>, but you can simply mentally convert between <em>master</em>/<em>controller</em> and <em>slave</em>/<em>peripheral</em>. To avoid confusion with such historical documentation, this book uses <em>master</em> and <em>slave</em> only when referring to external documentation that uses those terms.</p>&#13;
<h2 id="h1-502468f06-0005">Organization</h2>&#13;
<p class="BodyFirst">This book is organized into four parts as follows, in addition to appendixes and online chapters:</p>&#13;
<p class="ListHead"><b>Part I: Low-Level Protocols and Hardware</b></p>&#13;
<ol class="none">&#13;
<li>This part describes the signals and hardware for the I<sup>2</sup>C. Though you don’t necessarily need to know this information in order to design systems using the I<sup>2</sup>C bus or to write code to program peripherals, this knowledge is handy when debugging hardware and software that use the I<sup>2</sup>C bus. Part I also includes a software implementation of the I<sup>2</sup>C bus for those software engineers who relate more to code than electrical specifications, as well as a section on analyzing and debugging I<sup>2</sup>C bus transactions. Finally, the section concludes by discussing various real-world extensions to the I<sup>2</sup>C bus.</li>&#13;
</ol>&#13;
<p class="ListHead"><b>Part II: Hardware Implementations</b></p>&#13;
<ol class="none">&#13;
<li>This part describes several real-world implementations of the I<sup>2</sup>C bus. In particular, it reviews the I<sup>2</sup>C implementation of the following pieces of hardware:</li>&#13;
</ol>&#13;
<ul>&#13;
<li>Arduino systems (and compatibles)</li>&#13;
<li>The Teensy 3.<em>x</em> and 4.<em>x</em> SBC I<sup>2</sup>C implementations</li>&#13;
<li>The Raspberry Pi, BeagleBone Black, PINE64 and ROCKPro64, Onion, and other Linux systems</li>&#13;
<li>The STM32/Nucleo-144/Nucleo-64 I<sup>2</sup>C implementation</li>&#13;
<li>The NetBurner MOD54415 I<sup>2</sup>C implementation</li>&#13;
</ul>&#13;
<ol class="none">&#13;
<li>Part II also describes the following I<sup>2</sup>C bus implementations:</li>&#13;
</ol>&#13;
<ul>&#13;
<li>The Adafruit Feather bus</li>&#13;
<li>The SparkFun Qwiic bus</li>&#13;
<li>The Seeed Studio Grove bus</li>&#13;
</ul>&#13;
<p class="ListHead"><b><span epub:type="pagebreak" id="Page_xxv" title="xxv"/>Part III: Programming the I<sup>2</sup>C Bus</b></p>&#13;
<ol class="none">&#13;
<li>This part discusses programming devices on the I<sup>2</sup>C bus. It covers various generic programming techniques, such as real-time OS I<sup>2</sup>C programming, as well as providing specific real-world programming examples for Arduino, Raspberry Pi, Teensy, MBED, and NetBurner. Part III also describes how to implement an I<sup>2</sup>C using bare-metal programming techniques—those that work at the hardware level rather than calling library code.</li>&#13;
</ol>&#13;
<p class="ListHead"><b>Part IV: I<sup>2</sup>C Peripheral Programming Examples</b></p>&#13;
<ol class="none">&#13;
<li>This part provides programming examples for some common real-world I<sup>2</sup>C peripheral ICs, including the MCP23017 GPIO expander, ADS1115 16-bit A/D converter, MCP4725 D/A converter, and TCA9548A I<sup>2</sup>C multiplexer. Part IV also describes how to use a SparkFun Atto84 module as a custom I<sup>2</sup>C peripheral.</li>&#13;
</ol>&#13;
<p class="ListHead"><b>Appendixes</b></p>&#13;
<ol class="none">&#13;
<li>Appendix A is a snapshot of the Adafruit I<sup>2</sup>C Address Compilation, which lists the addresses of hundreds of commerically available I<sup>2</sup>C peripheral ICs.</li>&#13;
<li>Appendix B contains an overview of the online content. No matter how many pages I add to this book, it will be woefully incomplete. There are just too many I<sup>2</sup>C controllers and peripherals available. Furthermore, new peripherals will certainly appear after this book is published. To resolve this conundrum (and reduce the price you have to pay for this book), additional chapters are available online at <a class="LinkURL" href="https://bookofi2c.randallhyde.com">https://bookofi2c.randallhyde.com</a>. </li>&#13;
<li>The online content will cover (among other things) the following topics:</li>&#13;
</ol>&#13;
<ul>&#13;
<li>The MCP4728 quad DAC</li>&#13;
<li>The Maxim DS3502 digital potentiometer</li>&#13;
<li>The DS3231 precision real-time clock</li>&#13;
<li>The MCP9600 thermocouple amplifier</li>&#13;
<li>I<sup>2</sup>C displays</li>&#13;
<li>The SX1509 GPIO interface</li>&#13;
<li>The PCA9685 PCM/servo interface</li>&#13;
<li>The INA169 and INA218 current sensors</li>&#13;
<li>The MPR121 capacitive touch interface</li>&#13;
<li>The Raspberry Pi Pico SBC</li>&#13;
<li>Espressif ESP32 (and ESP8266) SBCs</li>&#13;
</ul>&#13;
<p class="ListHead"><b>Glossary</b></p>&#13;
<ol class="none">&#13;
<li>A list of the terms and acronyms appearing in this book.</li>&#13;
<li><span epub:type="pagebreak" id="Page_xxvi" title="xxvi"/>In addition to the online chapters, the website will contain help on constructing the circuitry appearing in this book and other information of interest to someone programming I<sup>2</sup>C peripherals. It will also contain a parts list for all the electronic projects appearing within this book. My goal is to continuously update this information as new (important) peripherals and controllers appear that utilize the I<sup>2</sup>C bus. </li>&#13;
</ol>&#13;
</section>&#13;
</div>&#13;
</body></html>