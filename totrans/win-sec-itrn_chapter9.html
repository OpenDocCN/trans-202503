<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" xml:lang="en" lang="en">
<head>
<title>9. Security Auditing</title>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="sbo-rt-content"><section aria-labelledby="ch9" epub:type="chapter" role="doc-chapter">
<hgroup>
<h2 class="CHAPTER" id="ch9">
<span class="CN"><span aria-label=" Page 281. " epub:type="pagebreak" id="pg_281" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">9</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">SECURITY AUDITING</samp></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener" height="386" src="../images/chapter.jpg" width="386"/></figure>
<p class="ChapterIntro">Intertwined with the access check process is the auditing process. An administrator can configure the system’s auditing mechanism to generate a log of accessed resources. Each log event will include details about the user and application that opened the resource and whether the access succeeded or failed. This information can help us identify incorrect security settings or detect malicious access to sensitive resources.</p>
<p class="TX">In this short chapter, we’ll first discuss where the resource access log gets stored once the kernel generates it. We’ll then describe how a system administrator can configure the audit mechanism. Finally, we’ll detail how to configure individual resources to generate audit log events through the SACL.</p>
<section aria-labelledby="sec1" epub:type="division">
<h3 class="H1" id="sec1"><span id="h1-71"></span><span aria-label=" Page 282. " epub:type="pagebreak" id="pg_282" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_B_11">The Security Event Log</samp></h3>
<p class="TNI1">Windows generates log events whenever an access check succeeds or fails. The kernel writes these log events to the <i>security event log</i>, which only administrators can access.</p>
<p class="TX">When performing access checks on kernel resources, Windows will generate the following types of audit events. The security event log represents these by using the event ID included in parentheses:</p>
<ul class="ul">
<li class="ListBullet">Object handle opened (<samp class="SANS_TheSansMonoCd_W5Regular_11">4656</samp>)</li>
<li class="ListBullet">Object handle closed (<samp class="SANS_TheSansMonoCd_W5Regular_11">4658</samp>)</li>
<li class="ListBullet">Object deleted (<samp class="SANS_TheSansMonoCd_W5Regular_11">4660</samp>)</li>
<li class="ListBullet">Object handle duplicated (<samp class="SANS_TheSansMonoCd_W5Regular_11">4690</samp>)</li>
<li class="ListBullet">SACL changed (<samp class="SANS_TheSansMonoCd_W5Regular_11">4717</samp>)</li>
</ul>
<p class="TX">When we access resources via kernel system calls such as <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp>, the auditing mechanism generates these events automatically. But for the object-related audit events, we must first configure two aspects of the system: we must set the system policy to generate audit events, and we must enable audit ACEs in the resource’s SACL. Let’s discuss each of these configuration requirements in turn.</p>
<section aria-labelledby="sec2" epub:type="division">
<h4 class="H2" id="sec2"><span id="h2-87"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Configuring the System Audit Policy</samp></h4>
<p class="TNI1">Most Windows users don’t need to capture audit information for kernel resources, so the audit policy is disabled by default. Enterprise environments commonly configure the audit policy through a <i>domain security policy</i>, which the enterprise network distributes to the individual devices.</p>
<p class="TX">Users not in an enterprise network can enable the audit policy manually. One way to do so is to edit the <i>local security policy</i>, which looks the same as the domain security policy but applies only to the current system. There are two types of audit policy: the legacy policy used prior to Windows 7 and the advanced audit policy. Using the advanced audit policy is recommended, as it provides more granular configuration; we won’t discuss the legacy policy further.</p>
<p class="TX">If you open the local security policy editor by running the <samp class="SANS_TheSansMonoCd_W5Regular_11">secpol.msc</samp> command in PowerShell, you can view the current configuration of the advanced audit policy, as shown in <a href="chapter9.xhtml#fig9-1">Figure 9-1</a>.</p>
<span aria-label=" Page 283. " epub:type="pagebreak" id="pg_283" role="doc-pagebreak"></span>
<figure class="IMG"><img alt="" class="img1" height="942" id="fig9-1" src="../images/Figure9-1.jpg" width="1388"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-1: The security policy editor showing the advanced audit policy</samp></p></figcaption>
</figure>
<p class="TX">As you can see, the categories in the audit policy aren’t currently configured. To explore how audit events are generated, we’ll use PowerShell to enable the required audit policy temporarily and run some example code. Any changes you make with PowerShell won’t be reflected in the local security policy, which will revert the next time it synchronizes (for example, during a reboot or when the group policy is updated on an enterprise network). You can force the settings to synchronize by running the command <samp class="SANS_TheSansMonoCd_W5Regular_11">gpupdate.exe /force</samp> as an administrator in PowerShell or at the command prompt.</p>
<p class="TX">Advanced audit policies have two levels: a top-level category and multiple subcategories. You can query for the top-level categories using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtAuditPolicy</samp>, as in <a href="chapter9.xhtml#Lis9-1">Listing 9-1</a>.</p>
<span id="Lis9-1"></span><pre><code>PS&gt; <b>Get-NtAuditPolicy</b>
Name               SubCategory Count
----               -----------------
System             5
Logon/Logoff       11
Object Access      14
Privilege Use      3
Detailed Tracking  6
Policy Change      6
Account Management 6
DS Access          4
Account Logon      4
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 9-1: The top-level audit policy categories</span></p>
<p class="TX"><span aria-label=" Page 284. " epub:type="pagebreak" id="pg_284" role="doc-pagebreak"></span>In the output, you can see the name of each category and a count of its subcategories. Each category also has an associated GUID, but this value is hidden by default. To see it, select the <samp class="SANS_TheSansMonoCd_W5Regular_11">Id</samp> property from the command’s output, as shown in <a href="chapter9.xhtml#Lis9-2">Listing 9-2</a>.</p>
<span id="Lis9-2"></span><pre><code>PS&gt; <b>Get-NtAuditPolicy | Select-Object Name, Id</b>
Name               Id
----               --
System             69979848-797a-11d9-bed3-505054503030
Logon/Logoff       69979849-797a-11d9-bed3-505054503030
Object Access      6997984a-797a-11d9-bed3-505054503030
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 9-2: Displaying category GUIDs</span></p>
<p class="TX">You can display the subcategories by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">ExpandCategory</samp> parameter. In <a href="chapter9.xhtml#Lis9-3">Listing 9-3</a>, we specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">System</samp> category by name and then expand the output to show its subcategories.</p>
<span id="Lis9-3"></span><pre><code>PS&gt; <b>Get-NtAuditPolicy -Category System -ExpandCategory</b>
Name                      Policy
----                      ------
Security State Change     Unchanged
Security System Extension Unchanged
System Integrity          Unchanged
IPsec Driver              Unchanged
Other System Events       Unchanged
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 9-3: Displaying the audit policy’s subcategories</span></p>
<p class="TX">You can also select a category by specifying its GUID using the <samp class="SANS_TheSansMonoCd_W5Regular_11">CategoryGuid</samp> parameter. The audit policy is based on these subcategories. Each subcategory policy can have one or more of the following values:</p>
<p class="RunInPara1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Unchanged</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">  </samp>The policy is not configured and should not be changed.</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Success  </samp>The policy should generate audit events when an auditable resource is opened successfully.</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Failure  </samp>The policy should generate audit events when an auditable resource can’t be opened.</p>
<p class="RunInPara2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">None  </samp>The policy should never generate an audit event.</p>
<p class="TX">In <a href="chapter9.xhtml#Lis9-3">Listing 9-3</a> the subcategories all show the value <samp class="SANS_TheSansMonoCd_W5Regular_11">Unchanged</samp>, which means no policy has been configured. We can enable kernel object auditing by running the commands shown in <a href="chapter9.xhtml#Lis9-4">Listing 9-4</a> as an administrator.</p>
<span id="Lis9-4"></span><pre><code>PS&gt; <b>Enable-NtTokenPrivilege SeSecurityPrivilege</b>
PS&gt; <b>Set-NtAuditPolicy -Category ObjectAccess -Policy Success, </b>
<b>Failure -PassThru</b>
Name                           Policy
----                           ------
File System                    Success, Failure
Registry                       Success, Failure
<span aria-label=" Page 285. " epub:type="pagebreak" id="pg_285" role="doc-pagebreak"></span>Kernel Object                  Success, Failure
SAM                            Success, Failure
Certification Services         Success, Failure
Application Generated          Success, Failure
Handle Manipulation            Success, Failure
File Share                     Success, Failure
Filtering Platform Packet Drop Success, Failure
Filtering Platform Connection  Success, Failure
Other Object Access Events     Success, Failure
Detailed File Share            Success, Failure
Removable Storage              Success, Failure
Central Policy Staging         Success, Failure
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 9-4: Setting the policy and viewing the resulting ObjectAccess audit policy list</span></p>
<p class="TX">Here, we’ve enabled the <samp class="SANS_TheSansMonoCd_W5Regular_11">Success</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Failure</samp> audit policies for all subcategories under <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectAccess</samp>. To make this modification, we need the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeSecurityPrivilege</samp> privilege. We can set a single subcategory rather than the entire category by name by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">SubCategoryName</samp> parameter or specifying the GUID using <samp class="SANS_TheSansMonoCd_W5Regular_11">SubCategoryGuid</samp>.</p>
<p class="TX">We confirm that the audit policy has been configured correctly by specifying the <samp class="SANS_TheSansMonoCd_W5Regular_11">PassThru</samp> parameter, which lists the modified <samp class="SANS_TheSansMonoCd_W5Regular_11">SubCategory</samp> objects. The output displays some important audit policies, including <samp class="SANS_TheSansMonoCd_W5Regular_11">File System</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Registry</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Kernel Object</samp>, which enable auditing on files, registry keys, and other kernel objects, respectively.</p>
<p class="TX">You can run the following command as an administrator to disable the change we made in <a href="chapter9.xhtml#Lis9-4">Listing 9-4</a>:</p>
<pre><code>PS&gt; <b>Set-NtAuditPolicy -Category ObjectAccess -Policy None</b>
</code></pre>
<p class="BodyContinued">Unless you need to enable the audit policy for some reason, it’s best to disable it once you’re finished experimenting.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h4 class="H2" id="sec3"><span id="h2-88"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Configuring the Per-User Audit Policy</samp></h4>
<p class="TNI1">In addition to configuring a system-wide policy, it’s also possible to configure the audit policy on a per-user basis. You could use this feature to add auditing to a specific user account in cases when the system does not define an overall audit policy. You could also use it to exclude a specific user account from auditing. To facilitate this behavior, the policy settings differ slightly for per-user policies:</p>
<p class="RunInPara1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Unchanged  </samp>The policy is not configured. When set, the policy should not be changed.</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">SuccessInclude  </samp>The policy should generate audit events on success, regardless of the system policy.</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">SuccessExclude  </samp>The policy should never generate audit events on success, regardless of the system policy.</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">FailureInclude  </samp>The policy should generate audit events on failure, regardless of the system policy.</p>
<p class="RunInPara"><span aria-label=" Page 286. " epub:type="pagebreak" id="pg_286" role="doc-pagebreak"></span><samp class="SANS_TheSansMonoCd_W7Bold_B_11">FailureExclude</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">  </samp>The policy should never generate audit events on failure, regardless of the system policy.</p>
<p class="RunInPara2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">None  </samp>The policy should never generate an audit event.</p>
<p class="TX">To configure a per-user policy, you can specify a SID to the <samp class="SANS_TheSansMonoCd_W5Regular_11">User</samp> parameter when using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-NtAuditPolicy</samp> command. This SID must represent a user account; it can’t represent a group, such as <i>Administrators</i>, or a service account, such as <i>SYSTEM</i>, or you’ll receive an error when setting the policy.</p>
<p class="TX"><a href="chapter9.xhtml#Lis9-5">Listing 9-5</a> configures a per-user policy for the current user. You must run these commands as an administrator.</p>
<span id="Lis9-5"></span><pre><code>PS&gt; <b>Enable-NtTokenPrivilege SeSecurityPrivilege</b>
PS&gt; <b>$sid = Get-NtSid</b>
PS&gt; <b>Set-NtAuditPolicy -Category ObjectAccess -User $sid -UserPolicy </b>
<b>SuccessExclude</b>
PS&gt; <b>Get-NtAuditPolicy -User $sid -Category ObjectAccess -ExpandCategory</b>
Name          User           Policy
----          ----           ------
File System   GRAPHITE\admin SuccessExclude
Registry      GRAPHITE\admin SuccessExclude
Kernel Object GRAPHITE\admin SuccessExclude
SAM           GRAPHITE\admin SuccessExclude
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 9-5: Configuring a per-user audit policy</span></p>
<p class="TX">Here, we specify the user’s SID to the <samp class="SANS_TheSansMonoCd_W5Regular_11">User</samp> parameter, then specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">SuccessExclude</samp> user policy. This will exclude success audit events for only this user. If you want to remove the per-user policy for a user, you can specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp> user policy:</p>
<pre><code>PS&gt; <b>Set-NtAuditPolicy -Category ObjectAccess -User $sid -UserPolicy None</b>
</code></pre>
<p class="TX">You can also enumerate all users who have configured policies using the <samp class="SANS_TheSansMonoCd_W5Regular_11">AllUser</samp> parameter of <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtAuditPolicy</samp>, as shown in <a href="chapter9.xhtml#Lis9-6">Listing 9-6</a>.</p>
<span id="Lis9-6"></span><pre><code>PS&gt; <b>Get-NtAuditPolicy -AllUser</b>
Name          User           SubCategory Count
----          ----           -----------------
System        GRAPHITE\admin 5
Logon/Logoff  GRAPHITE\admin 11
Object Access GRAPHITE\admin 14
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 9-6: Querying per-user policies for all users</span></p>
<p class="TX">You now know how to query and set policies for the system and for a specific user. Next, we’ll look at how to grant users the access needed to query and set these policies on the system.</p>
</section>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h3 class="H1" id="sec4"><span id="h1-72"></span><span aria-label=" Page 287. " epub:type="pagebreak" id="pg_287" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_B_11">Audit Policy Security</samp></h3>
<p class="TNI1">To query or set a policy, the caller must have <samp class="SANS_TheSansMonoCd_W5Regular_11">SeSecurityPrivilege</samp> enabled on their token. If the privilege is not enabled, LSASS will perform an access check based on a security descriptor in the system configuration. We can configure the following access rights in the security descriptor to grant a user the ability to query or set the policy for the system or a single user:</p>
<p class="RunInPara1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">SetSystemPolicy  </samp>Enables setting the system audit policy</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">QuerySystemPolicy  </samp>Enables querying the system audit policy</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">SetUserPolicy</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">  </samp>Enables setting a per-user audit policy</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">QueryUserPolicy  </samp>Enables querying a per-user audit policy</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">EnumerateUsers  </samp>Enables enumerating all per-user audit policies</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">SetMiscPolicy  </samp>Enables setting a miscellaneous audit policy</p>
<p class="RunInPara2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">QueryMiscPolicy  </samp>Enables querying a miscellaneous audit policy</p>
<p class="TX">No standard auditing API seems to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">SetMiscPolicy</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryMiscPolicy</samp> access rights, but because they are defined in the Windows SDK, I’ve included them here for completeness.</p>
<p class="TX">As an administrator, you can query the currently configured security descriptor by enabling <samp class="SANS_TheSansMonoCd_W5Regular_11">SeSecurityPrivilege</samp> and using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtAuditSecurity</samp> command, as shown in <a href="chapter9.xhtml#Lis9-7">Listing 9-7</a>.</p>
<span id="Lis9-7"></span><pre><code>PS&gt; <b>Enable-NtTokenPrivilege SeSecurityPrivilege</b>
PS&gt; <b>$sd =</b> <b>Get-NtAuditSecurity</b>
PS&gt;<b> Format-NtSecurityDescriptor $sd -Summary -MapGeneric</b>
&lt;DACL&gt;
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> BUILTIN\Administrators: (Allowed)(None)(GenericRead)
NT AUTHORITY\SYSTEM: (Allowed)(None)(GenericRead)
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 9-7: Querying and displaying the audit security descriptor</span></p>
<p class="TX">We pass the queried security descriptor to <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-NtSecurityDescriptor</samp> to display the DACL. Notice that only <i>Administrators</i> and <i>SYSTEM</i> can access the policy <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. Also, they’re limited to <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp> access, which allows users to query the policy but not modify it. Thus, even administrators will need to enable <samp class="SANS_TheSansMonoCd_W5Regular_11">SeSecurityPrivilege</samp> to modify the audit policy, as that privilege bypasses any access check.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>A user who has not been granted read access to the policy can still query the advanced audit categories and subcategories, which ignore the security descriptor. However, they won’t be granted access to query the configured settings. Get-NtAuditPolicy will return the value of Unchanged for audit settings the user wasn’t able to query.</i></p>
</blockquote>
<p class="TX">If you want to allow non-administrators to change the advanced audit policy, you can change the security descriptor using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-NtAuditSecurity</samp> command. Run the commands in <a href="chapter9.xhtml#Lis9-8">Listing 9-8</a> as an administrator.</p>
<span id="Lis9-8"></span><pre><code><span aria-label=" Page 288. " epub:type="pagebreak" id="pg_288" role="doc-pagebreak"></span>PS&gt; <b>Enable-NtTokenPrivilege SeSecurityPrivilege</b>
PS&gt; <b>$sd = Get-NtAuditSecurity</b>
PS&gt; <b>Add-NtSecurityDescriptorAce $sd -Sid "LA" -Access GenericAll</b>
PS&gt; <b>Set-NtAuditSecurity $sd</b>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 9-8: Modifying the audit security descriptor</span></p>
<p class="TX">We first query the existing security descriptor for the audit policy and grant the local administrator all access rights. Then we set the modified security descriptor using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-NtAuditSecurity</samp> command. Now the local administrator can query and modify the audit policy without needing to enable <samp class="SANS_TheSansMonoCd_W5Regular_11">SeSecurityPrivilege</samp>.</p>
<p class="TX">You shouldn’t normally reconfigure the security of the audit policy, and you certainly shouldn’t grant all users write access. Note that the security descriptor doesn’t affect who can query or set the security descriptor itself; only callers with <samp class="SANS_TheSansMonoCd_W5Regular_11">SeSecurityPrivilege</samp> enabled can do this, no matter the values in the security descriptor.</p>
<section aria-labelledby="sec5" epub:type="division">
<h4 class="H2" id="sec5"><span id="h2-89"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Configuring the Resource SACL</samp></h4>
<p class="TNI1">Just enabling the audit policies isn’t enough to start generating audit events. We also need to configure an object’s SACL to specify the auditing rules to use. To set the SACL on an object we’ll again need to enable <samp class="SANS_TheSansMonoCd_W5Regular_11">SeSecurityPrivilege</samp>, which can only be done as an administrator. <a href="chapter9.xhtml#Lis9-9">Listing 9-9</a> demonstrates the process for creating a <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> object with a SACL.</p>
<span id="Lis9-9"></span><pre><code>PS&gt; <b>$sd = New-NtSecurityDescriptor -Type Mutant</b>
PS&gt; <b>Add-NtSecurityDescriptorAce $sd -Type Audit -Access GenericAll</b>
<b>-Flags SuccessfulAccess, FailedAccess -KnownSid World -MapGeneric</b>
PS&gt; <b>Enable-NtTokenPrivilege SeSecurityPrivilege</b>
PS&gt; <b>Clear-EventLog -LogName "Security"</b>
PS&gt; <b>Use-NtObject($m = New-NtMutant "ABC" -Win32Path -SecurityDescriptor $sd) {</b>
    <b>Use-NtObject($m2 = Get-NtMutant "ABC" -Win32Path) {</b>
    <b>}</b>
<b>}</b>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 9-9: Creating a Mutant object with a SACL</span></p>
<p class="TX">We start by creating an empty security descriptor, then add a single <samp class="SANS_TheSansMonoCd_W5Regular_11">Audit</samp> ACE to the SACL. Other ACE types we could add include <samp class="SANS_TheSansMonoCd_W5Regular_11">AuditObject</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">AuditCallback</samp>.</p>
<p class="TX">The processing of <samp class="SANS_TheSansMonoCd_W5Regular_11">Audit</samp> ACEs looks a lot like the discretionary access check described in <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>. The SID must match a group in the calling token (including any <samp class="SANS_TheSansMonoCd_W5Regular_11">DenyOnly</samp> SIDs), and the access mask must match one or more bits of the granted access. The <i>Everyone</i> group’s SID is a special case; it will always match, regardless of whether the SID is available in the token.</p>
<p class="TX">In addition to any of the usual inheritance ACE flags, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritOnly</samp>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Audit</samp> ACE must specify one or both of the <samp class="SANS_TheSansMonoCd_W5Regular_11">SuccessfulAccess</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">FailedAccess</samp> flags, which provide the auditing code with the conditions in which it should generate the audit entry.</p>
<p class="TX"><span aria-label=" Page 289. " epub:type="pagebreak" id="pg_289" role="doc-pagebreak"></span>We’ll create the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> object with a security descriptor containing the SACL. Before creating the object, we need to enable <samp class="SANS_TheSansMonoCd_W5Regular_11">SeSecurityPrivilege</samp>. If we don’t do this, the creation will fail. To make it easier to see the generated audit event, we also clear the security event log. Next, we create the object, passing it the SACL we built, and then reopen it to trigger the generation of an audit log.</p>
<p class="TX">Now we can query the security event log using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-WinEvent</samp>, passing it the event ID <samp class="SANS_TheSansMonoCd_W5Regular_11">4656</samp> to find the generated audit event (<a href="chapter9.xhtml#Lis9-10">Listing 9-10</a>).</p>
<span id="Lis9-10"></span><pre><code>PS&gt; <b>$filter = @{logname = 'Security'; id = @(4656)}</b>
PS&gt; <b>Get-WinEvent -FilterHashtable $filter | Select-Object -ExpandProperty Message</b>
A handle to an object was requested.
Subject:
        Security ID:    S-1-5-21-2318445812-3516008893-216915059-1002
        Account Name:   user
        Account Domain: GRAPHITE
        Logon ID:       0x524D0

Object:
        Object Server:          Security
        Object Type:            Mutant
        Object Name:            \Sessions\2\BaseNamedObjects\ABC
        Handle ID:              0xfb4
        Resource Attributes:    -

Process Information:
        Process ID:     0xaac
        Process Name:   C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe

Access Request Information:
        Transaction ID:        <b> </b>{00000000-0000-0000-0000-000000000000}
        Accesses:               DELETE
                                READ_CONTROL
                                WRITE_DAC
                                WRITE_OWNER
                                SYNCHRONIZE
                                Query mutant state

        Access Reasons:                         -
        Access Mask:                            0x1F0001
        Privileges Used for Access Check:       -
        Restricted SID Count:                   0
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 9-10: Viewing the open audit event for the Mutant object</span></p>
<p class="TX">We first set up a filter for the security event log and event ID <samp class="SANS_TheSansMonoCd_W5Regular_11">4656</samp>, which corresponds to the opening of a handle. We then use the filter with <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-WinEvent</samp> and select the event’s textual message.</p>
<p class="TX">The output begins with this textual description of the event, which confirms that it was generated in response to a handle being opened. After this comes the <samp class="SANS_TheSansMonoCd_W5Regular_11">Subject</samp>, which includes the user’s information, including their <span aria-label=" Page 290. " epub:type="pagebreak" id="pg_290" role="doc-pagebreak"></span>SID and username. To look up the username, the kernel sends the audit event to the LSASS process.</p>
<p class="TX">Next are the details of the opened object. These include the object server (<samp class="SANS_TheSansMonoCd_W5Regular_11">Security</samp>, representing the SRM), the object type (<samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>), and the native path to the object, as well as the handle ID (the handle number for the object). If you query the handle value returned from the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp> system call, it should match this value. We then get some basic process information, and finally some information about the access granted to the handle.</p>
<p class="TX">How can we distinguish between success and failure events? The best way to do this is to extract the <samp class="SANS_TheSansMonoCd_W5Regular_11">KeywordsDisplayNames</samp> property, which contains either <samp class="SANS_TheSansMonoCd_W5Regular_11">Audit Success</samp> if the handle was opened or <samp class="SANS_TheSansMonoCd_W5Regular_11">Audit Failure</samp> if the handle could not be opened. <a href="chapter9.xhtml#Lis9-11">Listing 9-11</a> shows an example.</p>
<span id="Lis9-11"></span><pre><code>PS&gt; <b>Get-WinEvent -FilterHashtable $filter | Select-Object KeywordsDisplayNames</b>
KeywordsDisplayNames
--------------------
{Audit Success}
{Audit Failure}
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 9-11: Extracting KeywordsDisplayNames to view the success or failure status</span></p>
<p class="TX">When you close the handle to the object you’ll get another audit event, with the event ID <samp class="SANS_TheSansMonoCd_W5Regular_11">4658</samp>, as shown in <a href="chapter9.xhtml#Lis9-12">Listing 9-12</a>.</p>
<span id="Lis9-12"></span><pre><code>PS&gt; <b>$filter = @{logname = 'Security'; id = @(4658)}</b>
PS&gt; <b>Get-WinEvent -FilterHashtable $filter | Select-Object -ExpandProperty Message</b>
The handle to an object was closed.
Subject :
        Security ID:    S-1-5-21-2318445812-3516008893-216915059-1002
        Account Name:   user
        Account Domain: GRAPHITE
        Logon ID:       0x524D0

Object:
        Object Server:  Security
        Handle ID:      0xfb4

Process Information:
        Process ID:     0xaac
        Process Name:   C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 9-12: Viewing the audit event generated when the Mutant object handle is closed</span></p>
<p class="TX">You might notice that the information provided about the closing of the object handle is slightly less detailed than the information generated when the handle was opened. You can manually correlate the open and close handle events by using the handle IDs, which should match.</p>
<p class="TX">It’s possible to generate object audit events manually from user mode using some additional system calls. However, to do so you need the <span aria-label=" Page 291. " epub:type="pagebreak" id="pg_291" role="doc-pagebreak"></span><samp class="SANS_TheSansMonoCd_W5Regular_11">SeAuditPrivilege</samp> privilege, which is typically only granted to the <i>SYSTEM</i> account, not to normal administrators.</p>
<p class="TX">You can generate the audit event at the same time as an access check using the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAccessCheckAndAuditAlarm</samp> system call, which has all the same object ACE variants as the normal access checks do. You can access it using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtGrantedAccess</samp> PowerShell command with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Audit</samp> parameter.</p>
<p class="TX">You can also generate events manually using the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtOpenObjectAuditAlarm</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCloseObjectAuditAlarm</samp> system calls, which PowerShell exposes through the <samp class="SANS_TheSansMonoCd_W5Regular_11">Write-NtAudit</samp> command. Run the commands in <a href="chapter9.xhtml#Lis9-13">Listing 9-13</a> as the <i>SYSTEM</i> user to manually generate audit log events.</p>
<span id="Lis9-13"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>Enable-NtTokenPrivilege SeAuditPrivilege -WarningAction Stop</b>
PS&gt; <b>$owner = Get-NtSid -KnownSid Null</b>
PS&gt; <b>$sd = New-NtSecurityDescriptor -Type Mutant -Owner $owner -Group $owner</b>
PS&gt; <b>Add-NtSecurityDescriptorAce $sd -KnownSid World -Access GenericAll </b>
<b>-MapGeneric</b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>Add-NtSecurityDescriptorAce $sd -Type Audit -Access GenericAll</b>
<b>-Flags SuccessfulAccess, FailedAccess -KnownSid World -MapGeneric</b>
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>$handle = 0x1234</b>
<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> PS&gt; <b>$r = Get-NtGrantedAccess $sd -Audit -SubsystemName "SuperSecurity"</b>
<b>-ObjectTypeName "Badger" -ObjectName "ABC" -ObjectCreation</b>
<b>-HandleId $handle -PassResult</b>
<span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> PS&gt; <b>Write-NtAudit -Close -SubsystemName "SuperSecurity" -HandleId $handle</b>
<b>-GenerateOnClose:$r.GenerateOnClose</b>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 9-13: Manually generating audit log events</span></p>
<p class="TX">We start by enabling <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAuditPrivilege</samp> <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, as otherwise the rest of the script will fail. This privilege must be enabled on the primary token; you can’t impersonate a token with the privilege, which is why you must run the PowerShell instance as the <i>SYSTEM</i> user.</p>
<p class="TX">After enabling the required privilege, we build a security descriptor with a SACL to audit successful and failed access attempts <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. We generate a fake handle ID <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>; this value would be the kernel handle in a normal audit event, but when we generate an event from user mode it can be any value we like. We can then run the access check, specifying the <samp class="SANS_TheSansMonoCd_W5Regular_11">Audit</samp> parameter, which enables the other auditing parameters. We need to specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">SubsystemName</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectTypeName</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectName</samp> parameters, which can be completely arbitrary. We also specify the handle ID <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>.</p>
<p class="TX">In the output, we receive an access check result with one additional property: <samp class="SANS_TheSansMonoCd_W5Regular_11">GenerateOnClose</samp>, which indicates whether we need to write a closed handle event. Calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">Write-NtAudit</samp> command and specifying the <samp class="SANS_TheSansMonoCd_W5Regular_11">Close</samp> parameter will call the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCloseObjectAuditAlarm</samp> system call to generate the event. We do so, specifying the <samp class="SANS_TheSansMonoCd_W5Regular_11">GenerateOnClose</samp> value from the result <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>. If <samp class="SANS_TheSansMonoCd_W5Regular_11">GenerateOnClose</samp> were <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>, we would still need to write the close event to complete the audit, but the actual close event would not be written to the audit log.</p>
<p class="TX">If you don’t receive any audit events when you run the commands in <a href="chapter9.xhtml#Lis9-13">Listing 9-13</a>, ensure that you’ve enabled object auditing, as we did in <a href="chapter9.xhtml#Lis9-4">Listing 9-4</a>.</p>
<aside aria-label="box-8" class="box">
<p class="BoxTitle" id="box-8"><span aria-label=" Page 292. " epub:type="pagebreak" id="pg_292" role="doc-pagebreak"></span><samp class="SANS_Dogma_OT_Bold_B_11">THE MYSTERIOUS ALARM ACE</samp></p>
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">In the list of ACE types in <a href="chapter5.xhtml#tab5-3">Table 5-3</a>, you might have noticed the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Alarm</samp> <samp class="SANS_Futura_Std_Book_11">type that is related to auditing. I mentioned in the table that the kernel does not use this type, and if you read the Microsoft technical documentation for the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Alarm</samp> <samp class="SANS_Futura_Std_Book_11">ACE type you’ll see the phrase “The</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">SYSTEM_ALARM_ACE</samp> <samp class="SANS_Futura_Std_Book_11">structure is reserved for future use.” What is its purpose, if it’s always been reserved?</samp></p>
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">It’s hard to tell. Kernel code checked for the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Alarm</samp> <samp class="SANS_Futura_Std_Book_11">ACE type starting in Windows NT 3.1, until Microsoft removed the check in Windows XP. The Windows developers even defined</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">AlarmCallback</samp><samp class="SANS_Futura_Std_Book_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">AlarmObject</samp><samp class="SANS_Futura_Std_Book_11">, and</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">AlarmObjectCallback</samp> <samp class="SANS_Futura_Std_Book_11">variants, though code doesn’t seem to have checked these in the Windows 2000 kernel, where object ACEs were introduced. It is clear from old kernels that the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Alarm</samp> <samp class="SANS_Futura_Std_Book_11">ACE type was handled; less clear is whether an</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Alarm</samp> <samp class="SANS_Futura_Std_Book_11">ACE could generate an event to be monitored. Even in the documentation for versions of Windows that handled the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Alarm</samp> <samp class="SANS_Futura_Std_Book_11">ACE type, it is marked as unsupported.</samp></p>
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">As to what the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Alarm</samp> <samp class="SANS_Futura_Std_Book_11">ACE might have done, it’s likely a holdover from Windows NT’s VMS roots. VMS had a similar security model to Windows NT, including the use of ACLs and ACEs. In VMS, audit ACEs are written to an audit logfile, as on Windows, and the alarm ACEs would generate real-time ephemeral security events in the system console or an operator’s terminal once a user enabled alarms using the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">REPLY/ENABLE=SECURITY</samp> <samp class="SANS_Futura_Std_Book_11">command. It’s likely that Microsoft added support for this ACE type to the Windows kernel but never implemented the ability to send these real-time events. With modern logging alternatives such as Event Tracing for Windows (ETW), which provides much more comprehensive security information in real time, the chances of Microsoft reintroducing the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Alarm</samp> <samp class="SANS_Futura_Std_Book_11">ACE (or implementing its variants) in the future are slim.</samp></p>
</aside>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h4 class="H2" id="sec6"><span id="h2-90"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Configuring the Global SACL</samp></h4>
<p class="TNI1">Correctly configuring the SACL for every resource can be difficult, as well as time-consuming. For this reason, the advanced audit policy allows you to configure a global SACL for files or registry keys. The system will use this global SACL if no SACL exists for a resource, and for resources that already have a SACL, it will merge the global and resource SACLs. Because these broad auditing configurations can swamp your logging output and impede your ability to monitor events, I recommend that you use global SACLs sparingly.</p>
<p class="TX">You can query the global SACL by specifying either the <samp class="SANS_TheSansMonoCd_W5Regular_11">File</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Key</samp> value to the <samp class="SANS_TheSansMonoCd_W5Regular_11">GlobalSacl</samp> parameter of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtAuditSecurity</samp> PowerShell command. You can also modify the global SACL with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-NtAuditSecurity</samp> command, specifying the same <samp class="SANS_TheSansMonoCd_W5Regular_11">GlobalSacl</samp> parameter. To test this behavior, run the commands in <a href="chapter9.xhtml#Lis9-14">Listing 9-14</a> as an administrator.</p>
<span id="Lis9-14"></span><pre><code><span aria-label=" Page 293. " epub:type="pagebreak" id="pg_293" role="doc-pagebreak"></span>PS&gt; <b>Enable-NtTokenPrivilege SeSecurityPrivilege</b>
PS&gt; <b>$sd = New-NtSecurityDescriptor -Type File</b>
PS&gt; <b>Add-NtSecurityDescriptorAce $sd -Type Audit -KnownSid World</b>
<b>-Access WriteData -Flags SuccessfulAccess</b>
PS&gt; <b>Set-NtAuditSecurity -GlobalSacl File -SecurityDescriptor $sd</b>
PS&gt; <b>Get-NtAuditSecurity -GlobalSacl File |</b>
<b>Format-NtSecurityDescriptor -SecurityInformation Sacl -Summary</b>
&lt;SACL&gt;
Everyone: (Audit)(SuccessfulAccess)(WriteData)
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 9-14: Setting and querying the global file SACL</span></p>
<p class="TX">We start by building a security descriptor containing a SACL with a single <samp class="SANS_TheSansMonoCd_W5Regular_11">Audit</samp> ACE. We then call <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-NtAuditSecurity</samp> to set the global SACL for the <samp class="SANS_TheSansMonoCd_W5Regular_11">File</samp> type. Finally, we query the global SACL to make sure it’s set correctly.</p>
<p class="TX">You can remove the global SACL by passing a security descriptor with a NULL SACL to <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-NtAuditSecurity</samp>. To create this security descriptor, use the following command:</p>
<pre><code>PS&gt; <b>$sd = New-NtSecurityDescriptor -NullSacl</b></code></pre>
</section>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h3 class="H1" id="sec7"><span id="h1-73"></span><samp class="SANS_Futura_Std_Bold_B_11">Worked Examples</samp></h3>
<p class="TNI1">Let’s wrap up with some worked examples that use the commands you learned about in this chapter.</p>
<section aria-labelledby="sec8" epub:type="division">
<h4 class="H2" id="sec8"><span id="h2-91"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Verifying Audit Access Security</samp></h4>
<p class="TNI1">When you’re checking whether malicious code has compromised an untrusted Windows system, it’s a good idea to verify that the security settings haven’t been modified. One check you might want to perform is determining whether a non-administrator user has the access needed to change the audit policy on the system. If a non-administrator user can change the policy, they could disable auditing and hide their access to sensitive resources.</p>
<p class="TX">We can inspect the audit policy’s security descriptor manually, or do so using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtGrantedAccess</samp> PowerShell command. Run the commands in <a href="chapter9.xhtml#Lis9-15">Listing 9-15</a> as an administrator.</p>
<span id="Lis9-15"></span><pre><code>PS&gt; <b>Enable-NtTokenPrivilege SeSecurityPrivilege</b>
PS&gt; <b>$sd = Get-NtAuditSecurity</b>
PS&gt; <b>Set-NtSecurityDescriptorOwner $sd -KnownSid LocalSystem</b>
PS&gt; <b>Set-NtSecurityDescriptorGroup $sd -KnownSid LocalSystem</b>
PS&gt; <b>Get-NtGrantedAccess $sd -PassResult</b>
Status         Granted Access Privileges
------         -------------- ----------
STATUS_SUCCESS GenericRead    NONE

<span aria-label=" Page 294. " epub:type="pagebreak" id="pg_294" role="doc-pagebreak"></span>PS&gt; <b>Use-NtObject($token = Get-NtToken -Filtered -Flags LuaToken) {</b>
  <b>Get-NtGrantedAccess $sd -Token $token -PassResult</b>
<b>}</b>
Status               Granted Access Privileges
------               -------------- ----------
STATUS_ACCESS_DENIED 0              NONE
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 9-15: Performing an access check on the audit policy security descriptor</span></p>
<p class="TX">We start by querying for the audit policy security descriptor and setting the <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Group</samp> fields. These fields are required for the access check process, but the security descriptor returned from the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtAuditSecurity</samp> command does not contain them.</p>
<p class="TX">We can then pass the security descriptor to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtGrantedAccess</samp> command to check it against the current administrator token. The result indicates the caller has <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp> access to the audit policy, which allows them to query the policy but not set it without enabling <samp class="SANS_TheSansMonoCd_W5Regular_11">SeSecurityPrivilege</samp>.</p>
<p class="TX">Finally, we can remove the <i>Administrators</i> group from the token by creating a filtered token with the <samp class="SANS_TheSansMonoCd_W5Regular_11">LuaToken</samp> flag. Running the access check with the filtered token indicates that it has no granted access to the audit policy (not even read access). If this second check returns a status other than <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_ACCESS_DENIED</samp>, you can conclude that the default audit policy security descriptor has been changed, and it’s worth checking whether this was done intentionally or maliciously.</p>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h4 class="H2" id="sec9"><span id="h2-92"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding Resources with Audit ACEs</samp></h4>
<p class="TNI1">Most resources aren’t configured with a SACL, so you might want to enumerate the resources on the system that have one. This can help you understand what resources might generate audit log events. <a href="chapter9.xhtml#Lis9-16">Listing 9-16</a> provides a simple example in which we find these resources. Run the commands as an administrator.</p>
<span id="Lis9-16"></span><pre><code>PS&gt; <b>Enable-NtTokenPrivilege SeDebugPrivilege, SeSecurityPrivilege</b>
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$ps = Get-NtProcess -Access QueryLimitedInformation, AccessSystemSecurity</b>
<b>-FilterScript {</b>
<b>  </b><span aria-label="annotation2" class="CodeAnnotationCode2">❷</span><b> $sd = Get-NtSecurityDescriptor $_ -SecurityInformation Sacl</b>
    <b>$sd.HasAuditAce</b>
<b>}</b>
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>$ps | Format-NtSecurityDescriptor -SecurityInformation Sacl</b>
Path: \Device\HarddiskVolume3\Windows\System32\lsass.exe
Type: Process
Control: SaclPresent

&lt;SACL&gt;
 - Type  : Audit
 - Name  : Everyone
 - SID   : S-1-1-0
 - Mask  : 0x00000010
 <span aria-label=" Page 295. " epub:type="pagebreak" id="pg_295" role="doc-pagebreak"></span><span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> - Access: VmRead
 - Flags : SuccessfulAccess, FailedAccess

PS&gt; <b>$ps.Close()</b>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 9-16: Finding processes with configured SACLs</span></p>
<p class="TX">We focus on <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp> objects here, but you can apply this same approach to other resource types.</p>
<p class="TX">We first open all processes for <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryLimitedInformation</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp> access <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. We apply a filter to the processes, querying for the SACL from the <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp> object, then returning the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">HasAuditAce</samp> property <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. This property indicates whether the security descriptor has at least one audit ACE.</p>
<p class="TX">We then pipe the results returned from the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtProcess</samp> command into <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-NtSecurityDescriptor</samp> to display the SACLs <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. In this case, there is only a single entry, for the LSASS process. We can see that the audit ACE logs an event whenever the LSASS process is opened for <samp class="SANS_TheSansMonoCd_W5Regular_11">VmRead</samp> access <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>.</p>
<p class="TX">This policy is a default audit configuration on Windows, used to detect access to the LSASS process. The <samp class="SANS_TheSansMonoCd_W5Regular_11">VmRead</samp> access right allows a caller to read the virtual memory of a process, and this ACE aims to detect the extraction of the LSASS memory contents, which can include passwords and other authentication credentials. If the process is opened for any other access right, no audit log entry will be generated.</p>
</section>
</section>
<section aria-labelledby="sec10" epub:type="division">
<h3 class="H1" id="sec10"><span id="h1-74"></span><samp class="SANS_Futura_Std_Bold_B_11">Wrapping Up</samp></h3>
<p class="TNI1">In this chapter, we covered the basics of security auditing. We started with a description of the security event log and the types of log entries you might find when auditing resource access. Next, we looked at configuring the audit policy and setting advanced audit policies with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-NtAuditPolicy</samp> command. We also discussed how Windows controls access to the audit policy and the importance of the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeSecurityPrivilege</samp> privilege, used for almost all audit-related configuration.</p>
<p class="TX">To enable auditing on an object, we must modify the SACL to define rules for generating the events enabled by the policy. We walked through examples of generating audit events automatically, using the SACL, and manually, during a user-mode access check.</p>
<p class="TX">We’ve now covered all aspects of the SRM: security access tokens, security descriptors, access checking, and auditing. In the rest of this book, we’ll explore the various mechanisms to authenticate to a Windows system.</p>
</section>
</section>
</div></body>
</html>